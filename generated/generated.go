// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	GetGuides() GetGuidesResolver
	GetMods() GetModsResolver
	GetMyMods() GetMyModsResolver
	GetMyVersions() GetMyVersionsResolver
	GetSMLVersions() GetSMLVersionsResolver
	GetVersions() GetVersionsResolver
	Guide() GuideResolver
	Mod() ModResolver
	Mutation() MutationResolver
	Query() QueryResolver
	SMLVersion() SMLVersionResolver
	SMLVersionTarget() SMLVersionTargetResolver
	User() UserResolver
	UserMod() UserModResolver
	Version() VersionResolver
	VersionTarget() VersionTargetResolver
}

type DirectiveRoot struct {
	CanApproveMods              func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	CanApproveVersions          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	CanEditAnnouncements        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	CanEditGuide                func(ctx context.Context, obj interface{}, next graphql.Resolver, field string) (res interface{}, err error)
	CanEditMod                  func(ctx context.Context, obj interface{}, next graphql.Resolver, field string) (res interface{}, err error)
	CanEditModCompatibility     func(ctx context.Context, obj interface{}, next graphql.Resolver, field *string) (res interface{}, err error)
	CanEditSatisfactoryVersions func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	CanEditUser                 func(ctx context.Context, obj interface{}, next graphql.Resolver, field string, object bool) (res interface{}, err error)
	CanEditUsers                func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	CanEditVersion              func(ctx context.Context, obj interface{}, next graphql.Resolver, field string) (res interface{}, err error)
	CanManageTags               func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	IsLoggedIn                  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	IsNotLoggedIn               func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Announcement struct {
		ID         func(childComplexity int) int
		Importance func(childComplexity int) int
		Message    func(childComplexity int) int
	}

	Compatibility struct {
		Note  func(childComplexity int) int
		State func(childComplexity int) int
	}

	CompatibilityInfo struct {
		Ea  func(childComplexity int) int
		Exp func(childComplexity int) int
	}

	CreateVersionResponse struct {
		AutoApproved func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	GetGuides struct {
		Count  func(childComplexity int) int
		Guides func(childComplexity int) int
	}

	GetMods struct {
		Count func(childComplexity int) int
		Mods  func(childComplexity int) int
	}

	GetMyMods struct {
		Count func(childComplexity int) int
		Mods  func(childComplexity int) int
	}

	GetMyVersions struct {
		Count    func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	GetSMLVersions struct {
		Count       func(childComplexity int) int
		SmlVersions func(childComplexity int) int
	}

	GetVersions struct {
		Count    func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	Group struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Guide struct {
		CreatedAt        func(childComplexity int) int
		Guide            func(childComplexity int) int
		ID               func(childComplexity int) int
		Name             func(childComplexity int) int
		ShortDescription func(childComplexity int) int
		Tags             func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		User             func(childComplexity int) int
		UserID           func(childComplexity int) int
		Views            func(childComplexity int) int
	}

	LatestVersions struct {
		Alpha   func(childComplexity int) int
		Beta    func(childComplexity int) int
		Release func(childComplexity int) int
	}

	Mod struct {
		Approved         func(childComplexity int) int
		Authors          func(childComplexity int) int
		Compatibility    func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		CreatorID        func(childComplexity int) int
		Downloads        func(childComplexity int) int
		FullDescription  func(childComplexity int) int
		Hidden           func(childComplexity int) int
		Hotness          func(childComplexity int) int
		ID               func(childComplexity int) int
		LastVersionDate  func(childComplexity int) int
		LatestVersions   func(childComplexity int) int
		Logo             func(childComplexity int) int
		ModReference     func(childComplexity int) int
		Name             func(childComplexity int) int
		Popularity       func(childComplexity int) int
		ShortDescription func(childComplexity int) int
		SourceURL        func(childComplexity int) int
		Tags             func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		Version          func(childComplexity int, version string) int
		Versions         func(childComplexity int, filter map[string]interface{}) int
		Views            func(childComplexity int) int
	}

	ModVersion struct {
		ID           func(childComplexity int) int
		ModReference func(childComplexity int) int
		Versions     func(childComplexity int) int
	}

	Mutation struct {
		ApproveMod                       func(childComplexity int, modID string) int
		ApproveVersion                   func(childComplexity int, versionID string) int
		CreateAnnouncement               func(childComplexity int, announcement NewAnnouncement) int
		CreateGuide                      func(childComplexity int, guide NewGuide) int
		CreateMod                        func(childComplexity int, mod NewMod) int
		CreateMultipleTags               func(childComplexity int, tagNames []*NewTag) int
		CreateSatisfactoryVersion        func(childComplexity int, input NewSatisfactoryVersion) int
		CreateTag                        func(childComplexity int, tagName string, description string) int
		CreateVersion                    func(childComplexity int, modID string) int
		DeleteAnnouncement               func(childComplexity int, announcementID string) int
		DeleteGuide                      func(childComplexity int, guideID string) int
		DeleteMod                        func(childComplexity int, modID string) int
		DeleteSatisfactoryVersion        func(childComplexity int, id string) int
		DeleteTag                        func(childComplexity int, tagID string) int
		DeleteVersion                    func(childComplexity int, versionID string) int
		DenyMod                          func(childComplexity int, modID string) int
		DenyVersion                      func(childComplexity int, versionID string) int
		DiscourseSso                     func(childComplexity int, sso string, sig string) int
		FinalizeCreateVersion            func(childComplexity int, modID string, versionID string, version NewVersion) int
		Logout                           func(childComplexity int) int
		OAuthFacebook                    func(childComplexity int, code string, state string) int
		OAuthGithub                      func(childComplexity int, code string, state string) int
		OAuthGoogle                      func(childComplexity int, code string, state string) int
		UpdateAnnouncement               func(childComplexity int, announcementID string, announcement UpdateAnnouncement) int
		UpdateGuide                      func(childComplexity int, guideID string, guide UpdateGuide) int
		UpdateMod                        func(childComplexity int, modID string, mod UpdateMod) int
		UpdateModCompatibility           func(childComplexity int, modID string, compatibility CompatibilityInfoInput) int
		UpdateMultipleModCompatibilities func(childComplexity int, modIDs []string, compatibility CompatibilityInfoInput) int
		UpdateSatisfactoryVersion        func(childComplexity int, id string, input UpdateSatisfactoryVersion) int
		UpdateTag                        func(childComplexity int, tagID string, newName string, description string) int
		UpdateUser                       func(childComplexity int, userID string, input UpdateUser) int
		UpdateVersion                    func(childComplexity int, versionID string, version UpdateVersion) int
		UploadVersionPart                func(childComplexity int, modID string, versionID string, part int, file graphql.Upload) int
	}

	OAuthOptions struct {
		Facebook func(childComplexity int) int
		Github   func(childComplexity int) int
		Google   func(childComplexity int) int
	}

	Query struct {
		CheckVersionUploadState      func(childComplexity int, modID string, versionID string) int
		GetAnnouncement              func(childComplexity int, announcementID string) int
		GetAnnouncements             func(childComplexity int) int
		GetAnnouncementsByImportance func(childComplexity int, importance AnnouncementImportance) int
		GetGuide                     func(childComplexity int, guideID string) int
		GetGuides                    func(childComplexity int, filter map[string]interface{}) int
		GetMe                        func(childComplexity int) int
		GetMod                       func(childComplexity int, modID string) int
		GetModAssetList              func(childComplexity int, modReference string) int
		GetModByIDOrReference        func(childComplexity int, modIDOrReference string) int
		GetModByReference            func(childComplexity int, modReference string) int
		GetMods                      func(childComplexity int, filter map[string]interface{}) int
		GetMyMods                    func(childComplexity int, filter map[string]interface{}) int
		GetMyUnapprovedMods          func(childComplexity int, filter map[string]interface{}) int
		GetMyUnapprovedVersions      func(childComplexity int, filter map[string]interface{}) int
		GetMyVersions                func(childComplexity int, filter map[string]interface{}) int
		GetOAuthOptions              func(childComplexity int, callbackURL string) int
		GetSMLVersion                func(childComplexity int, smlVersionID string) int
		GetSMLVersions               func(childComplexity int, filter map[string]interface{}) int
		GetSatisfactoryVersion       func(childComplexity int, id string) int
		GetSatisfactoryVersions      func(childComplexity int) int
		GetTag                       func(childComplexity int, tagID string) int
		GetTags                      func(childComplexity int, filter *TagFilter) int
		GetUnapprovedMods            func(childComplexity int, filter map[string]interface{}) int
		GetUnapprovedVersions        func(childComplexity int, filter map[string]interface{}) int
		GetUser                      func(childComplexity int, userID string) int
		GetUsers                     func(childComplexity int, userIds []string) int
		GetVersion                   func(childComplexity int, versionID string) int
		GetVersions                  func(childComplexity int, filter map[string]interface{}) int
		ResolveModVersions           func(childComplexity int, filter []*ModVersionConstraint) int
	}

	SMLVersion struct {
		BootstrapVersion    func(childComplexity int) int
		Changelog           func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		Date                func(childComplexity int) int
		EngineVersion       func(childComplexity int) int
		ID                  func(childComplexity int) int
		Link                func(childComplexity int) int
		SatisfactoryVersion func(childComplexity int) int
		Stability           func(childComplexity int) int
		Targets             func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
		Version             func(childComplexity int) int
	}

	SMLVersionTarget struct {
		Link       func(childComplexity int) int
		TargetName func(childComplexity int) int
		VersionID  func(childComplexity int) int
	}

	SatisfactoryVersion struct {
		EngineVersion func(childComplexity int) int
		ID            func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	Tag struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	User struct {
		Avatar     func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		Email      func(childComplexity int) int
		FacebookID func(childComplexity int) int
		GithubID   func(childComplexity int) int
		GoogleID   func(childComplexity int) int
		Groups     func(childComplexity int) int
		Guides     func(childComplexity int) int
		ID         func(childComplexity int) int
		Mods       func(childComplexity int) int
		Roles      func(childComplexity int) int
		Username   func(childComplexity int) int
	}

	UserMod struct {
		Mod    func(childComplexity int) int
		ModID  func(childComplexity int) int
		Role   func(childComplexity int) int
		User   func(childComplexity int) int
		UserID func(childComplexity int) int
	}

	UserRoles struct {
		ApproveMods              func(childComplexity int) int
		ApproveVersions          func(childComplexity int) int
		DeleteContent            func(childComplexity int) int
		EditAnyModCompatibility  func(childComplexity int) int
		EditBootstrapVersions    func(childComplexity int) int
		EditContent              func(childComplexity int) int
		EditSatisfactoryVersions func(childComplexity int) int
		EditUsers                func(childComplexity int) int
	}

	UserSession struct {
		Token func(childComplexity int) int
	}

	Version struct {
		Approved     func(childComplexity int) int
		Changelog    func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Dependencies func(childComplexity int) int
		Downloads    func(childComplexity int) int
		Hash         func(childComplexity int) int
		ID           func(childComplexity int) int
		Link         func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Mod          func(childComplexity int) int
		ModID        func(childComplexity int) int
		Size         func(childComplexity int) int
		SmlVersion   func(childComplexity int) int
		Stability    func(childComplexity int) int
		Targets      func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	VersionDependency struct {
		Condition func(childComplexity int) int
		Mod       func(childComplexity int) int
		ModID     func(childComplexity int) int
		Optional  func(childComplexity int) int
		Version   func(childComplexity int) int
		VersionID func(childComplexity int) int
	}

	VersionTarget struct {
		Hash       func(childComplexity int) int
		Link       func(childComplexity int) int
		Size       func(childComplexity int) int
		TargetName func(childComplexity int) int
		VersionID  func(childComplexity int) int
	}
}

type GetGuidesResolver interface {
	Guides(ctx context.Context, obj *GetGuides) ([]*Guide, error)
	Count(ctx context.Context, obj *GetGuides) (int, error)
}
type GetModsResolver interface {
	Mods(ctx context.Context, obj *GetMods) ([]*Mod, error)
	Count(ctx context.Context, obj *GetMods) (int, error)
}
type GetMyModsResolver interface {
	Mods(ctx context.Context, obj *GetMyMods) ([]*Mod, error)
	Count(ctx context.Context, obj *GetMyMods) (int, error)
}
type GetMyVersionsResolver interface {
	Versions(ctx context.Context, obj *GetMyVersions) ([]*Version, error)
	Count(ctx context.Context, obj *GetMyVersions) (int, error)
}
type GetSMLVersionsResolver interface {
	SmlVersions(ctx context.Context, obj *GetSMLVersions) ([]*SMLVersion, error)
	Count(ctx context.Context, obj *GetSMLVersions) (int, error)
}
type GetVersionsResolver interface {
	Versions(ctx context.Context, obj *GetVersions) ([]*Version, error)
	Count(ctx context.Context, obj *GetVersions) (int, error)
}
type GuideResolver interface {
	User(ctx context.Context, obj *Guide) (*User, error)
}
type ModResolver interface {
	Authors(ctx context.Context, obj *Mod) ([]*UserMod, error)
	Version(ctx context.Context, obj *Mod, version string) (*Version, error)
	Versions(ctx context.Context, obj *Mod, filter map[string]interface{}) ([]*Version, error)
	LatestVersions(ctx context.Context, obj *Mod) (*LatestVersions, error)
}
type MutationResolver interface {
	DiscourseSso(ctx context.Context, sso string, sig string) (*string, error)
	CreateAnnouncement(ctx context.Context, announcement NewAnnouncement) (*Announcement, error)
	UpdateAnnouncement(ctx context.Context, announcementID string, announcement UpdateAnnouncement) (*Announcement, error)
	DeleteAnnouncement(ctx context.Context, announcementID string) (bool, error)
	UpdateModCompatibility(ctx context.Context, modID string, compatibility CompatibilityInfoInput) (bool, error)
	UpdateMultipleModCompatibilities(ctx context.Context, modIDs []string, compatibility CompatibilityInfoInput) (bool, error)
	CreateGuide(ctx context.Context, guide NewGuide) (*Guide, error)
	UpdateGuide(ctx context.Context, guideID string, guide UpdateGuide) (*Guide, error)
	DeleteGuide(ctx context.Context, guideID string) (bool, error)
	CreateMod(ctx context.Context, mod NewMod) (*Mod, error)
	UpdateMod(ctx context.Context, modID string, mod UpdateMod) (*Mod, error)
	DeleteMod(ctx context.Context, modID string) (bool, error)
	ApproveMod(ctx context.Context, modID string) (bool, error)
	DenyMod(ctx context.Context, modID string) (bool, error)
	CreateSatisfactoryVersion(ctx context.Context, input NewSatisfactoryVersion) (*SatisfactoryVersion, error)
	UpdateSatisfactoryVersion(ctx context.Context, id string, input UpdateSatisfactoryVersion) (*SatisfactoryVersion, error)
	DeleteSatisfactoryVersion(ctx context.Context, id string) (bool, error)
	CreateTag(ctx context.Context, tagName string, description string) (*Tag, error)
	CreateMultipleTags(ctx context.Context, tagNames []*NewTag) ([]*Tag, error)
	UpdateTag(ctx context.Context, tagID string, newName string, description string) (*Tag, error)
	DeleteTag(ctx context.Context, tagID string) (bool, error)
	UpdateUser(ctx context.Context, userID string, input UpdateUser) (*User, error)
	Logout(ctx context.Context) (bool, error)
	OAuthGithub(ctx context.Context, code string, state string) (*UserSession, error)
	OAuthGoogle(ctx context.Context, code string, state string) (*UserSession, error)
	OAuthFacebook(ctx context.Context, code string, state string) (*UserSession, error)
	CreateVersion(ctx context.Context, modID string) (string, error)
	UploadVersionPart(ctx context.Context, modID string, versionID string, part int, file graphql.Upload) (bool, error)
	FinalizeCreateVersion(ctx context.Context, modID string, versionID string, version NewVersion) (bool, error)
	UpdateVersion(ctx context.Context, versionID string, version UpdateVersion) (*Version, error)
	DeleteVersion(ctx context.Context, versionID string) (bool, error)
	ApproveVersion(ctx context.Context, versionID string) (bool, error)
	DenyVersion(ctx context.Context, versionID string) (bool, error)
}
type QueryResolver interface {
	GetOAuthOptions(ctx context.Context, callbackURL string) (*OAuthOptions, error)
	GetAnnouncement(ctx context.Context, announcementID string) (*Announcement, error)
	GetAnnouncements(ctx context.Context) ([]*Announcement, error)
	GetAnnouncementsByImportance(ctx context.Context, importance AnnouncementImportance) ([]*Announcement, error)
	GetGuide(ctx context.Context, guideID string) (*Guide, error)
	GetGuides(ctx context.Context, filter map[string]interface{}) (*GetGuides, error)
	GetMod(ctx context.Context, modID string) (*Mod, error)
	GetModByReference(ctx context.Context, modReference string) (*Mod, error)
	GetModByIDOrReference(ctx context.Context, modIDOrReference string) (*Mod, error)
	GetMods(ctx context.Context, filter map[string]interface{}) (*GetMods, error)
	GetUnapprovedMods(ctx context.Context, filter map[string]interface{}) (*GetMods, error)
	GetMyMods(ctx context.Context, filter map[string]interface{}) (*GetMyMods, error)
	GetMyUnapprovedMods(ctx context.Context, filter map[string]interface{}) (*GetMyMods, error)
	ResolveModVersions(ctx context.Context, filter []*ModVersionConstraint) ([]*ModVersion, error)
	GetModAssetList(ctx context.Context, modReference string) ([]string, error)
	GetSatisfactoryVersions(ctx context.Context) ([]*SatisfactoryVersion, error)
	GetSatisfactoryVersion(ctx context.Context, id string) (*SatisfactoryVersion, error)
	GetSMLVersion(ctx context.Context, smlVersionID string) (*SMLVersion, error)
	GetSMLVersions(ctx context.Context, filter map[string]interface{}) (*GetSMLVersions, error)
	GetTag(ctx context.Context, tagID string) (*Tag, error)
	GetTags(ctx context.Context, filter *TagFilter) ([]*Tag, error)
	GetMe(ctx context.Context) (*User, error)
	GetUser(ctx context.Context, userID string) (*User, error)
	GetUsers(ctx context.Context, userIds []string) ([]*User, error)
	GetVersion(ctx context.Context, versionID string) (*Version, error)
	GetVersions(ctx context.Context, filter map[string]interface{}) (*GetVersions, error)
	GetUnapprovedVersions(ctx context.Context, filter map[string]interface{}) (*GetVersions, error)
	CheckVersionUploadState(ctx context.Context, modID string, versionID string) (*CreateVersionResponse, error)
	GetMyVersions(ctx context.Context, filter map[string]interface{}) (*GetMyVersions, error)
	GetMyUnapprovedVersions(ctx context.Context, filter map[string]interface{}) (*GetMyVersions, error)
}
type SMLVersionResolver interface {
	SatisfactoryVersion(ctx context.Context, obj *SMLVersion) (int, error)

	Link(ctx context.Context, obj *SMLVersion) (string, error)

	BootstrapVersion(ctx context.Context, obj *SMLVersion) (*string, error)
	EngineVersion(ctx context.Context, obj *SMLVersion) (string, error)
}
type SMLVersionTargetResolver interface {
	Link(ctx context.Context, obj *SMLVersionTarget) (string, error)
}
type UserResolver interface {
	Roles(ctx context.Context, obj *User) (*UserRoles, error)
	Groups(ctx context.Context, obj *User) ([]*Group, error)
	Mods(ctx context.Context, obj *User) ([]*UserMod, error)
	Guides(ctx context.Context, obj *User) ([]*Guide, error)
}
type UserModResolver interface {
	User(ctx context.Context, obj *UserMod) (*User, error)
	Mod(ctx context.Context, obj *UserMod) (*Mod, error)
}
type VersionResolver interface {
	Link(ctx context.Context, obj *Version) (string, error)

	Size(ctx context.Context, obj *Version) (*int, error)
	Hash(ctx context.Context, obj *Version) (*string, error)
	Mod(ctx context.Context, obj *Version) (*Mod, error)
	Dependencies(ctx context.Context, obj *Version) ([]*VersionDependency, error)
}
type VersionTargetResolver interface {
	Link(ctx context.Context, obj *VersionTarget) (string, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Announcement.id":
		if e.complexity.Announcement.ID == nil {
			break
		}

		return e.complexity.Announcement.ID(childComplexity), true

	case "Announcement.importance":
		if e.complexity.Announcement.Importance == nil {
			break
		}

		return e.complexity.Announcement.Importance(childComplexity), true

	case "Announcement.message":
		if e.complexity.Announcement.Message == nil {
			break
		}

		return e.complexity.Announcement.Message(childComplexity), true

	case "Compatibility.note":
		if e.complexity.Compatibility.Note == nil {
			break
		}

		return e.complexity.Compatibility.Note(childComplexity), true

	case "Compatibility.state":
		if e.complexity.Compatibility.State == nil {
			break
		}

		return e.complexity.Compatibility.State(childComplexity), true

	case "CompatibilityInfo.EA":
		if e.complexity.CompatibilityInfo.Ea == nil {
			break
		}

		return e.complexity.CompatibilityInfo.Ea(childComplexity), true

	case "CompatibilityInfo.EXP":
		if e.complexity.CompatibilityInfo.Exp == nil {
			break
		}

		return e.complexity.CompatibilityInfo.Exp(childComplexity), true

	case "CreateVersionResponse.auto_approved":
		if e.complexity.CreateVersionResponse.AutoApproved == nil {
			break
		}

		return e.complexity.CreateVersionResponse.AutoApproved(childComplexity), true

	case "CreateVersionResponse.version":
		if e.complexity.CreateVersionResponse.Version == nil {
			break
		}

		return e.complexity.CreateVersionResponse.Version(childComplexity), true

	case "GetGuides.count":
		if e.complexity.GetGuides.Count == nil {
			break
		}

		return e.complexity.GetGuides.Count(childComplexity), true

	case "GetGuides.guides":
		if e.complexity.GetGuides.Guides == nil {
			break
		}

		return e.complexity.GetGuides.Guides(childComplexity), true

	case "GetMods.count":
		if e.complexity.GetMods.Count == nil {
			break
		}

		return e.complexity.GetMods.Count(childComplexity), true

	case "GetMods.mods":
		if e.complexity.GetMods.Mods == nil {
			break
		}

		return e.complexity.GetMods.Mods(childComplexity), true

	case "GetMyMods.count":
		if e.complexity.GetMyMods.Count == nil {
			break
		}

		return e.complexity.GetMyMods.Count(childComplexity), true

	case "GetMyMods.mods":
		if e.complexity.GetMyMods.Mods == nil {
			break
		}

		return e.complexity.GetMyMods.Mods(childComplexity), true

	case "GetMyVersions.count":
		if e.complexity.GetMyVersions.Count == nil {
			break
		}

		return e.complexity.GetMyVersions.Count(childComplexity), true

	case "GetMyVersions.versions":
		if e.complexity.GetMyVersions.Versions == nil {
			break
		}

		return e.complexity.GetMyVersions.Versions(childComplexity), true

	case "GetSMLVersions.count":
		if e.complexity.GetSMLVersions.Count == nil {
			break
		}

		return e.complexity.GetSMLVersions.Count(childComplexity), true

	case "GetSMLVersions.sml_versions":
		if e.complexity.GetSMLVersions.SmlVersions == nil {
			break
		}

		return e.complexity.GetSMLVersions.SmlVersions(childComplexity), true

	case "GetVersions.count":
		if e.complexity.GetVersions.Count == nil {
			break
		}

		return e.complexity.GetVersions.Count(childComplexity), true

	case "GetVersions.versions":
		if e.complexity.GetVersions.Versions == nil {
			break
		}

		return e.complexity.GetVersions.Versions(childComplexity), true

	case "Group.id":
		if e.complexity.Group.ID == nil {
			break
		}

		return e.complexity.Group.ID(childComplexity), true

	case "Group.name":
		if e.complexity.Group.Name == nil {
			break
		}

		return e.complexity.Group.Name(childComplexity), true

	case "Guide.created_at":
		if e.complexity.Guide.CreatedAt == nil {
			break
		}

		return e.complexity.Guide.CreatedAt(childComplexity), true

	case "Guide.guide":
		if e.complexity.Guide.Guide == nil {
			break
		}

		return e.complexity.Guide.Guide(childComplexity), true

	case "Guide.id":
		if e.complexity.Guide.ID == nil {
			break
		}

		return e.complexity.Guide.ID(childComplexity), true

	case "Guide.name":
		if e.complexity.Guide.Name == nil {
			break
		}

		return e.complexity.Guide.Name(childComplexity), true

	case "Guide.short_description":
		if e.complexity.Guide.ShortDescription == nil {
			break
		}

		return e.complexity.Guide.ShortDescription(childComplexity), true

	case "Guide.tags":
		if e.complexity.Guide.Tags == nil {
			break
		}

		return e.complexity.Guide.Tags(childComplexity), true

	case "Guide.updated_at":
		if e.complexity.Guide.UpdatedAt == nil {
			break
		}

		return e.complexity.Guide.UpdatedAt(childComplexity), true

	case "Guide.user":
		if e.complexity.Guide.User == nil {
			break
		}

		return e.complexity.Guide.User(childComplexity), true

	case "Guide.user_id":
		if e.complexity.Guide.UserID == nil {
			break
		}

		return e.complexity.Guide.UserID(childComplexity), true

	case "Guide.views":
		if e.complexity.Guide.Views == nil {
			break
		}

		return e.complexity.Guide.Views(childComplexity), true

	case "LatestVersions.alpha":
		if e.complexity.LatestVersions.Alpha == nil {
			break
		}

		return e.complexity.LatestVersions.Alpha(childComplexity), true

	case "LatestVersions.beta":
		if e.complexity.LatestVersions.Beta == nil {
			break
		}

		return e.complexity.LatestVersions.Beta(childComplexity), true

	case "LatestVersions.release":
		if e.complexity.LatestVersions.Release == nil {
			break
		}

		return e.complexity.LatestVersions.Release(childComplexity), true

	case "Mod.approved":
		if e.complexity.Mod.Approved == nil {
			break
		}

		return e.complexity.Mod.Approved(childComplexity), true

	case "Mod.authors":
		if e.complexity.Mod.Authors == nil {
			break
		}

		return e.complexity.Mod.Authors(childComplexity), true

	case "Mod.compatibility":
		if e.complexity.Mod.Compatibility == nil {
			break
		}

		return e.complexity.Mod.Compatibility(childComplexity), true

	case "Mod.created_at":
		if e.complexity.Mod.CreatedAt == nil {
			break
		}

		return e.complexity.Mod.CreatedAt(childComplexity), true

	case "Mod.creator_id":
		if e.complexity.Mod.CreatorID == nil {
			break
		}

		return e.complexity.Mod.CreatorID(childComplexity), true

	case "Mod.downloads":
		if e.complexity.Mod.Downloads == nil {
			break
		}

		return e.complexity.Mod.Downloads(childComplexity), true

	case "Mod.full_description":
		if e.complexity.Mod.FullDescription == nil {
			break
		}

		return e.complexity.Mod.FullDescription(childComplexity), true

	case "Mod.hidden":
		if e.complexity.Mod.Hidden == nil {
			break
		}

		return e.complexity.Mod.Hidden(childComplexity), true

	case "Mod.hotness":
		if e.complexity.Mod.Hotness == nil {
			break
		}

		return e.complexity.Mod.Hotness(childComplexity), true

	case "Mod.id":
		if e.complexity.Mod.ID == nil {
			break
		}

		return e.complexity.Mod.ID(childComplexity), true

	case "Mod.last_version_date":
		if e.complexity.Mod.LastVersionDate == nil {
			break
		}

		return e.complexity.Mod.LastVersionDate(childComplexity), true

	case "Mod.latestVersions":
		if e.complexity.Mod.LatestVersions == nil {
			break
		}

		return e.complexity.Mod.LatestVersions(childComplexity), true

	case "Mod.logo":
		if e.complexity.Mod.Logo == nil {
			break
		}

		return e.complexity.Mod.Logo(childComplexity), true

	case "Mod.mod_reference":
		if e.complexity.Mod.ModReference == nil {
			break
		}

		return e.complexity.Mod.ModReference(childComplexity), true

	case "Mod.name":
		if e.complexity.Mod.Name == nil {
			break
		}

		return e.complexity.Mod.Name(childComplexity), true

	case "Mod.popularity":
		if e.complexity.Mod.Popularity == nil {
			break
		}

		return e.complexity.Mod.Popularity(childComplexity), true

	case "Mod.short_description":
		if e.complexity.Mod.ShortDescription == nil {
			break
		}

		return e.complexity.Mod.ShortDescription(childComplexity), true

	case "Mod.source_url":
		if e.complexity.Mod.SourceURL == nil {
			break
		}

		return e.complexity.Mod.SourceURL(childComplexity), true

	case "Mod.tags":
		if e.complexity.Mod.Tags == nil {
			break
		}

		return e.complexity.Mod.Tags(childComplexity), true

	case "Mod.updated_at":
		if e.complexity.Mod.UpdatedAt == nil {
			break
		}

		return e.complexity.Mod.UpdatedAt(childComplexity), true

	case "Mod.version":
		if e.complexity.Mod.Version == nil {
			break
		}

		args, err := ec.field_Mod_version_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mod.Version(childComplexity, args["version"].(string)), true

	case "Mod.versions":
		if e.complexity.Mod.Versions == nil {
			break
		}

		args, err := ec.field_Mod_versions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mod.Versions(childComplexity, args["filter"].(map[string]interface{})), true

	case "Mod.views":
		if e.complexity.Mod.Views == nil {
			break
		}

		return e.complexity.Mod.Views(childComplexity), true

	case "ModVersion.id":
		if e.complexity.ModVersion.ID == nil {
			break
		}

		return e.complexity.ModVersion.ID(childComplexity), true

	case "ModVersion.mod_reference":
		if e.complexity.ModVersion.ModReference == nil {
			break
		}

		return e.complexity.ModVersion.ModReference(childComplexity), true

	case "ModVersion.versions":
		if e.complexity.ModVersion.Versions == nil {
			break
		}

		return e.complexity.ModVersion.Versions(childComplexity), true

	case "Mutation.approveMod":
		if e.complexity.Mutation.ApproveMod == nil {
			break
		}

		args, err := ec.field_Mutation_approveMod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApproveMod(childComplexity, args["modId"].(string)), true

	case "Mutation.approveVersion":
		if e.complexity.Mutation.ApproveVersion == nil {
			break
		}

		args, err := ec.field_Mutation_approveVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApproveVersion(childComplexity, args["versionId"].(string)), true

	case "Mutation.createAnnouncement":
		if e.complexity.Mutation.CreateAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_createAnnouncement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAnnouncement(childComplexity, args["announcement"].(NewAnnouncement)), true

	case "Mutation.createGuide":
		if e.complexity.Mutation.CreateGuide == nil {
			break
		}

		args, err := ec.field_Mutation_createGuide_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateGuide(childComplexity, args["guide"].(NewGuide)), true

	case "Mutation.createMod":
		if e.complexity.Mutation.CreateMod == nil {
			break
		}

		args, err := ec.field_Mutation_createMod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMod(childComplexity, args["mod"].(NewMod)), true

	case "Mutation.createMultipleTags":
		if e.complexity.Mutation.CreateMultipleTags == nil {
			break
		}

		args, err := ec.field_Mutation_createMultipleTags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMultipleTags(childComplexity, args["tagNames"].([]*NewTag)), true

	case "Mutation.createSatisfactoryVersion":
		if e.complexity.Mutation.CreateSatisfactoryVersion == nil {
			break
		}

		args, err := ec.field_Mutation_createSatisfactoryVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSatisfactoryVersion(childComplexity, args["input"].(NewSatisfactoryVersion)), true

	case "Mutation.createTag":
		if e.complexity.Mutation.CreateTag == nil {
			break
		}

		args, err := ec.field_Mutation_createTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTag(childComplexity, args["tagName"].(string), args["description"].(string)), true

	case "Mutation.createVersion":
		if e.complexity.Mutation.CreateVersion == nil {
			break
		}

		args, err := ec.field_Mutation_createVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateVersion(childComplexity, args["modId"].(string)), true

	case "Mutation.deleteAnnouncement":
		if e.complexity.Mutation.DeleteAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAnnouncement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAnnouncement(childComplexity, args["announcementId"].(string)), true

	case "Mutation.deleteGuide":
		if e.complexity.Mutation.DeleteGuide == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGuide_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGuide(childComplexity, args["guideId"].(string)), true

	case "Mutation.deleteMod":
		if e.complexity.Mutation.DeleteMod == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMod(childComplexity, args["modId"].(string)), true

	case "Mutation.deleteSatisfactoryVersion":
		if e.complexity.Mutation.DeleteSatisfactoryVersion == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSatisfactoryVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSatisfactoryVersion(childComplexity, args["id"].(string)), true

	case "Mutation.deleteTag":
		if e.complexity.Mutation.DeleteTag == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTag(childComplexity, args["tagID"].(string)), true

	case "Mutation.deleteVersion":
		if e.complexity.Mutation.DeleteVersion == nil {
			break
		}

		args, err := ec.field_Mutation_deleteVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteVersion(childComplexity, args["versionId"].(string)), true

	case "Mutation.denyMod":
		if e.complexity.Mutation.DenyMod == nil {
			break
		}

		args, err := ec.field_Mutation_denyMod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DenyMod(childComplexity, args["modId"].(string)), true

	case "Mutation.denyVersion":
		if e.complexity.Mutation.DenyVersion == nil {
			break
		}

		args, err := ec.field_Mutation_denyVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DenyVersion(childComplexity, args["versionId"].(string)), true

	case "Mutation.discourseSSO":
		if e.complexity.Mutation.DiscourseSso == nil {
			break
		}

		args, err := ec.field_Mutation_discourseSSO_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DiscourseSso(childComplexity, args["sso"].(string), args["sig"].(string)), true

	case "Mutation.finalizeCreateVersion":
		if e.complexity.Mutation.FinalizeCreateVersion == nil {
			break
		}

		args, err := ec.field_Mutation_finalizeCreateVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FinalizeCreateVersion(childComplexity, args["modId"].(string), args["versionId"].(string), args["version"].(NewVersion)), true

	case "Mutation.logout":
		if e.complexity.Mutation.Logout == nil {
			break
		}

		return e.complexity.Mutation.Logout(childComplexity), true

	case "Mutation.oAuthFacebook":
		if e.complexity.Mutation.OAuthFacebook == nil {
			break
		}

		args, err := ec.field_Mutation_oAuthFacebook_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OAuthFacebook(childComplexity, args["code"].(string), args["state"].(string)), true

	case "Mutation.oAuthGithub":
		if e.complexity.Mutation.OAuthGithub == nil {
			break
		}

		args, err := ec.field_Mutation_oAuthGithub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OAuthGithub(childComplexity, args["code"].(string), args["state"].(string)), true

	case "Mutation.oAuthGoogle":
		if e.complexity.Mutation.OAuthGoogle == nil {
			break
		}

		args, err := ec.field_Mutation_oAuthGoogle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OAuthGoogle(childComplexity, args["code"].(string), args["state"].(string)), true

	case "Mutation.updateAnnouncement":
		if e.complexity.Mutation.UpdateAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_updateAnnouncement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAnnouncement(childComplexity, args["announcementId"].(string), args["announcement"].(UpdateAnnouncement)), true

	case "Mutation.updateGuide":
		if e.complexity.Mutation.UpdateGuide == nil {
			break
		}

		args, err := ec.field_Mutation_updateGuide_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGuide(childComplexity, args["guideId"].(string), args["guide"].(UpdateGuide)), true

	case "Mutation.updateMod":
		if e.complexity.Mutation.UpdateMod == nil {
			break
		}

		args, err := ec.field_Mutation_updateMod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMod(childComplexity, args["modId"].(string), args["mod"].(UpdateMod)), true

	case "Mutation.updateModCompatibility":
		if e.complexity.Mutation.UpdateModCompatibility == nil {
			break
		}

		args, err := ec.field_Mutation_updateModCompatibility_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateModCompatibility(childComplexity, args["modId"].(string), args["compatibility"].(CompatibilityInfoInput)), true

	case "Mutation.updateMultipleModCompatibilities":
		if e.complexity.Mutation.UpdateMultipleModCompatibilities == nil {
			break
		}

		args, err := ec.field_Mutation_updateMultipleModCompatibilities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMultipleModCompatibilities(childComplexity, args["modIDs"].([]string), args["compatibility"].(CompatibilityInfoInput)), true

	case "Mutation.updateSatisfactoryVersion":
		if e.complexity.Mutation.UpdateSatisfactoryVersion == nil {
			break
		}

		args, err := ec.field_Mutation_updateSatisfactoryVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSatisfactoryVersion(childComplexity, args["id"].(string), args["input"].(UpdateSatisfactoryVersion)), true

	case "Mutation.updateTag":
		if e.complexity.Mutation.UpdateTag == nil {
			break
		}

		args, err := ec.field_Mutation_updateTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTag(childComplexity, args["tagID"].(string), args["NewName"].(string), args["description"].(string)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["userId"].(string), args["input"].(UpdateUser)), true

	case "Mutation.updateVersion":
		if e.complexity.Mutation.UpdateVersion == nil {
			break
		}

		args, err := ec.field_Mutation_updateVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVersion(childComplexity, args["versionId"].(string), args["version"].(UpdateVersion)), true

	case "Mutation.uploadVersionPart":
		if e.complexity.Mutation.UploadVersionPart == nil {
			break
		}

		args, err := ec.field_Mutation_uploadVersionPart_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadVersionPart(childComplexity, args["modId"].(string), args["versionId"].(string), args["part"].(int), args["file"].(graphql.Upload)), true

	case "OAuthOptions.facebook":
		if e.complexity.OAuthOptions.Facebook == nil {
			break
		}

		return e.complexity.OAuthOptions.Facebook(childComplexity), true

	case "OAuthOptions.github":
		if e.complexity.OAuthOptions.Github == nil {
			break
		}

		return e.complexity.OAuthOptions.Github(childComplexity), true

	case "OAuthOptions.google":
		if e.complexity.OAuthOptions.Google == nil {
			break
		}

		return e.complexity.OAuthOptions.Google(childComplexity), true

	case "Query.checkVersionUploadState":
		if e.complexity.Query.CheckVersionUploadState == nil {
			break
		}

		args, err := ec.field_Query_checkVersionUploadState_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CheckVersionUploadState(childComplexity, args["modId"].(string), args["versionId"].(string)), true

	case "Query.getAnnouncement":
		if e.complexity.Query.GetAnnouncement == nil {
			break
		}

		args, err := ec.field_Query_getAnnouncement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAnnouncement(childComplexity, args["announcementId"].(string)), true

	case "Query.getAnnouncements":
		if e.complexity.Query.GetAnnouncements == nil {
			break
		}

		return e.complexity.Query.GetAnnouncements(childComplexity), true

	case "Query.getAnnouncementsByImportance":
		if e.complexity.Query.GetAnnouncementsByImportance == nil {
			break
		}

		args, err := ec.field_Query_getAnnouncementsByImportance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAnnouncementsByImportance(childComplexity, args["importance"].(AnnouncementImportance)), true

	case "Query.getGuide":
		if e.complexity.Query.GetGuide == nil {
			break
		}

		args, err := ec.field_Query_getGuide_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetGuide(childComplexity, args["guideId"].(string)), true

	case "Query.getGuides":
		if e.complexity.Query.GetGuides == nil {
			break
		}

		args, err := ec.field_Query_getGuides_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetGuides(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getMe":
		if e.complexity.Query.GetMe == nil {
			break
		}

		return e.complexity.Query.GetMe(childComplexity), true

	case "Query.getMod":
		if e.complexity.Query.GetMod == nil {
			break
		}

		args, err := ec.field_Query_getMod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMod(childComplexity, args["modId"].(string)), true

	case "Query.getModAssetList":
		if e.complexity.Query.GetModAssetList == nil {
			break
		}

		args, err := ec.field_Query_getModAssetList_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetModAssetList(childComplexity, args["modReference"].(string)), true

	case "Query.getModByIdOrReference":
		if e.complexity.Query.GetModByIDOrReference == nil {
			break
		}

		args, err := ec.field_Query_getModByIdOrReference_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetModByIDOrReference(childComplexity, args["modIdOrReference"].(string)), true

	case "Query.getModByReference":
		if e.complexity.Query.GetModByReference == nil {
			break
		}

		args, err := ec.field_Query_getModByReference_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetModByReference(childComplexity, args["modReference"].(string)), true

	case "Query.getMods":
		if e.complexity.Query.GetMods == nil {
			break
		}

		args, err := ec.field_Query_getMods_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMods(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getMyMods":
		if e.complexity.Query.GetMyMods == nil {
			break
		}

		args, err := ec.field_Query_getMyMods_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMyMods(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getMyUnapprovedMods":
		if e.complexity.Query.GetMyUnapprovedMods == nil {
			break
		}

		args, err := ec.field_Query_getMyUnapprovedMods_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMyUnapprovedMods(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getMyUnapprovedVersions":
		if e.complexity.Query.GetMyUnapprovedVersions == nil {
			break
		}

		args, err := ec.field_Query_getMyUnapprovedVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMyUnapprovedVersions(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getMyVersions":
		if e.complexity.Query.GetMyVersions == nil {
			break
		}

		args, err := ec.field_Query_getMyVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMyVersions(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getOAuthOptions":
		if e.complexity.Query.GetOAuthOptions == nil {
			break
		}

		args, err := ec.field_Query_getOAuthOptions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetOAuthOptions(childComplexity, args["callback_url"].(string)), true

	case "Query.getSMLVersion":
		if e.complexity.Query.GetSMLVersion == nil {
			break
		}

		args, err := ec.field_Query_getSMLVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSMLVersion(childComplexity, args["smlVersionID"].(string)), true

	case "Query.getSMLVersions":
		if e.complexity.Query.GetSMLVersions == nil {
			break
		}

		args, err := ec.field_Query_getSMLVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSMLVersions(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getSatisfactoryVersion":
		if e.complexity.Query.GetSatisfactoryVersion == nil {
			break
		}

		args, err := ec.field_Query_getSatisfactoryVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSatisfactoryVersion(childComplexity, args["id"].(string)), true

	case "Query.getSatisfactoryVersions":
		if e.complexity.Query.GetSatisfactoryVersions == nil {
			break
		}

		return e.complexity.Query.GetSatisfactoryVersions(childComplexity), true

	case "Query.getTag":
		if e.complexity.Query.GetTag == nil {
			break
		}

		args, err := ec.field_Query_getTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTag(childComplexity, args["tagID"].(string)), true

	case "Query.getTags":
		if e.complexity.Query.GetTags == nil {
			break
		}

		args, err := ec.field_Query_getTags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTags(childComplexity, args["filter"].(*TagFilter)), true

	case "Query.getUnapprovedMods":
		if e.complexity.Query.GetUnapprovedMods == nil {
			break
		}

		args, err := ec.field_Query_getUnapprovedMods_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUnapprovedMods(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getUnapprovedVersions":
		if e.complexity.Query.GetUnapprovedVersions == nil {
			break
		}

		args, err := ec.field_Query_getUnapprovedVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUnapprovedVersions(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getUser":
		if e.complexity.Query.GetUser == nil {
			break
		}

		args, err := ec.field_Query_getUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUser(childComplexity, args["userId"].(string)), true

	case "Query.getUsers":
		if e.complexity.Query.GetUsers == nil {
			break
		}

		args, err := ec.field_Query_getUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUsers(childComplexity, args["userIds"].([]string)), true

	case "Query.getVersion":
		if e.complexity.Query.GetVersion == nil {
			break
		}

		args, err := ec.field_Query_getVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetVersion(childComplexity, args["versionId"].(string)), true

	case "Query.getVersions":
		if e.complexity.Query.GetVersions == nil {
			break
		}

		args, err := ec.field_Query_getVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetVersions(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.resolveModVersions":
		if e.complexity.Query.ResolveModVersions == nil {
			break
		}

		args, err := ec.field_Query_resolveModVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ResolveModVersions(childComplexity, args["filter"].([]*ModVersionConstraint)), true

	case "SMLVersion.bootstrap_version":
		if e.complexity.SMLVersion.BootstrapVersion == nil {
			break
		}

		return e.complexity.SMLVersion.BootstrapVersion(childComplexity), true

	case "SMLVersion.changelog":
		if e.complexity.SMLVersion.Changelog == nil {
			break
		}

		return e.complexity.SMLVersion.Changelog(childComplexity), true

	case "SMLVersion.created_at":
		if e.complexity.SMLVersion.CreatedAt == nil {
			break
		}

		return e.complexity.SMLVersion.CreatedAt(childComplexity), true

	case "SMLVersion.date":
		if e.complexity.SMLVersion.Date == nil {
			break
		}

		return e.complexity.SMLVersion.Date(childComplexity), true

	case "SMLVersion.engine_version":
		if e.complexity.SMLVersion.EngineVersion == nil {
			break
		}

		return e.complexity.SMLVersion.EngineVersion(childComplexity), true

	case "SMLVersion.id":
		if e.complexity.SMLVersion.ID == nil {
			break
		}

		return e.complexity.SMLVersion.ID(childComplexity), true

	case "SMLVersion.link":
		if e.complexity.SMLVersion.Link == nil {
			break
		}

		return e.complexity.SMLVersion.Link(childComplexity), true

	case "SMLVersion.satisfactory_version":
		if e.complexity.SMLVersion.SatisfactoryVersion == nil {
			break
		}

		return e.complexity.SMLVersion.SatisfactoryVersion(childComplexity), true

	case "SMLVersion.stability":
		if e.complexity.SMLVersion.Stability == nil {
			break
		}

		return e.complexity.SMLVersion.Stability(childComplexity), true

	case "SMLVersion.targets":
		if e.complexity.SMLVersion.Targets == nil {
			break
		}

		return e.complexity.SMLVersion.Targets(childComplexity), true

	case "SMLVersion.updated_at":
		if e.complexity.SMLVersion.UpdatedAt == nil {
			break
		}

		return e.complexity.SMLVersion.UpdatedAt(childComplexity), true

	case "SMLVersion.version":
		if e.complexity.SMLVersion.Version == nil {
			break
		}

		return e.complexity.SMLVersion.Version(childComplexity), true

	case "SMLVersionTarget.link":
		if e.complexity.SMLVersionTarget.Link == nil {
			break
		}

		return e.complexity.SMLVersionTarget.Link(childComplexity), true

	case "SMLVersionTarget.targetName":
		if e.complexity.SMLVersionTarget.TargetName == nil {
			break
		}

		return e.complexity.SMLVersionTarget.TargetName(childComplexity), true

	case "SMLVersionTarget.VersionID":
		if e.complexity.SMLVersionTarget.VersionID == nil {
			break
		}

		return e.complexity.SMLVersionTarget.VersionID(childComplexity), true

	case "SatisfactoryVersion.engine_version":
		if e.complexity.SatisfactoryVersion.EngineVersion == nil {
			break
		}

		return e.complexity.SatisfactoryVersion.EngineVersion(childComplexity), true

	case "SatisfactoryVersion.id":
		if e.complexity.SatisfactoryVersion.ID == nil {
			break
		}

		return e.complexity.SatisfactoryVersion.ID(childComplexity), true

	case "SatisfactoryVersion.version":
		if e.complexity.SatisfactoryVersion.Version == nil {
			break
		}

		return e.complexity.SatisfactoryVersion.Version(childComplexity), true

	case "Tag.description":
		if e.complexity.Tag.Description == nil {
			break
		}

		return e.complexity.Tag.Description(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "User.avatar":
		if e.complexity.User.Avatar == nil {
			break
		}

		return e.complexity.User.Avatar(childComplexity), true

	case "User.created_at":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.facebook_id":
		if e.complexity.User.FacebookID == nil {
			break
		}

		return e.complexity.User.FacebookID(childComplexity), true

	case "User.github_id":
		if e.complexity.User.GithubID == nil {
			break
		}

		return e.complexity.User.GithubID(childComplexity), true

	case "User.google_id":
		if e.complexity.User.GoogleID == nil {
			break
		}

		return e.complexity.User.GoogleID(childComplexity), true

	case "User.groups":
		if e.complexity.User.Groups == nil {
			break
		}

		return e.complexity.User.Groups(childComplexity), true

	case "User.guides":
		if e.complexity.User.Guides == nil {
			break
		}

		return e.complexity.User.Guides(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.mods":
		if e.complexity.User.Mods == nil {
			break
		}

		return e.complexity.User.Mods(childComplexity), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "UserMod.mod":
		if e.complexity.UserMod.Mod == nil {
			break
		}

		return e.complexity.UserMod.Mod(childComplexity), true

	case "UserMod.mod_id":
		if e.complexity.UserMod.ModID == nil {
			break
		}

		return e.complexity.UserMod.ModID(childComplexity), true

	case "UserMod.role":
		if e.complexity.UserMod.Role == nil {
			break
		}

		return e.complexity.UserMod.Role(childComplexity), true

	case "UserMod.user":
		if e.complexity.UserMod.User == nil {
			break
		}

		return e.complexity.UserMod.User(childComplexity), true

	case "UserMod.user_id":
		if e.complexity.UserMod.UserID == nil {
			break
		}

		return e.complexity.UserMod.UserID(childComplexity), true

	case "UserRoles.approveMods":
		if e.complexity.UserRoles.ApproveMods == nil {
			break
		}

		return e.complexity.UserRoles.ApproveMods(childComplexity), true

	case "UserRoles.approveVersions":
		if e.complexity.UserRoles.ApproveVersions == nil {
			break
		}

		return e.complexity.UserRoles.ApproveVersions(childComplexity), true

	case "UserRoles.deleteContent":
		if e.complexity.UserRoles.DeleteContent == nil {
			break
		}

		return e.complexity.UserRoles.DeleteContent(childComplexity), true

	case "UserRoles.editAnyModCompatibility":
		if e.complexity.UserRoles.EditAnyModCompatibility == nil {
			break
		}

		return e.complexity.UserRoles.EditAnyModCompatibility(childComplexity), true

	case "UserRoles.editBootstrapVersions":
		if e.complexity.UserRoles.EditBootstrapVersions == nil {
			break
		}

		return e.complexity.UserRoles.EditBootstrapVersions(childComplexity), true

	case "UserRoles.editContent":
		if e.complexity.UserRoles.EditContent == nil {
			break
		}

		return e.complexity.UserRoles.EditContent(childComplexity), true

	case "UserRoles.editSatisfactoryVersions":
		if e.complexity.UserRoles.EditSatisfactoryVersions == nil {
			break
		}

		return e.complexity.UserRoles.EditSatisfactoryVersions(childComplexity), true

	case "UserRoles.editUsers":
		if e.complexity.UserRoles.EditUsers == nil {
			break
		}

		return e.complexity.UserRoles.EditUsers(childComplexity), true

	case "UserSession.token":
		if e.complexity.UserSession.Token == nil {
			break
		}

		return e.complexity.UserSession.Token(childComplexity), true

	case "Version.approved":
		if e.complexity.Version.Approved == nil {
			break
		}

		return e.complexity.Version.Approved(childComplexity), true

	case "Version.changelog":
		if e.complexity.Version.Changelog == nil {
			break
		}

		return e.complexity.Version.Changelog(childComplexity), true

	case "Version.created_at":
		if e.complexity.Version.CreatedAt == nil {
			break
		}

		return e.complexity.Version.CreatedAt(childComplexity), true

	case "Version.dependencies":
		if e.complexity.Version.Dependencies == nil {
			break
		}

		return e.complexity.Version.Dependencies(childComplexity), true

	case "Version.downloads":
		if e.complexity.Version.Downloads == nil {
			break
		}

		return e.complexity.Version.Downloads(childComplexity), true

	case "Version.hash":
		if e.complexity.Version.Hash == nil {
			break
		}

		return e.complexity.Version.Hash(childComplexity), true

	case "Version.id":
		if e.complexity.Version.ID == nil {
			break
		}

		return e.complexity.Version.ID(childComplexity), true

	case "Version.link":
		if e.complexity.Version.Link == nil {
			break
		}

		return e.complexity.Version.Link(childComplexity), true

	case "Version.metadata":
		if e.complexity.Version.Metadata == nil {
			break
		}

		return e.complexity.Version.Metadata(childComplexity), true

	case "Version.mod":
		if e.complexity.Version.Mod == nil {
			break
		}

		return e.complexity.Version.Mod(childComplexity), true

	case "Version.mod_id":
		if e.complexity.Version.ModID == nil {
			break
		}

		return e.complexity.Version.ModID(childComplexity), true

	case "Version.size":
		if e.complexity.Version.Size == nil {
			break
		}

		return e.complexity.Version.Size(childComplexity), true

	case "Version.sml_version":
		if e.complexity.Version.SmlVersion == nil {
			break
		}

		return e.complexity.Version.SmlVersion(childComplexity), true

	case "Version.stability":
		if e.complexity.Version.Stability == nil {
			break
		}

		return e.complexity.Version.Stability(childComplexity), true

	case "Version.targets":
		if e.complexity.Version.Targets == nil {
			break
		}

		return e.complexity.Version.Targets(childComplexity), true

	case "Version.updated_at":
		if e.complexity.Version.UpdatedAt == nil {
			break
		}

		return e.complexity.Version.UpdatedAt(childComplexity), true

	case "Version.version":
		if e.complexity.Version.Version == nil {
			break
		}

		return e.complexity.Version.Version(childComplexity), true

	case "VersionDependency.condition":
		if e.complexity.VersionDependency.Condition == nil {
			break
		}

		return e.complexity.VersionDependency.Condition(childComplexity), true

	case "VersionDependency.mod":
		if e.complexity.VersionDependency.Mod == nil {
			break
		}

		return e.complexity.VersionDependency.Mod(childComplexity), true

	case "VersionDependency.mod_id":
		if e.complexity.VersionDependency.ModID == nil {
			break
		}

		return e.complexity.VersionDependency.ModID(childComplexity), true

	case "VersionDependency.optional":
		if e.complexity.VersionDependency.Optional == nil {
			break
		}

		return e.complexity.VersionDependency.Optional(childComplexity), true

	case "VersionDependency.version":
		if e.complexity.VersionDependency.Version == nil {
			break
		}

		return e.complexity.VersionDependency.Version(childComplexity), true

	case "VersionDependency.version_id":
		if e.complexity.VersionDependency.VersionID == nil {
			break
		}

		return e.complexity.VersionDependency.VersionID(childComplexity), true

	case "VersionTarget.hash":
		if e.complexity.VersionTarget.Hash == nil {
			break
		}

		return e.complexity.VersionTarget.Hash(childComplexity), true

	case "VersionTarget.link":
		if e.complexity.VersionTarget.Link == nil {
			break
		}

		return e.complexity.VersionTarget.Link(childComplexity), true

	case "VersionTarget.size":
		if e.complexity.VersionTarget.Size == nil {
			break
		}

		return e.complexity.VersionTarget.Size(childComplexity), true

	case "VersionTarget.targetName":
		if e.complexity.VersionTarget.TargetName == nil {
			break
		}

		return e.complexity.VersionTarget.TargetName(childComplexity), true

	case "VersionTarget.VersionID":
		if e.complexity.VersionTarget.VersionID == nil {
			break
		}

		return e.complexity.VersionTarget.VersionID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCompatibilityInfoInput,
		ec.unmarshalInputCompatibilityInput,
		ec.unmarshalInputGuideFilter,
		ec.unmarshalInputModFilter,
		ec.unmarshalInputModVersionConstraint,
		ec.unmarshalInputNewAnnouncement,
		ec.unmarshalInputNewGuide,
		ec.unmarshalInputNewMod,
		ec.unmarshalInputNewSatisfactoryVersion,
		ec.unmarshalInputNewTag,
		ec.unmarshalInputNewVersion,
		ec.unmarshalInputSMLVersionFilter,
		ec.unmarshalInputTagFilter,
		ec.unmarshalInputUpdateAnnouncement,
		ec.unmarshalInputUpdateGuide,
		ec.unmarshalInputUpdateMod,
		ec.unmarshalInputUpdateSatisfactoryVersion,
		ec.unmarshalInputUpdateUser,
		ec.unmarshalInputUpdateUserMod,
		ec.unmarshalInputUpdateVersion,
		ec.unmarshalInputVersionFilter,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/announcements.graphql", Input: `### Types

scalar AnnouncementID

enum AnnouncementImportance {
    Fix
    Info
    Warning
    Alert
}

type Announcement {
    id: AnnouncementID!
    message: String!
    importance: AnnouncementImportance!
}

### Inputs

input NewAnnouncement {
    message: String!
    importance: AnnouncementImportance!
}

input UpdateAnnouncement {
    message: String
    importance: AnnouncementImportance
}

### Queries

extend type Query {
    getAnnouncement(announcementId: AnnouncementID!): Announcement
    getAnnouncements: [Announcement!]!
    getAnnouncementsByImportance(importance: AnnouncementImportance!): [Announcement!]!
}

### Mutations

extend type Mutation {
    createAnnouncement(announcement: NewAnnouncement!): Announcement @canEditAnnouncements @isLoggedIn
    updateAnnouncement(announcementId: AnnouncementID!, announcement: UpdateAnnouncement!): Announcement! @canEditAnnouncements @isLoggedIn
    deleteAnnouncement(announcementId: AnnouncementID!): Boolean! @canEditAnnouncements @isLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/base.graphql", Input: `scalar Upload

scalar Date

enum Order {
    asc
    desc
}

type OAuthOptions {
    github: String!
    google: String!
    facebook: String!
}

type Query {
    getOAuthOptions(callback_url: String!): OAuthOptions!
}

type Mutation {
    discourseSSO(sso: String!, sig: String!): String @isLoggedIn
}
`, BuiltIn: false},
	{Name: "../schemas/compatibility.graphql", Input: `enum CompatibilityState {
    Works
    Damaged
    Broken
}

type Compatibility {
    state: CompatibilityState!
    note: String
}

input CompatibilityInput {
    state: CompatibilityState!
    note: String
}

type CompatibilityInfo {
    EA: Compatibility!
    EXP: Compatibility!
}

input CompatibilityInfoInput {
    EA: CompatibilityInput!
    EXP: CompatibilityInput!
}

extend type Mutation {
    updateModCompatibility(modId: ModID!, compatibility: CompatibilityInfoInput!): Boolean! @canEditModCompatibility(field: "modId") @isLoggedIn
    updateMultipleModCompatibilities(modIDs: [ModID!]!, compatibility: CompatibilityInfoInput!): Boolean! @canEditModCompatibility @isLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/directives.graphql", Input: `directive @isLoggedIn on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @isNotLoggedIn on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @canEditMod(field: String!) on FIELD_DEFINITION
directive @canEditVersion(field: String!) on FIELD_DEFINITION
directive @canEditUser(field: String!, object: Boolean!) on FIELD_DEFINITION
directive @canEditGuide(field: String!) on FIELD_DEFINITION
directive @canEditModCompatibility(field: String) on FIELD_DEFINITION

directive @canApproveMods on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @canApproveVersions on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @canEditUsers on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @canEditSatisfactoryVersions on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @canEditAnnouncements on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @canManageTags on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../schemas/guide.graphql", Input: `### Types

scalar GuideID

enum GuideFields {
    name
    created_at
    updated_at
    views
}

type Guide {
    id: GuideID!
    name: String!
    short_description: String!
    guide: String!
    views: Int!
    user_id: UserID!
    updated_at: Date!
    created_at: Date!
    tags: [Tag!]!

    user: User!
}

type GetGuides {
    guides: [Guide!]!
    count: Int!
}

### Inputs

input NewGuide {
    name: String!
    short_description: String!
    guide: String!
    tagIDs: [TagID!]
}

input UpdateGuide {
    name: String
    short_description: String
    guide: String
    tagIDs: [TagID!]
}

input GuideFilter {
    limit: Int
    offset: Int
    order_by: GuideFields
    order: Order
    search: String
    ids: [String!]
    tagIDs: [TagID!]
}

### Queries

extend type Query {
    getGuide(guideId: GuideID!): Guide
    getGuides(filter: GuideFilter): GetGuides!
}

### Mutations

extend type Mutation {
    createGuide(guide: NewGuide!): Guide @isLoggedIn
    updateGuide(guideId: GuideID!, guide: UpdateGuide!): Guide! @canEditGuide(field: "guideId") @isLoggedIn
    deleteGuide(guideId: GuideID!): Boolean! @canEditGuide(field: "guideId") @isLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/mod.graphql", Input: `### Types

scalar ModID
scalar ModReference

enum ModFields {
    created_at
    updated_at
    name
    views
    downloads
    hotness
    popularity
    last_version_date
    search
}

type Mod {
    id: ModID!
    name: String!
    short_description: String!
    full_description: String
    logo: String
    source_url: String
    creator_id: UserID!
    approved: Boolean!
    views: Int!
    downloads: Int!
    hotness: Int!
    popularity: Int!
    updated_at: Date!
    created_at: Date!
    last_version_date: Date
    mod_reference: ModReference!
    hidden: Boolean!
    tags: [Tag!]
    compatibility: CompatibilityInfo

    authors: [UserMod!]!
    version(version: String!): Version
    versions(filter: VersionFilter): [Version!]!
    latestVersions: LatestVersions!
}

type GetMods {
    mods: [Mod!]!
    count: Int!
}

type GetMyMods {
    mods: [Mod!]!
    count: Int!
}

type ModVersion {
    id: ModID!
    mod_reference: ModReference!
    versions: [Version!]!
}

### Inputs

input ModFilter {
    limit: Int
    offset: Int
    order_by: ModFields
    order: Order
    search: String
    ids: [String!]
    references: [String!]
    hidden: Boolean
    tagIDs: [TagID!]
}

input NewMod {
    name: String!
    short_description: String!
    full_description: String
    logo: Upload
    source_url: String
    mod_reference: ModReference!
    hidden: Boolean
    tagIDs: [TagID!]
}

input UpdateMod {
    name: String
    short_description: String
    full_description: String
    logo: Upload
    source_url: String
    mod_reference: ModReference
    authors: [UpdateUserMod!]
    hidden: Boolean
    tagIDs: [TagID!]
    compatibility: CompatibilityInfoInput
}

input UpdateUserMod {
    user_id: UserID!
    role: String!
}

input ModVersionConstraint {
    modIdOrReference: String!
    version: String!
}

### Queries

extend type Query {
    getMod(modId: ModID!): Mod
    getModByReference(modReference: ModReference!): Mod
    getModByIdOrReference(modIdOrReference: String!): Mod
    getMods(filter: ModFilter): GetMods!
    getUnapprovedMods(filter: ModFilter): GetMods! @canApproveMods @isLoggedIn

    getMyMods(filter: ModFilter): GetMyMods! @isLoggedIn
    getMyUnapprovedMods(filter: ModFilter): GetMyMods! @isLoggedIn

    resolveModVersions(filter: [ModVersionConstraint!]!): [ModVersion!]!

    getModAssetList(modReference: ModID!): [String!]!
}

### Mutations

extend type Mutation {
    createMod(mod: NewMod!): Mod @isLoggedIn
    updateMod(modId: ModID!, mod: UpdateMod!): Mod! @canEditMod(field: "modId") @isLoggedIn
    deleteMod(modId: ModID!): Boolean! @canEditMod(field: "modId") @isLoggedIn

    approveMod(modId: ModID!): Boolean! @canApproveMods @isLoggedIn
    denyMod(modId: ModID!): Boolean! @canApproveMods @isLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/satisfactory_version.graphql", Input: `### Types

scalar SatisfactoryVersionID

type SatisfactoryVersion {
    id: SatisfactoryVersionID!
    version: Int!
    engine_version: String!
}

### Inputs

input NewSatisfactoryVersion {
    version: Int!
    engine_version: String!
}

input UpdateSatisfactoryVersion {
    version: Int
    engine_version: String
}

### Queries

extend type Query {
    getSatisfactoryVersions: [SatisfactoryVersion!]!
    getSatisfactoryVersion(id: SatisfactoryVersionID!): SatisfactoryVersion
}

### Mutations

extend type Mutation {
    createSatisfactoryVersion(input: NewSatisfactoryVersion!): SatisfactoryVersion! @isLoggedIn @canEditSatisfactoryVersions
    updateSatisfactoryVersion(id: SatisfactoryVersionID!, input: UpdateSatisfactoryVersion!): SatisfactoryVersion! @isLoggedIn @canEditSatisfactoryVersions
    deleteSatisfactoryVersion(id: SatisfactoryVersionID!): Boolean! @isLoggedIn @canEditSatisfactoryVersions
}
`, BuiltIn: false},
	{Name: "../schemas/sml_version.graphql", Input: `### Types

scalar SMLVersionID

type SMLVersion {
    id: SMLVersionID!
    version: String!
    satisfactory_version: Int!
    stability: VersionStabilities!
    link: String!
    targets: [SMLVersionTarget]!
    changelog: String!
    date: Date!
    bootstrap_version: String
    engine_version: String!

    updated_at: Date!
    created_at: Date!
}

type SMLVersionTarget {
    VersionID: SMLVersionID!
    targetName: TargetName!
    link: String!
}

type GetSMLVersions {
    sml_versions: [SMLVersion!]!
    count: Int!
}

enum SMLVersionFields {
    name
    created_at
    updated_at
    satisfactory_version
    date
}

### Inputs

input SMLVersionFilter {
    limit: Int
    offset: Int
    order_by: SMLVersionFields
    order: Order
    search: String
    ids: [String!]
}

### Queries

extend type Query {
    getSMLVersion(smlVersionID: SMLVersionID!): SMLVersion @deprecated(reason: "SML is now a mod")
    getSMLVersions(filter: SMLVersionFilter): GetSMLVersions! @deprecated(reason: "SML is now a mod")
}

### Mutations

`, BuiltIn: false},
	{Name: "../schemas/tags.graphql", Input: `scalar TagID
scalar TagName

type Tag {
    id: TagID!
    name: TagName!
    description: String!
}

input NewTag {
    name: TagName!
    description: String!
}

input TagFilter {
    limit: Int
    offset: Int
    order: Order
    search: String
    ids: [TagID!]
}

extend type Query {
    getTag(tagID: TagID!): Tag
    getTags(filter: TagFilter): [Tag!]!
}

### Mutations

extend type Mutation {
    createTag(tagName: TagName!, description: String!): Tag @canManageTags @isLoggedIn
    createMultipleTags(tagNames: [NewTag!]!): [Tag!]! @canManageTags @isLoggedIn
    updateTag(tagID: TagID!, NewName: TagName!, description: String!): Tag! @canManageTags @isLoggedIn
    deleteTag(tagID: TagID!): Boolean! @canManageTags @isLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/user.graphql", Input: `### Types

scalar UserID

type UserRoles {
    approveMods: Boolean!
    approveVersions: Boolean!
    deleteContent: Boolean!
    editContent: Boolean!
    editUsers: Boolean!
    editSatisfactoryVersions: Boolean!
    editBootstrapVersions: Boolean!
    editAnyModCompatibility: Boolean!
}

type Group {
    id: String!
    name: String!
}

type User {
    id: UserID!
    email: String @canEditUser(field: "ID", object: true) @isLoggedIn
    username: String!
    avatar: String
    created_at: Date!

    github_id: String @canEditUser(field: "ID", object: true) @isLoggedIn
    google_id: String @canEditUser(field: "ID", object: true) @isLoggedIn
    facebook_id: String @canEditUser(field: "ID", object: true) @isLoggedIn

    roles: UserRoles! @canEditUser(field: "ID", object: true) @isLoggedIn
    groups: [Group!]! @canEditUser(field: "ID", object: true) @isLoggedIn

    mods: [UserMod!]!
    guides: [Guide!]!
}

type UserSession {
    token: String!
}

type UserMod {
    user_id: UserID!
    mod_id: ModID!
    role: String!

    user: User!
    mod: Mod!
}

### Inputs

input UpdateUser {
    avatar: Upload
    groups: [String!] @canEditUsers @isLoggedIn
    username: String
}

### Queries

extend type Query {
    getMe: User @isLoggedIn
    getUser(userId: UserID!): User
    getUsers(userIds: [UserID!]!): [User]!
}

### Mutations

extend type Mutation {
    updateUser(userId: UserID!, input: UpdateUser!): User! @canEditUser(field: "userId", object: false) @isLoggedIn
    logout: Boolean! @isLoggedIn

    oAuthGithub(code: String!, state: String!): UserSession @isNotLoggedIn
    oAuthGoogle(code: String!, state: String!): UserSession @isNotLoggedIn
    oAuthFacebook(code: String!, state: String!): UserSession @isNotLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/version.graphql", Input: `### Types

scalar VersionID

type LatestVersions {
    alpha: Version
    beta: Version
    release: Version
}

enum VersionFields {
    created_at
    updated_at
    downloads
}

enum VersionStabilities {
    alpha
    beta
    release
}

type Version {
    id: VersionID!
    mod_id: ModID!
    version: String!
    sml_version: String!
    changelog: String!
    downloads: Int!
    stability: VersionStabilities!
    approved: Boolean!
    updated_at: Date!
    created_at: Date!
    link: String!
    targets: [VersionTarget]!
    metadata: String
    size: Int
    hash: String

    mod: Mod!
    dependencies: [VersionDependency!]!
}

type VersionTarget {
    VersionID: VersionID!
    targetName: TargetName!
    link: String!
    size: Int
    hash: String
}

type CreateVersionResponse {
    auto_approved: Boolean!
    version: Version
}

type GetVersions {
    versions: [Version!]!
    count: Int!
}

type GetMyVersions {
    versions: [Version!]!
    count: Int!
}

type VersionDependency {
    version_id: VersionID!
    mod_id: ModID!
    condition: String!
    optional: Boolean!

    mod: Mod
    version: Version
}

### Inputs

input VersionFilter {
    limit: Int
    offset: Int
    order_by: VersionFields
    order: Order
    search: String
    ids: [String!]
}

input NewVersion {
    changelog: String!
    stability: VersionStabilities!
}

input UpdateVersion {
    changelog: String
    stability: VersionStabilities
}

### Queries

extend type Query {
    getVersion(versionId: VersionID!): Version
    getVersions(filter: VersionFilter): GetVersions!
    getUnapprovedVersions(filter: VersionFilter): GetVersions! @canApproveVersions @isLoggedIn

    checkVersionUploadState(modId: ModID!, versionId: VersionID!): CreateVersionResponse @canEditMod(field: "modId") @isLoggedIn

    getMyVersions(filter: VersionFilter): GetMyVersions! @isLoggedIn
    getMyUnapprovedVersions(filter: VersionFilter): GetMyVersions! @isLoggedIn
}

### Mutations

extend type Mutation {
    createVersion(modId: ModID!): VersionID! @canEditMod(field: "modId") @isLoggedIn
    uploadVersionPart(modId: ModID!, versionId: VersionID!, part: Int!, file: Upload!): Boolean! @canEditMod(field: "modId") @isLoggedIn
    finalizeCreateVersion(modId: ModID!, versionId: VersionID!, version: NewVersion!): Boolean! @canEditMod(field: "modId") @isLoggedIn

    updateVersion(versionId: VersionID!, version: UpdateVersion!): Version! @canEditVersion(field: "versionId") @isLoggedIn
    deleteVersion(versionId: VersionID!): Boolean! @canEditVersion(field: "versionId") @isLoggedIn

    approveVersion(versionId: VersionID!): Boolean! @canApproveVersions @isLoggedIn
    denyVersion(versionId: VersionID!): Boolean! @canApproveVersions @isLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/version_target.graphql", Input: `enum TargetName {
    Windows,
    WindowsServer,
    LinuxServer
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_canEditGuide_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["field"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["field"] = arg0
	return args, nil
}

func (ec *executionContext) dir_canEditModCompatibility_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["field"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["field"] = arg0
	return args, nil
}

func (ec *executionContext) dir_canEditMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["field"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["field"] = arg0
	return args, nil
}

func (ec *executionContext) dir_canEditUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["field"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["field"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["object"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("object"))
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["object"] = arg1
	return args, nil
}

func (ec *executionContext) dir_canEditVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["field"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["field"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mod_version_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["version"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["version"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mod_versions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOVersionFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_approveMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_approveVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg0, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createAnnouncement_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 NewAnnouncement
	if tmp, ok := rawArgs["announcement"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("announcement"))
		arg0, err = ec.unmarshalNNewAnnouncement2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewAnnouncement(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["announcement"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createGuide_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 NewGuide
	if tmp, ok := rawArgs["guide"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guide"))
		arg0, err = ec.unmarshalNNewGuide2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewGuide(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guide"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 NewMod
	if tmp, ok := rawArgs["mod"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mod"))
		arg0, err = ec.unmarshalNNewMod2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewMod(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mod"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createMultipleTags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*NewTag
	if tmp, ok := rawArgs["tagNames"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNames"))
		arg0, err = ec.unmarshalNNewTag2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewTagᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tagNames"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSatisfactoryVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 NewSatisfactoryVersion
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNNewSatisfactoryVersion2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewSatisfactoryVersion(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tagName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagName"))
		arg0, err = ec.unmarshalNTagName2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tagName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["description"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["description"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteAnnouncement_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["announcementId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("announcementId"))
		arg0, err = ec.unmarshalNAnnouncementID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["announcementId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteGuide_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["guideId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guideId"))
		arg0, err = ec.unmarshalNGuideID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guideId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSatisfactoryVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNSatisfactoryVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tagID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
		arg0, err = ec.unmarshalNTagID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tagID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg0, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_denyMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_denyVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg0, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_discourseSSO_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["sso"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sso"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sso"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["sig"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sig"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sig"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_finalizeCreateVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg1, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg1
	var arg2 NewVersion
	if tmp, ok := rawArgs["version"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
		arg2, err = ec.unmarshalNNewVersion2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewVersion(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["version"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_oAuthFacebook_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["state"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["state"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_oAuthGithub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["state"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["state"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_oAuthGoogle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["state"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["state"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateAnnouncement_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["announcementId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("announcementId"))
		arg0, err = ec.unmarshalNAnnouncementID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["announcementId"] = arg0
	var arg1 UpdateAnnouncement
	if tmp, ok := rawArgs["announcement"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("announcement"))
		arg1, err = ec.unmarshalNUpdateAnnouncement2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateAnnouncement(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["announcement"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateGuide_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["guideId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guideId"))
		arg0, err = ec.unmarshalNGuideID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guideId"] = arg0
	var arg1 UpdateGuide
	if tmp, ok := rawArgs["guide"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guide"))
		arg1, err = ec.unmarshalNUpdateGuide2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateGuide(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guide"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateModCompatibility_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	var arg1 CompatibilityInfoInput
	if tmp, ok := rawArgs["compatibility"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compatibility"))
		arg1, err = ec.unmarshalNCompatibilityInfoInput2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityInfoInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["compatibility"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	var arg1 UpdateMod
	if tmp, ok := rawArgs["mod"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mod"))
		arg1, err = ec.unmarshalNUpdateMod2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateMod(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mod"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMultipleModCompatibilities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["modIDs"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modIDs"))
		arg0, err = ec.unmarshalNModID2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modIDs"] = arg0
	var arg1 CompatibilityInfoInput
	if tmp, ok := rawArgs["compatibility"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compatibility"))
		arg1, err = ec.unmarshalNCompatibilityInfoInput2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityInfoInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["compatibility"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSatisfactoryVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNSatisfactoryVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 UpdateSatisfactoryVersion
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateSatisfactoryVersion2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateSatisfactoryVersion(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tagID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
		arg0, err = ec.unmarshalNTagID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tagID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["NewName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("NewName"))
		arg1, err = ec.unmarshalNTagName2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["NewName"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["description"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["description"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNUserID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 UpdateUser
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateUser2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateUser(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg0, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg0
	var arg1 UpdateVersion
	if tmp, ok := rawArgs["version"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
		arg1, err = ec.unmarshalNUpdateVersion2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateVersion(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["version"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_uploadVersionPart_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg1, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["part"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("part"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["part"] = arg2
	var arg3 graphql.Upload
	if tmp, ok := rawArgs["file"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file"))
		arg3, err = ec.unmarshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["file"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_checkVersionUploadState_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg1, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getAnnouncement_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["announcementId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("announcementId"))
		arg0, err = ec.unmarshalNAnnouncementID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["announcementId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getAnnouncementsByImportance_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 AnnouncementImportance
	if tmp, ok := rawArgs["importance"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("importance"))
		arg0, err = ec.unmarshalNAnnouncementImportance2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncementImportance(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["importance"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getGuide_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["guideId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guideId"))
		arg0, err = ec.unmarshalNGuideID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guideId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getGuides_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOGuideFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getModAssetList_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modReference"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modReference"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modReference"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getModByIdOrReference_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modIdOrReference"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modIdOrReference"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modIdOrReference"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getModByReference_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modReference"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modReference"))
		arg0, err = ec.unmarshalNModReference2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modReference"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMods_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOModFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMyMods_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOModFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMyUnapprovedMods_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOModFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMyUnapprovedVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOVersionFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMyVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOVersionFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getOAuthOptions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["callback_url"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("callback_url"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["callback_url"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getSMLVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["smlVersionID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("smlVersionID"))
		arg0, err = ec.unmarshalNSMLVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["smlVersionID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getSMLVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOSMLVersionFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getSatisfactoryVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNSatisfactoryVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tagID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
		arg0, err = ec.unmarshalNTagID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tagID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getTags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *TagFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTagFilter2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTagFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUnapprovedMods_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOModFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUnapprovedVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOVersionFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNUserID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["userIds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIds"))
		arg0, err = ec.unmarshalNUserID2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg0, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOVersionFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_resolveModVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*ModVersionConstraint
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNModVersionConstraint2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModVersionConstraintᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Announcement_id(ctx context.Context, field graphql.CollectedField, obj *Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAnnouncementID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AnnouncementID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_message(ctx context.Context, field graphql.CollectedField, obj *Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_importance(ctx context.Context, field graphql.CollectedField, obj *Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_importance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Importance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AnnouncementImportance)
	fc.Result = res
	return ec.marshalNAnnouncementImportance2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncementImportance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_importance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AnnouncementImportance does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Compatibility_state(ctx context.Context, field graphql.CollectedField, obj *Compatibility) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Compatibility_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(CompatibilityState)
	fc.Result = res
	return ec.marshalNCompatibilityState2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Compatibility_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Compatibility",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CompatibilityState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Compatibility_note(ctx context.Context, field graphql.CollectedField, obj *Compatibility) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Compatibility_note(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Compatibility_note(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Compatibility",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompatibilityInfo_EA(ctx context.Context, field graphql.CollectedField, obj *CompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompatibilityInfo_EA(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ea, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Compatibility)
	fc.Result = res
	return ec.marshalNCompatibility2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibility(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompatibilityInfo_EA(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_Compatibility_state(ctx, field)
			case "note":
				return ec.fieldContext_Compatibility_note(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Compatibility", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompatibilityInfo_EXP(ctx context.Context, field graphql.CollectedField, obj *CompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompatibilityInfo_EXP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Compatibility)
	fc.Result = res
	return ec.marshalNCompatibility2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibility(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompatibilityInfo_EXP(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_Compatibility_state(ctx, field)
			case "note":
				return ec.fieldContext_Compatibility_note(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Compatibility", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateVersionResponse_auto_approved(ctx context.Context, field graphql.CollectedField, obj *CreateVersionResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateVersionResponse_auto_approved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AutoApproved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateVersionResponse_auto_approved(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateVersionResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateVersionResponse_version(ctx context.Context, field graphql.CollectedField, obj *CreateVersionResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateVersionResponse_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateVersionResponse_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateVersionResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetGuides_guides(ctx context.Context, field graphql.CollectedField, obj *GetGuides) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetGuides_guides(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetGuides().Guides(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Guide)
	fc.Result = res
	return ec.marshalNGuide2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuideᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetGuides_guides(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetGuides",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Guide_id(ctx, field)
			case "name":
				return ec.fieldContext_Guide_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Guide_short_description(ctx, field)
			case "guide":
				return ec.fieldContext_Guide_guide(ctx, field)
			case "views":
				return ec.fieldContext_Guide_views(ctx, field)
			case "user_id":
				return ec.fieldContext_Guide_user_id(ctx, field)
			case "updated_at":
				return ec.fieldContext_Guide_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Guide_created_at(ctx, field)
			case "tags":
				return ec.fieldContext_Guide_tags(ctx, field)
			case "user":
				return ec.fieldContext_Guide_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Guide", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetGuides_count(ctx context.Context, field graphql.CollectedField, obj *GetGuides) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetGuides_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetGuides().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetGuides_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetGuides",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMods_mods(ctx context.Context, field graphql.CollectedField, obj *GetMods) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMods_mods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetMods().Mods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Mod)
	fc.Result = res
	return ec.marshalNMod2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMods_mods(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMods",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMods_count(ctx context.Context, field graphql.CollectedField, obj *GetMods) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMods_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetMods().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMods_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMods",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMyMods_mods(ctx context.Context, field graphql.CollectedField, obj *GetMyMods) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMyMods_mods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetMyMods().Mods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Mod)
	fc.Result = res
	return ec.marshalNMod2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMyMods_mods(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMyMods",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMyMods_count(ctx context.Context, field graphql.CollectedField, obj *GetMyMods) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMyMods_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetMyMods().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMyMods_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMyMods",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMyVersions_versions(ctx context.Context, field graphql.CollectedField, obj *GetMyVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMyVersions_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetMyVersions().Versions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Version)
	fc.Result = res
	return ec.marshalNVersion2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMyVersions_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMyVersions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMyVersions_count(ctx context.Context, field graphql.CollectedField, obj *GetMyVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMyVersions_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetMyVersions().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMyVersions_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMyVersions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetSMLVersions_sml_versions(ctx context.Context, field graphql.CollectedField, obj *GetSMLVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetSMLVersions_sml_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetSMLVersions().SmlVersions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*SMLVersion)
	fc.Result = res
	return ec.marshalNSMLVersion2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetSMLVersions_sml_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetSMLVersions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SMLVersion_id(ctx, field)
			case "version":
				return ec.fieldContext_SMLVersion_version(ctx, field)
			case "satisfactory_version":
				return ec.fieldContext_SMLVersion_satisfactory_version(ctx, field)
			case "stability":
				return ec.fieldContext_SMLVersion_stability(ctx, field)
			case "link":
				return ec.fieldContext_SMLVersion_link(ctx, field)
			case "targets":
				return ec.fieldContext_SMLVersion_targets(ctx, field)
			case "changelog":
				return ec.fieldContext_SMLVersion_changelog(ctx, field)
			case "date":
				return ec.fieldContext_SMLVersion_date(ctx, field)
			case "bootstrap_version":
				return ec.fieldContext_SMLVersion_bootstrap_version(ctx, field)
			case "engine_version":
				return ec.fieldContext_SMLVersion_engine_version(ctx, field)
			case "updated_at":
				return ec.fieldContext_SMLVersion_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_SMLVersion_created_at(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMLVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetSMLVersions_count(ctx context.Context, field graphql.CollectedField, obj *GetSMLVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetSMLVersions_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetSMLVersions().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetSMLVersions_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetSMLVersions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetVersions_versions(ctx context.Context, field graphql.CollectedField, obj *GetVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetVersions_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetVersions().Versions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Version)
	fc.Result = res
	return ec.marshalNVersion2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetVersions_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetVersions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetVersions_count(ctx context.Context, field graphql.CollectedField, obj *GetVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetVersions_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetVersions().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetVersions_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetVersions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_id(ctx context.Context, field graphql.CollectedField, obj *Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_name(ctx context.Context, field graphql.CollectedField, obj *Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_id(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNGuideID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GuideID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_name(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_short_description(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_short_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_short_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_guide(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_guide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Guide, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_guide(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_views(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_views(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Views, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_views(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_user_id(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_user_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNUserID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_user_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_updated_at(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_updated_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_created_at(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_created_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_tags(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalNTag2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_user(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Guide().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatar":
				return ec.fieldContext_User_avatar(ctx, field)
			case "created_at":
				return ec.fieldContext_User_created_at(ctx, field)
			case "github_id":
				return ec.fieldContext_User_github_id(ctx, field)
			case "google_id":
				return ec.fieldContext_User_google_id(ctx, field)
			case "facebook_id":
				return ec.fieldContext_User_facebook_id(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "mods":
				return ec.fieldContext_User_mods(ctx, field)
			case "guides":
				return ec.fieldContext_User_guides(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LatestVersions_alpha(ctx context.Context, field graphql.CollectedField, obj *LatestVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LatestVersions_alpha(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alpha, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LatestVersions_alpha(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LatestVersions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LatestVersions_beta(ctx context.Context, field graphql.CollectedField, obj *LatestVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LatestVersions_beta(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Beta, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LatestVersions_beta(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LatestVersions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LatestVersions_release(ctx context.Context, field graphql.CollectedField, obj *LatestVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LatestVersions_release(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Release, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LatestVersions_release(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LatestVersions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_id(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_name(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_short_description(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_short_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_short_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_full_description(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_full_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FullDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_full_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_logo(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_logo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_logo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_source_url(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_source_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_source_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_creator_id(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_creator_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatorID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNUserID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_creator_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_approved(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_approved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Approved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_approved(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_views(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_views(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Views, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_views(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_downloads(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_downloads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Downloads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_downloads(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_hotness(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_hotness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_hotness(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_popularity(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_popularity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Popularity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_popularity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_updated_at(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_updated_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_created_at(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_created_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_last_version_date(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_last_version_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastVersionDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODate2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_last_version_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_mod_reference(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_mod_reference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModReference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModReference2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_mod_reference(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModReference does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_hidden(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_hidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hidden, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_hidden(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_tags(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalOTag2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_compatibility(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_compatibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Compatibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CompatibilityInfo)
	fc.Result = res
	return ec.marshalOCompatibilityInfo2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_compatibility(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "EA":
				return ec.fieldContext_CompatibilityInfo_EA(ctx, field)
			case "EXP":
				return ec.fieldContext_CompatibilityInfo_EXP(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompatibilityInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_authors(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_authors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mod().Authors(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*UserMod)
	fc.Result = res
	return ec.marshalNUserMod2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUserModᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_authors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user_id":
				return ec.fieldContext_UserMod_user_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_UserMod_mod_id(ctx, field)
			case "role":
				return ec.fieldContext_UserMod_role(ctx, field)
			case "user":
				return ec.fieldContext_UserMod_user(ctx, field)
			case "mod":
				return ec.fieldContext_UserMod_mod(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserMod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_version(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mod().Version(rctx, obj, fc.Args["version"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mod_version_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mod_versions(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mod().Versions(rctx, obj, fc.Args["filter"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Version)
	fc.Result = res
	return ec.marshalNVersion2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mod_versions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mod_latestVersions(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_latestVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mod().LatestVersions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*LatestVersions)
	fc.Result = res
	return ec.marshalNLatestVersions2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐLatestVersions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_latestVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alpha":
				return ec.fieldContext_LatestVersions_alpha(ctx, field)
			case "beta":
				return ec.fieldContext_LatestVersions_beta(ctx, field)
			case "release":
				return ec.fieldContext_LatestVersions_release(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LatestVersions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModVersion_id(ctx context.Context, field graphql.CollectedField, obj *ModVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModVersion_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModVersion_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModVersion_mod_reference(ctx context.Context, field graphql.CollectedField, obj *ModVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModVersion_mod_reference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModReference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModReference2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModVersion_mod_reference(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModReference does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModVersion_versions(ctx context.Context, field graphql.CollectedField, obj *ModVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModVersion_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Version)
	fc.Result = res
	return ec.marshalNVersion2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModVersion_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_discourseSSO(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_discourseSSO(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DiscourseSso(rctx, fc.Args["sso"].(string), fc.Args["sig"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_discourseSSO(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_discourseSSO_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateAnnouncement(rctx, fc.Args["announcement"].(NewAnnouncement))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditAnnouncements == nil {
				return nil, errors.New("directive canEditAnnouncements is not implemented")
			}
			return ec.directives.CanEditAnnouncements(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Announcement); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Announcement`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Announcement)
	fc.Result = res
	return ec.marshalOAnnouncement2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "message":
				return ec.fieldContext_Announcement_message(ctx, field)
			case "importance":
				return ec.fieldContext_Announcement_importance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateAnnouncement(rctx, fc.Args["announcementId"].(string), fc.Args["announcement"].(UpdateAnnouncement))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditAnnouncements == nil {
				return nil, errors.New("directive canEditAnnouncements is not implemented")
			}
			return ec.directives.CanEditAnnouncements(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Announcement); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Announcement`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "message":
				return ec.fieldContext_Announcement_message(ctx, field)
			case "importance":
				return ec.fieldContext_Announcement_importance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteAnnouncement(rctx, fc.Args["announcementId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditAnnouncements == nil {
				return nil, errors.New("directive canEditAnnouncements is not implemented")
			}
			return ec.directives.CanEditAnnouncements(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateModCompatibility(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateModCompatibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateModCompatibility(rctx, fc.Args["modId"].(string), fc.Args["compatibility"].(CompatibilityInfoInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalOString2ᚖstring(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditModCompatibility == nil {
				return nil, errors.New("directive canEditModCompatibility is not implemented")
			}
			return ec.directives.CanEditModCompatibility(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateModCompatibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateModCompatibility_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMultipleModCompatibilities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMultipleModCompatibilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMultipleModCompatibilities(rctx, fc.Args["modIDs"].([]string), fc.Args["compatibility"].(CompatibilityInfoInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditModCompatibility == nil {
				return nil, errors.New("directive canEditModCompatibility is not implemented")
			}
			return ec.directives.CanEditModCompatibility(ctx, nil, directive0, nil)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMultipleModCompatibilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMultipleModCompatibilities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createGuide(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createGuide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateGuide(rctx, fc.Args["guide"].(NewGuide))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Guide); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Guide`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Guide)
	fc.Result = res
	return ec.marshalOGuide2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createGuide(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Guide_id(ctx, field)
			case "name":
				return ec.fieldContext_Guide_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Guide_short_description(ctx, field)
			case "guide":
				return ec.fieldContext_Guide_guide(ctx, field)
			case "views":
				return ec.fieldContext_Guide_views(ctx, field)
			case "user_id":
				return ec.fieldContext_Guide_user_id(ctx, field)
			case "updated_at":
				return ec.fieldContext_Guide_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Guide_created_at(ctx, field)
			case "tags":
				return ec.fieldContext_Guide_tags(ctx, field)
			case "user":
				return ec.fieldContext_Guide_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Guide", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createGuide_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateGuide(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateGuide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateGuide(rctx, fc.Args["guideId"].(string), fc.Args["guide"].(UpdateGuide))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "guideId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditGuide == nil {
				return nil, errors.New("directive canEditGuide is not implemented")
			}
			return ec.directives.CanEditGuide(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Guide); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Guide`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Guide)
	fc.Result = res
	return ec.marshalNGuide2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateGuide(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Guide_id(ctx, field)
			case "name":
				return ec.fieldContext_Guide_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Guide_short_description(ctx, field)
			case "guide":
				return ec.fieldContext_Guide_guide(ctx, field)
			case "views":
				return ec.fieldContext_Guide_views(ctx, field)
			case "user_id":
				return ec.fieldContext_Guide_user_id(ctx, field)
			case "updated_at":
				return ec.fieldContext_Guide_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Guide_created_at(ctx, field)
			case "tags":
				return ec.fieldContext_Guide_tags(ctx, field)
			case "user":
				return ec.fieldContext_Guide_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Guide", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateGuide_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGuide(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGuide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteGuide(rctx, fc.Args["guideId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "guideId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditGuide == nil {
				return nil, errors.New("directive canEditGuide is not implemented")
			}
			return ec.directives.CanEditGuide(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGuide(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGuide_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateMod(rctx, fc.Args["mod"].(NewMod))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Mod); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Mod`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalOMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMod(rctx, fc.Args["modId"].(string), fc.Args["mod"].(UpdateMod))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditMod == nil {
				return nil, errors.New("directive canEditMod is not implemented")
			}
			return ec.directives.CanEditMod(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Mod); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Mod`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalNMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteMod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteMod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteMod(rctx, fc.Args["modId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditMod == nil {
				return nil, errors.New("directive canEditMod is not implemented")
			}
			return ec.directives.CanEditMod(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteMod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteMod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_approveMod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_approveMod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ApproveMod(rctx, fc.Args["modId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanApproveMods == nil {
				return nil, errors.New("directive canApproveMods is not implemented")
			}
			return ec.directives.CanApproveMods(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_approveMod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_approveMod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_denyMod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_denyMod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DenyMod(rctx, fc.Args["modId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanApproveMods == nil {
				return nil, errors.New("directive canApproveMods is not implemented")
			}
			return ec.directives.CanApproveMods(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_denyMod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_denyMod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSatisfactoryVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSatisfactoryVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateSatisfactoryVersion(rctx, fc.Args["input"].(NewSatisfactoryVersion))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditSatisfactoryVersions == nil {
				return nil, errors.New("directive canEditSatisfactoryVersions is not implemented")
			}
			return ec.directives.CanEditSatisfactoryVersions(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*SatisfactoryVersion); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.SatisfactoryVersion`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SatisfactoryVersion)
	fc.Result = res
	return ec.marshalNSatisfactoryVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSatisfactoryVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSatisfactoryVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SatisfactoryVersion_id(ctx, field)
			case "version":
				return ec.fieldContext_SatisfactoryVersion_version(ctx, field)
			case "engine_version":
				return ec.fieldContext_SatisfactoryVersion_engine_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SatisfactoryVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSatisfactoryVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSatisfactoryVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSatisfactoryVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSatisfactoryVersion(rctx, fc.Args["id"].(string), fc.Args["input"].(UpdateSatisfactoryVersion))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditSatisfactoryVersions == nil {
				return nil, errors.New("directive canEditSatisfactoryVersions is not implemented")
			}
			return ec.directives.CanEditSatisfactoryVersions(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*SatisfactoryVersion); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.SatisfactoryVersion`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SatisfactoryVersion)
	fc.Result = res
	return ec.marshalNSatisfactoryVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSatisfactoryVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSatisfactoryVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SatisfactoryVersion_id(ctx, field)
			case "version":
				return ec.fieldContext_SatisfactoryVersion_version(ctx, field)
			case "engine_version":
				return ec.fieldContext_SatisfactoryVersion_engine_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SatisfactoryVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSatisfactoryVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSatisfactoryVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSatisfactoryVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSatisfactoryVersion(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditSatisfactoryVersions == nil {
				return nil, errors.New("directive canEditSatisfactoryVersions is not implemented")
			}
			return ec.directives.CanEditSatisfactoryVersions(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSatisfactoryVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSatisfactoryVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTag(rctx, fc.Args["tagName"].(string), fc.Args["description"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanManageTags == nil {
				return nil, errors.New("directive canManageTags is not implemented")
			}
			return ec.directives.CanManageTags(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tag)
	fc.Result = res
	return ec.marshalOTag2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMultipleTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMultipleTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateMultipleTags(rctx, fc.Args["tagNames"].([]*NewTag))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanManageTags == nil {
				return nil, errors.New("directive canManageTags is not implemented")
			}
			return ec.directives.CanManageTags(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/satisfactorymodding/smr-api/generated.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalNTag2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMultipleTags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMultipleTags_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTag(rctx, fc.Args["tagID"].(string), fc.Args["NewName"].(string), fc.Args["description"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanManageTags == nil {
				return nil, errors.New("directive canManageTags is not implemented")
			}
			return ec.directives.CanManageTags(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Tag)
	fc.Result = res
	return ec.marshalNTag2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTag(rctx, fc.Args["tagID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanManageTags == nil {
				return nil, errors.New("directive canManageTags is not implemented")
			}
			return ec.directives.CanManageTags(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateUser(rctx, fc.Args["userId"].(string), fc.Args["input"].(UpdateUser))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "userId")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, false)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, nil, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatar":
				return ec.fieldContext_User_avatar(ctx, field)
			case "created_at":
				return ec.fieldContext_User_created_at(ctx, field)
			case "github_id":
				return ec.fieldContext_User_github_id(ctx, field)
			case "google_id":
				return ec.fieldContext_User_google_id(ctx, field)
			case "facebook_id":
				return ec.fieldContext_User_facebook_id(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "mods":
				return ec.fieldContext_User_mods(ctx, field)
			case "guides":
				return ec.fieldContext_User_guides(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_logout(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_logout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Logout(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_logout(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_oAuthGithub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_oAuthGithub(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().OAuthGithub(rctx, fc.Args["code"].(string), fc.Args["state"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsNotLoggedIn == nil {
				return nil, errors.New("directive isNotLoggedIn is not implemented")
			}
			return ec.directives.IsNotLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*UserSession); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.UserSession`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserSession)
	fc.Result = res
	return ec.marshalOUserSession2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUserSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_oAuthGithub(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_UserSession_token(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSession", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_oAuthGithub_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_oAuthGoogle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_oAuthGoogle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().OAuthGoogle(rctx, fc.Args["code"].(string), fc.Args["state"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsNotLoggedIn == nil {
				return nil, errors.New("directive isNotLoggedIn is not implemented")
			}
			return ec.directives.IsNotLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*UserSession); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.UserSession`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserSession)
	fc.Result = res
	return ec.marshalOUserSession2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUserSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_oAuthGoogle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_UserSession_token(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSession", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_oAuthGoogle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_oAuthFacebook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_oAuthFacebook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().OAuthFacebook(rctx, fc.Args["code"].(string), fc.Args["state"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsNotLoggedIn == nil {
				return nil, errors.New("directive isNotLoggedIn is not implemented")
			}
			return ec.directives.IsNotLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*UserSession); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.UserSession`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserSession)
	fc.Result = res
	return ec.marshalOUserSession2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUserSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_oAuthFacebook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_UserSession_token(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSession", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_oAuthFacebook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateVersion(rctx, fc.Args["modId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditMod == nil {
				return nil, errors.New("directive canEditMod is not implemented")
			}
			return ec.directives.CanEditMod(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_uploadVersionPart(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_uploadVersionPart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UploadVersionPart(rctx, fc.Args["modId"].(string), fc.Args["versionId"].(string), fc.Args["part"].(int), fc.Args["file"].(graphql.Upload))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditMod == nil {
				return nil, errors.New("directive canEditMod is not implemented")
			}
			return ec.directives.CanEditMod(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_uploadVersionPart(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_uploadVersionPart_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_finalizeCreateVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_finalizeCreateVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FinalizeCreateVersion(rctx, fc.Args["modId"].(string), fc.Args["versionId"].(string), fc.Args["version"].(NewVersion))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditMod == nil {
				return nil, errors.New("directive canEditMod is not implemented")
			}
			return ec.directives.CanEditMod(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_finalizeCreateVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_finalizeCreateVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateVersion(rctx, fc.Args["versionId"].(string), fc.Args["version"].(UpdateVersion))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "versionId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditVersion == nil {
				return nil, errors.New("directive canEditVersion is not implemented")
			}
			return ec.directives.CanEditVersion(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Version); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Version`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalNVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteVersion(rctx, fc.Args["versionId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "versionId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditVersion == nil {
				return nil, errors.New("directive canEditVersion is not implemented")
			}
			return ec.directives.CanEditVersion(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_approveVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_approveVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ApproveVersion(rctx, fc.Args["versionId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanApproveVersions == nil {
				return nil, errors.New("directive canApproveVersions is not implemented")
			}
			return ec.directives.CanApproveVersions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_approveVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_approveVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_denyVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_denyVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DenyVersion(rctx, fc.Args["versionId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanApproveVersions == nil {
				return nil, errors.New("directive canApproveVersions is not implemented")
			}
			return ec.directives.CanApproveVersions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_denyVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_denyVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _OAuthOptions_github(ctx context.Context, field graphql.CollectedField, obj *OAuthOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuthOptions_github(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Github, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuthOptions_github(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuthOptions_google(ctx context.Context, field graphql.CollectedField, obj *OAuthOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuthOptions_google(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Google, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuthOptions_google(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuthOptions_facebook(ctx context.Context, field graphql.CollectedField, obj *OAuthOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuthOptions_facebook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Facebook, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuthOptions_facebook(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getOAuthOptions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getOAuthOptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetOAuthOptions(rctx, fc.Args["callback_url"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OAuthOptions)
	fc.Result = res
	return ec.marshalNOAuthOptions2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐOAuthOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getOAuthOptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "github":
				return ec.fieldContext_OAuthOptions_github(ctx, field)
			case "google":
				return ec.fieldContext_OAuthOptions_google(ctx, field)
			case "facebook":
				return ec.fieldContext_OAuthOptions_facebook(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuthOptions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getOAuthOptions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetAnnouncement(rctx, fc.Args["announcementId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Announcement)
	fc.Result = res
	return ec.marshalOAnnouncement2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "message":
				return ec.fieldContext_Announcement_message(ctx, field)
			case "importance":
				return ec.fieldContext_Announcement_importance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAnnouncements(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAnnouncements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetAnnouncements(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncementᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAnnouncements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "message":
				return ec.fieldContext_Announcement_message(ctx, field)
			case "importance":
				return ec.fieldContext_Announcement_importance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAnnouncementsByImportance(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAnnouncementsByImportance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetAnnouncementsByImportance(rctx, fc.Args["importance"].(AnnouncementImportance))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncementᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAnnouncementsByImportance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "message":
				return ec.fieldContext_Announcement_message(ctx, field)
			case "importance":
				return ec.fieldContext_Announcement_importance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAnnouncementsByImportance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getGuide(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getGuide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetGuide(rctx, fc.Args["guideId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Guide)
	fc.Result = res
	return ec.marshalOGuide2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getGuide(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Guide_id(ctx, field)
			case "name":
				return ec.fieldContext_Guide_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Guide_short_description(ctx, field)
			case "guide":
				return ec.fieldContext_Guide_guide(ctx, field)
			case "views":
				return ec.fieldContext_Guide_views(ctx, field)
			case "user_id":
				return ec.fieldContext_Guide_user_id(ctx, field)
			case "updated_at":
				return ec.fieldContext_Guide_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Guide_created_at(ctx, field)
			case "tags":
				return ec.fieldContext_Guide_tags(ctx, field)
			case "user":
				return ec.fieldContext_Guide_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Guide", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getGuide_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getGuides(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getGuides(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetGuides(rctx, fc.Args["filter"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetGuides)
	fc.Result = res
	return ec.marshalNGetGuides2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetGuides(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getGuides(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "guides":
				return ec.fieldContext_GetGuides_guides(ctx, field)
			case "count":
				return ec.fieldContext_GetGuides_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetGuides", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getGuides_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMod(rctx, fc.Args["modId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalOMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getModByReference(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getModByReference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetModByReference(rctx, fc.Args["modReference"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalOMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getModByReference(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getModByReference_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getModByIdOrReference(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getModByIdOrReference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetModByIDOrReference(rctx, fc.Args["modIdOrReference"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalOMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getModByIdOrReference(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getModByIdOrReference_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMods(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMods(rctx, fc.Args["filter"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetMods)
	fc.Result = res
	return ec.marshalNGetMods2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetMods(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mods":
				return ec.fieldContext_GetMods_mods(ctx, field)
			case "count":
				return ec.fieldContext_GetMods_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMods", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMods_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUnapprovedMods(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUnapprovedMods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetUnapprovedMods(rctx, fc.Args["filter"].(map[string]interface{}))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanApproveMods == nil {
				return nil, errors.New("directive canApproveMods is not implemented")
			}
			return ec.directives.CanApproveMods(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GetMods); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.GetMods`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetMods)
	fc.Result = res
	return ec.marshalNGetMods2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetMods(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUnapprovedMods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mods":
				return ec.fieldContext_GetMods_mods(ctx, field)
			case "count":
				return ec.fieldContext_GetMods_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMods", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getUnapprovedMods_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMyMods(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMyMods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMyMods(rctx, fc.Args["filter"].(map[string]interface{}))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GetMyMods); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.GetMyMods`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetMyMods)
	fc.Result = res
	return ec.marshalNGetMyMods2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetMyMods(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMyMods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mods":
				return ec.fieldContext_GetMyMods_mods(ctx, field)
			case "count":
				return ec.fieldContext_GetMyMods_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMyMods", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMyMods_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMyUnapprovedMods(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMyUnapprovedMods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMyUnapprovedMods(rctx, fc.Args["filter"].(map[string]interface{}))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GetMyMods); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.GetMyMods`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetMyMods)
	fc.Result = res
	return ec.marshalNGetMyMods2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetMyMods(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMyUnapprovedMods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mods":
				return ec.fieldContext_GetMyMods_mods(ctx, field)
			case "count":
				return ec.fieldContext_GetMyMods_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMyMods", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMyUnapprovedMods_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_resolveModVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_resolveModVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ResolveModVersions(rctx, fc.Args["filter"].([]*ModVersionConstraint))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ModVersion)
	fc.Result = res
	return ec.marshalNModVersion2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_resolveModVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ModVersion_id(ctx, field)
			case "mod_reference":
				return ec.fieldContext_ModVersion_mod_reference(ctx, field)
			case "versions":
				return ec.fieldContext_ModVersion_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_resolveModVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getModAssetList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getModAssetList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetModAssetList(rctx, fc.Args["modReference"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getModAssetList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getModAssetList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getSatisfactoryVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getSatisfactoryVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetSatisfactoryVersions(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*SatisfactoryVersion)
	fc.Result = res
	return ec.marshalNSatisfactoryVersion2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSatisfactoryVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getSatisfactoryVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SatisfactoryVersion_id(ctx, field)
			case "version":
				return ec.fieldContext_SatisfactoryVersion_version(ctx, field)
			case "engine_version":
				return ec.fieldContext_SatisfactoryVersion_engine_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SatisfactoryVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getSatisfactoryVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getSatisfactoryVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetSatisfactoryVersion(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SatisfactoryVersion)
	fc.Result = res
	return ec.marshalOSatisfactoryVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSatisfactoryVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getSatisfactoryVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SatisfactoryVersion_id(ctx, field)
			case "version":
				return ec.fieldContext_SatisfactoryVersion_version(ctx, field)
			case "engine_version":
				return ec.fieldContext_SatisfactoryVersion_engine_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SatisfactoryVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getSatisfactoryVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getSMLVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getSMLVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetSMLVersion(rctx, fc.Args["smlVersionID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SMLVersion)
	fc.Result = res
	return ec.marshalOSMLVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getSMLVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SMLVersion_id(ctx, field)
			case "version":
				return ec.fieldContext_SMLVersion_version(ctx, field)
			case "satisfactory_version":
				return ec.fieldContext_SMLVersion_satisfactory_version(ctx, field)
			case "stability":
				return ec.fieldContext_SMLVersion_stability(ctx, field)
			case "link":
				return ec.fieldContext_SMLVersion_link(ctx, field)
			case "targets":
				return ec.fieldContext_SMLVersion_targets(ctx, field)
			case "changelog":
				return ec.fieldContext_SMLVersion_changelog(ctx, field)
			case "date":
				return ec.fieldContext_SMLVersion_date(ctx, field)
			case "bootstrap_version":
				return ec.fieldContext_SMLVersion_bootstrap_version(ctx, field)
			case "engine_version":
				return ec.fieldContext_SMLVersion_engine_version(ctx, field)
			case "updated_at":
				return ec.fieldContext_SMLVersion_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_SMLVersion_created_at(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMLVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getSMLVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getSMLVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getSMLVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetSMLVersions(rctx, fc.Args["filter"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetSMLVersions)
	fc.Result = res
	return ec.marshalNGetSMLVersions2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetSMLVersions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getSMLVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sml_versions":
				return ec.fieldContext_GetSMLVersions_sml_versions(ctx, field)
			case "count":
				return ec.fieldContext_GetSMLVersions_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetSMLVersions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getSMLVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetTag(rctx, fc.Args["tagID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tag)
	fc.Result = res
	return ec.marshalOTag2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetTags(rctx, fc.Args["filter"].(*TagFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalNTag2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getTags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getTags_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMe(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMe(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMe(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMe(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatar":
				return ec.fieldContext_User_avatar(ctx, field)
			case "created_at":
				return ec.fieldContext_User_created_at(ctx, field)
			case "github_id":
				return ec.fieldContext_User_github_id(ctx, field)
			case "google_id":
				return ec.fieldContext_User_google_id(ctx, field)
			case "facebook_id":
				return ec.fieldContext_User_facebook_id(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "mods":
				return ec.fieldContext_User_mods(ctx, field)
			case "guides":
				return ec.fieldContext_User_guides(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetUser(rctx, fc.Args["userId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatar":
				return ec.fieldContext_User_avatar(ctx, field)
			case "created_at":
				return ec.fieldContext_User_created_at(ctx, field)
			case "github_id":
				return ec.fieldContext_User_github_id(ctx, field)
			case "google_id":
				return ec.fieldContext_User_google_id(ctx, field)
			case "facebook_id":
				return ec.fieldContext_User_facebook_id(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "mods":
				return ec.fieldContext_User_mods(ctx, field)
			case "guides":
				return ec.fieldContext_User_guides(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetUsers(rctx, fc.Args["userIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatar":
				return ec.fieldContext_User_avatar(ctx, field)
			case "created_at":
				return ec.fieldContext_User_created_at(ctx, field)
			case "github_id":
				return ec.fieldContext_User_github_id(ctx, field)
			case "google_id":
				return ec.fieldContext_User_google_id(ctx, field)
			case "facebook_id":
				return ec.fieldContext_User_facebook_id(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "mods":
				return ec.fieldContext_User_mods(ctx, field)
			case "guides":
				return ec.fieldContext_User_guides(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetVersion(rctx, fc.Args["versionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetVersions(rctx, fc.Args["filter"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetVersions)
	fc.Result = res
	return ec.marshalNGetVersions2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetVersions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "versions":
				return ec.fieldContext_GetVersions_versions(ctx, field)
			case "count":
				return ec.fieldContext_GetVersions_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetVersions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUnapprovedVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUnapprovedVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetUnapprovedVersions(rctx, fc.Args["filter"].(map[string]interface{}))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanApproveVersions == nil {
				return nil, errors.New("directive canApproveVersions is not implemented")
			}
			return ec.directives.CanApproveVersions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GetVersions); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.GetVersions`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetVersions)
	fc.Result = res
	return ec.marshalNGetVersions2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetVersions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUnapprovedVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "versions":
				return ec.fieldContext_GetVersions_versions(ctx, field)
			case "count":
				return ec.fieldContext_GetVersions_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetVersions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getUnapprovedVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_checkVersionUploadState(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_checkVersionUploadState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CheckVersionUploadState(rctx, fc.Args["modId"].(string), fc.Args["versionId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditMod == nil {
				return nil, errors.New("directive canEditMod is not implemented")
			}
			return ec.directives.CanEditMod(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*CreateVersionResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.CreateVersionResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CreateVersionResponse)
	fc.Result = res
	return ec.marshalOCreateVersionResponse2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCreateVersionResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_checkVersionUploadState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "auto_approved":
				return ec.fieldContext_CreateVersionResponse_auto_approved(ctx, field)
			case "version":
				return ec.fieldContext_CreateVersionResponse_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateVersionResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_checkVersionUploadState_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMyVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMyVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMyVersions(rctx, fc.Args["filter"].(map[string]interface{}))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GetMyVersions); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.GetMyVersions`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetMyVersions)
	fc.Result = res
	return ec.marshalNGetMyVersions2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetMyVersions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMyVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "versions":
				return ec.fieldContext_GetMyVersions_versions(ctx, field)
			case "count":
				return ec.fieldContext_GetMyVersions_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMyVersions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMyVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMyUnapprovedVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMyUnapprovedVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMyUnapprovedVersions(rctx, fc.Args["filter"].(map[string]interface{}))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GetMyVersions); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.GetMyVersions`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetMyVersions)
	fc.Result = res
	return ec.marshalNGetMyVersions2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetMyVersions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMyUnapprovedVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "versions":
				return ec.fieldContext_GetMyVersions_versions(ctx, field)
			case "count":
				return ec.fieldContext_GetMyVersions_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMyVersions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMyUnapprovedVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_id(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNSMLVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SMLVersionID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_version(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_satisfactory_version(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_satisfactory_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SMLVersion().SatisfactoryVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_satisfactory_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_stability(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_stability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(VersionStabilities)
	fc.Result = res
	return ec.marshalNVersionStabilities2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionStabilities(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_stability(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionStabilities does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_link(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_link(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SMLVersion().Link(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_link(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_targets(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_targets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Targets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*SMLVersionTarget)
	fc.Result = res
	return ec.marshalNSMLVersionTarget2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersionTarget(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_targets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "VersionID":
				return ec.fieldContext_SMLVersionTarget_VersionID(ctx, field)
			case "targetName":
				return ec.fieldContext_SMLVersionTarget_targetName(ctx, field)
			case "link":
				return ec.fieldContext_SMLVersionTarget_link(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMLVersionTarget", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_changelog(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_changelog(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Changelog, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_changelog(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_date(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_bootstrap_version(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_bootstrap_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SMLVersion().BootstrapVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_bootstrap_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_engine_version(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_engine_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SMLVersion().EngineVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_engine_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_updated_at(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_updated_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_created_at(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_created_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersionTarget_VersionID(ctx context.Context, field graphql.CollectedField, obj *SMLVersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersionTarget_VersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNSMLVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersionTarget_VersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SMLVersionID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersionTarget_targetName(ctx context.Context, field graphql.CollectedField, obj *SMLVersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersionTarget_targetName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TargetName)
	fc.Result = res
	return ec.marshalNTargetName2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTargetName(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersionTarget_targetName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TargetName does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersionTarget_link(ctx context.Context, field graphql.CollectedField, obj *SMLVersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersionTarget_link(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SMLVersionTarget().Link(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersionTarget_link(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersionTarget",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SatisfactoryVersion_id(ctx context.Context, field graphql.CollectedField, obj *SatisfactoryVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SatisfactoryVersion_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNSatisfactoryVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SatisfactoryVersion_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SatisfactoryVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SatisfactoryVersionID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SatisfactoryVersion_version(ctx context.Context, field graphql.CollectedField, obj *SatisfactoryVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SatisfactoryVersion_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SatisfactoryVersion_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SatisfactoryVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SatisfactoryVersion_engine_version(ctx context.Context, field graphql.CollectedField, obj *SatisfactoryVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SatisfactoryVersion_engine_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EngineVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SatisfactoryVersion_engine_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SatisfactoryVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_id(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNTagID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TagID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_name(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNTagName2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TagName does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_description(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNUserID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Email, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "ID")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, obj, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, obj, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_username(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_username(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_avatar(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_avatar(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avatar, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_avatar(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_created_at(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_created_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_github_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_github_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GithubID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "ID")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, obj, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, obj, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_github_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_google_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_google_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GoogleID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "ID")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, obj, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, obj, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_google_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_facebook_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_facebook_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.FacebookID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "ID")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, obj, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, obj, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_facebook_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_roles(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().Roles(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "ID")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, obj, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, obj, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*UserRoles); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.UserRoles`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*UserRoles)
	fc.Result = res
	return ec.marshalNUserRoles2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUserRoles(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_roles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "approveMods":
				return ec.fieldContext_UserRoles_approveMods(ctx, field)
			case "approveVersions":
				return ec.fieldContext_UserRoles_approveVersions(ctx, field)
			case "deleteContent":
				return ec.fieldContext_UserRoles_deleteContent(ctx, field)
			case "editContent":
				return ec.fieldContext_UserRoles_editContent(ctx, field)
			case "editUsers":
				return ec.fieldContext_UserRoles_editUsers(ctx, field)
			case "editSatisfactoryVersions":
				return ec.fieldContext_UserRoles_editSatisfactoryVersions(ctx, field)
			case "editBootstrapVersions":
				return ec.fieldContext_UserRoles_editBootstrapVersions(ctx, field)
			case "editAnyModCompatibility":
				return ec.fieldContext_UserRoles_editAnyModCompatibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRoles", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_groups(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().Groups(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "ID")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, obj, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, obj, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Group); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/satisfactorymodding/smr-api/generated.Group`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Group)
	fc.Result = res
	return ec.marshalNGroup2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_groups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_mods(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_mods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Mods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*UserMod)
	fc.Result = res
	return ec.marshalNUserMod2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUserModᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_mods(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user_id":
				return ec.fieldContext_UserMod_user_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_UserMod_mod_id(ctx, field)
			case "role":
				return ec.fieldContext_UserMod_role(ctx, field)
			case "user":
				return ec.fieldContext_UserMod_user(ctx, field)
			case "mod":
				return ec.fieldContext_UserMod_mod(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserMod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_guides(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_guides(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Guides(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Guide)
	fc.Result = res
	return ec.marshalNGuide2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuideᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_guides(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Guide_id(ctx, field)
			case "name":
				return ec.fieldContext_Guide_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Guide_short_description(ctx, field)
			case "guide":
				return ec.fieldContext_Guide_guide(ctx, field)
			case "views":
				return ec.fieldContext_Guide_views(ctx, field)
			case "user_id":
				return ec.fieldContext_Guide_user_id(ctx, field)
			case "updated_at":
				return ec.fieldContext_Guide_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Guide_created_at(ctx, field)
			case "tags":
				return ec.fieldContext_Guide_tags(ctx, field)
			case "user":
				return ec.fieldContext_Guide_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Guide", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserMod_user_id(ctx context.Context, field graphql.CollectedField, obj *UserMod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserMod_user_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNUserID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserMod_user_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserMod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserMod_mod_id(ctx context.Context, field graphql.CollectedField, obj *UserMod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserMod_mod_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserMod_mod_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserMod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserMod_role(ctx context.Context, field graphql.CollectedField, obj *UserMod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserMod_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserMod_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserMod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserMod_user(ctx context.Context, field graphql.CollectedField, obj *UserMod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserMod_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserMod().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserMod_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserMod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatar":
				return ec.fieldContext_User_avatar(ctx, field)
			case "created_at":
				return ec.fieldContext_User_created_at(ctx, field)
			case "github_id":
				return ec.fieldContext_User_github_id(ctx, field)
			case "google_id":
				return ec.fieldContext_User_google_id(ctx, field)
			case "facebook_id":
				return ec.fieldContext_User_facebook_id(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "mods":
				return ec.fieldContext_User_mods(ctx, field)
			case "guides":
				return ec.fieldContext_User_guides(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserMod_mod(ctx context.Context, field graphql.CollectedField, obj *UserMod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserMod_mod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserMod().Mod(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalNMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserMod_mod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserMod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_approveMods(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_approveMods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApproveMods, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_approveMods(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_approveVersions(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_approveVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApproveVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_approveVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_deleteContent(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_deleteContent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeleteContent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_deleteContent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_editContent(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_editContent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditContent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_editContent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_editUsers(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_editUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_editUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_editSatisfactoryVersions(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_editSatisfactoryVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditSatisfactoryVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_editSatisfactoryVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_editBootstrapVersions(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_editBootstrapVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditBootstrapVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_editBootstrapVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_editAnyModCompatibility(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_editAnyModCompatibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditAnyModCompatibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_editAnyModCompatibility(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSession_token(ctx context.Context, field graphql.CollectedField, obj *UserSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSession_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSession_token(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_id(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_mod_id(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_mod_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_mod_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_version(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_sml_version(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_sml_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SmlVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_sml_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_changelog(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_changelog(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Changelog, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_changelog(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_downloads(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_downloads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Downloads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_downloads(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_stability(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_stability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(VersionStabilities)
	fc.Result = res
	return ec.marshalNVersionStabilities2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionStabilities(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_stability(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionStabilities does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_approved(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_approved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Approved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_approved(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_updated_at(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_updated_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_created_at(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_created_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_link(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_link(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Link(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_link(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_targets(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_targets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Targets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*VersionTarget)
	fc.Result = res
	return ec.marshalNVersionTarget2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionTarget(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_targets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "VersionID":
				return ec.fieldContext_VersionTarget_VersionID(ctx, field)
			case "targetName":
				return ec.fieldContext_VersionTarget_targetName(ctx, field)
			case "link":
				return ec.fieldContext_VersionTarget_link(ctx, field)
			case "size":
				return ec.fieldContext_VersionTarget_size(ctx, field)
			case "hash":
				return ec.fieldContext_VersionTarget_hash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionTarget", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_metadata(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_metadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_size(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Size(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_hash(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Hash(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_mod(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_mod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Mod(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalNMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_mod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_dependencies(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_dependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Dependencies(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*VersionDependency)
	fc.Result = res
	return ec.marshalNVersionDependency2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionDependencyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_dependencies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version_id":
				return ec.fieldContext_VersionDependency_version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_VersionDependency_mod_id(ctx, field)
			case "condition":
				return ec.fieldContext_VersionDependency_condition(ctx, field)
			case "optional":
				return ec.fieldContext_VersionDependency_optional(ctx, field)
			case "mod":
				return ec.fieldContext_VersionDependency_mod(ctx, field)
			case "version":
				return ec.fieldContext_VersionDependency_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionDependency_version_id(ctx context.Context, field graphql.CollectedField, obj *VersionDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionDependency_version_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionDependency_version_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionDependency_mod_id(ctx context.Context, field graphql.CollectedField, obj *VersionDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionDependency_mod_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionDependency_mod_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionDependency_condition(ctx context.Context, field graphql.CollectedField, obj *VersionDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionDependency_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionDependency_condition(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionDependency_optional(ctx context.Context, field graphql.CollectedField, obj *VersionDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionDependency_optional(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Optional, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionDependency_optional(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionDependency_mod(ctx context.Context, field graphql.CollectedField, obj *VersionDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionDependency_mod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalOMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionDependency_mod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionDependency_version(ctx context.Context, field graphql.CollectedField, obj *VersionDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionDependency_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionDependency_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTarget_VersionID(ctx context.Context, field graphql.CollectedField, obj *VersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTarget_VersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTarget_VersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTarget_targetName(ctx context.Context, field graphql.CollectedField, obj *VersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTarget_targetName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TargetName)
	fc.Result = res
	return ec.marshalNTargetName2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTargetName(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTarget_targetName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TargetName does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTarget_link(ctx context.Context, field graphql.CollectedField, obj *VersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTarget_link(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionTarget().Link(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTarget_link(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTarget",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTarget_size(ctx context.Context, field graphql.CollectedField, obj *VersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTarget_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTarget_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTarget_hash(ctx context.Context, field graphql.CollectedField, obj *VersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTarget_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTarget_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCompatibilityInfoInput(ctx context.Context, obj interface{}) (CompatibilityInfoInput, error) {
	var it CompatibilityInfoInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"EA", "EXP"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "EA":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("EA"))
			data, err := ec.unmarshalNCompatibilityInput2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ea = data
		case "EXP":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("EXP"))
			data, err := ec.unmarshalNCompatibilityInput2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Exp = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCompatibilityInput(ctx context.Context, obj interface{}) (CompatibilityInput, error) {
	var it CompatibilityInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"state", "note"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "state":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			data, err := ec.unmarshalNCompatibilityState2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityState(ctx, v)
			if err != nil {
				return it, err
			}
			it.State = data
		case "note":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("note"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Note = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGuideFilter(ctx context.Context, obj interface{}) (map[string]interface{}, error) {
	it := make(map[string]interface{}, len(obj.(map[string]interface{})))
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"limit", "offset", "order_by", "order", "search", "ids", "tagIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it["limit"] = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it["offset"] = data
		case "order_by":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order_by"))
			data, err := ec.unmarshalOGuideFields2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuideFields(ctx, v)
			if err != nil {
				return it, err
			}
			it["order_by"] = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOOrder2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it["order"] = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it["search"] = data
		case "ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it["ids"] = data
		case "tagIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagIDs"))
			data, err := ec.unmarshalOTagID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it["tagIDs"] = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputModFilter(ctx context.Context, obj interface{}) (map[string]interface{}, error) {
	it := make(map[string]interface{}, len(obj.(map[string]interface{})))
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"limit", "offset", "order_by", "order", "search", "ids", "references", "hidden", "tagIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it["limit"] = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it["offset"] = data
		case "order_by":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order_by"))
			data, err := ec.unmarshalOModFields2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModFields(ctx, v)
			if err != nil {
				return it, err
			}
			it["order_by"] = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOOrder2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it["order"] = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it["search"] = data
		case "ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it["ids"] = data
		case "references":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("references"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it["references"] = data
		case "hidden":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it["hidden"] = data
		case "tagIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagIDs"))
			data, err := ec.unmarshalOTagID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it["tagIDs"] = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputModVersionConstraint(ctx context.Context, obj interface{}) (ModVersionConstraint, error) {
	var it ModVersionConstraint
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"modIdOrReference", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "modIdOrReference":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modIdOrReference"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModIDOrReference = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewAnnouncement(ctx context.Context, obj interface{}) (NewAnnouncement, error) {
	var it NewAnnouncement
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"message", "importance"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "importance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("importance"))
			data, err := ec.unmarshalNAnnouncementImportance2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncementImportance(ctx, v)
			if err != nil {
				return it, err
			}
			it.Importance = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewGuide(ctx context.Context, obj interface{}) (NewGuide, error) {
	var it NewGuide
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "short_description", "guide", "tagIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "short_description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("short_description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShortDescription = data
		case "guide":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guide"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Guide = data
		case "tagIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagIDs"))
			data, err := ec.unmarshalOTagID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewMod(ctx context.Context, obj interface{}) (NewMod, error) {
	var it NewMod
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "short_description", "full_description", "logo", "source_url", "mod_reference", "hidden", "tagIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "short_description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("short_description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShortDescription = data
		case "full_description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("full_description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullDescription = data
		case "logo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logo"))
			data, err := ec.unmarshalOUpload2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx, v)
			if err != nil {
				return it, err
			}
			it.Logo = data
		case "source_url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source_url"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURL = data
		case "mod_reference":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mod_reference"))
			data, err := ec.unmarshalNModReference2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModReference = data
		case "hidden":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hidden = data
		case "tagIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagIDs"))
			data, err := ec.unmarshalOTagID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewSatisfactoryVersion(ctx context.Context, obj interface{}) (NewSatisfactoryVersion, error) {
	var it NewSatisfactoryVersion
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version", "engine_version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "engine_version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("engine_version"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EngineVersion = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewTag(ctx context.Context, obj interface{}) (NewTag, error) {
	var it NewTag
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNTagName2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewVersion(ctx context.Context, obj interface{}) (NewVersion, error) {
	var it NewVersion
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"changelog", "stability"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "changelog":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changelog"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Changelog = data
		case "stability":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stability"))
			data, err := ec.unmarshalNVersionStabilities2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionStabilities(ctx, v)
			if err != nil {
				return it, err
			}
			it.Stability = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSMLVersionFilter(ctx context.Context, obj interface{}) (map[string]interface{}, error) {
	it := make(map[string]interface{}, len(obj.(map[string]interface{})))
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"limit", "offset", "order_by", "order", "search", "ids"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it["limit"] = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it["offset"] = data
		case "order_by":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order_by"))
			data, err := ec.unmarshalOSMLVersionFields2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersionFields(ctx, v)
			if err != nil {
				return it, err
			}
			it["order_by"] = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOOrder2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it["order"] = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it["search"] = data
		case "ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it["ids"] = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagFilter(ctx context.Context, obj interface{}) (TagFilter, error) {
	var it TagFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"limit", "offset", "order", "search", "ids"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOOrder2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			data, err := ec.unmarshalOTagID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ids = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateAnnouncement(ctx context.Context, obj interface{}) (UpdateAnnouncement, error) {
	var it UpdateAnnouncement
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"message", "importance"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "importance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("importance"))
			data, err := ec.unmarshalOAnnouncementImportance2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncementImportance(ctx, v)
			if err != nil {
				return it, err
			}
			it.Importance = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateGuide(ctx context.Context, obj interface{}) (UpdateGuide, error) {
	var it UpdateGuide
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "short_description", "guide", "tagIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "short_description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("short_description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShortDescription = data
		case "guide":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guide"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Guide = data
		case "tagIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagIDs"))
			data, err := ec.unmarshalOTagID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMod(ctx context.Context, obj interface{}) (UpdateMod, error) {
	var it UpdateMod
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "short_description", "full_description", "logo", "source_url", "mod_reference", "authors", "hidden", "tagIDs", "compatibility"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "short_description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("short_description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShortDescription = data
		case "full_description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("full_description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullDescription = data
		case "logo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logo"))
			data, err := ec.unmarshalOUpload2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx, v)
			if err != nil {
				return it, err
			}
			it.Logo = data
		case "source_url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source_url"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURL = data
		case "mod_reference":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mod_reference"))
			data, err := ec.unmarshalOModReference2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModReference = data
		case "authors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authors"))
			data, err := ec.unmarshalOUpdateUserMod2ᚕgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateUserModᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Authors = data
		case "hidden":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hidden = data
		case "tagIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagIDs"))
			data, err := ec.unmarshalOTagID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagIDs = data
		case "compatibility":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compatibility"))
			data, err := ec.unmarshalOCompatibilityInfoInput2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityInfoInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Compatibility = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSatisfactoryVersion(ctx context.Context, obj interface{}) (UpdateSatisfactoryVersion, error) {
	var it UpdateSatisfactoryVersion
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version", "engine_version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "engine_version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("engine_version"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EngineVersion = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUser(ctx context.Context, obj interface{}) (UpdateUser, error) {
	var it UpdateUser
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"avatar", "groups", "username"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "avatar":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatar"))
			data, err := ec.unmarshalOUpload2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx, v)
			if err != nil {
				return it, err
			}
			it.Avatar = data
		case "groups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groups"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚕstringᚄ(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.CanEditUsers == nil {
					return nil, errors.New("directive canEditUsers is not implemented")
				}
				return ec.directives.CanEditUsers(ctx, obj, directive0)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.IsLoggedIn == nil {
					return nil, errors.New("directive isLoggedIn is not implemented")
				}
				return ec.directives.IsLoggedIn(ctx, obj, directive1)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]string); ok {
				it.Groups = data
			} else if tmp == nil {
				it.Groups = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserMod(ctx context.Context, obj interface{}) (UpdateUserMod, error) {
	var it UpdateUserMod
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"user_id", "role"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "user_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user_id"))
			data, err := ec.unmarshalNUserID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateVersion(ctx context.Context, obj interface{}) (UpdateVersion, error) {
	var it UpdateVersion
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"changelog", "stability"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "changelog":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changelog"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Changelog = data
		case "stability":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stability"))
			data, err := ec.unmarshalOVersionStabilities2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionStabilities(ctx, v)
			if err != nil {
				return it, err
			}
			it.Stability = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVersionFilter(ctx context.Context, obj interface{}) (map[string]interface{}, error) {
	it := make(map[string]interface{}, len(obj.(map[string]interface{})))
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"limit", "offset", "order_by", "order", "search", "ids"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it["limit"] = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it["offset"] = data
		case "order_by":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order_by"))
			data, err := ec.unmarshalOVersionFields2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionFields(ctx, v)
			if err != nil {
				return it, err
			}
			it["order_by"] = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOOrder2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it["order"] = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it["search"] = data
		case "ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it["ids"] = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var announcementImplementors = []string{"Announcement"}

func (ec *executionContext) _Announcement(ctx context.Context, sel ast.SelectionSet, obj *Announcement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, announcementImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Announcement")
		case "id":
			out.Values[i] = ec._Announcement_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._Announcement_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "importance":
			out.Values[i] = ec._Announcement_importance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compatibilityImplementors = []string{"Compatibility"}

func (ec *executionContext) _Compatibility(ctx context.Context, sel ast.SelectionSet, obj *Compatibility) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compatibilityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Compatibility")
		case "state":
			out.Values[i] = ec._Compatibility_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "note":
			out.Values[i] = ec._Compatibility_note(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compatibilityInfoImplementors = []string{"CompatibilityInfo"}

func (ec *executionContext) _CompatibilityInfo(ctx context.Context, sel ast.SelectionSet, obj *CompatibilityInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compatibilityInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompatibilityInfo")
		case "EA":
			out.Values[i] = ec._CompatibilityInfo_EA(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "EXP":
			out.Values[i] = ec._CompatibilityInfo_EXP(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createVersionResponseImplementors = []string{"CreateVersionResponse"}

func (ec *executionContext) _CreateVersionResponse(ctx context.Context, sel ast.SelectionSet, obj *CreateVersionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createVersionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateVersionResponse")
		case "auto_approved":
			out.Values[i] = ec._CreateVersionResponse_auto_approved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._CreateVersionResponse_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getGuidesImplementors = []string{"GetGuides"}

func (ec *executionContext) _GetGuides(ctx context.Context, sel ast.SelectionSet, obj *GetGuides) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getGuidesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetGuides")
		case "guides":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetGuides_guides(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetGuides_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getModsImplementors = []string{"GetMods"}

func (ec *executionContext) _GetMods(ctx context.Context, sel ast.SelectionSet, obj *GetMods) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getModsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMods")
		case "mods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMods_mods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMods_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMyModsImplementors = []string{"GetMyMods"}

func (ec *executionContext) _GetMyMods(ctx context.Context, sel ast.SelectionSet, obj *GetMyMods) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMyModsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMyMods")
		case "mods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMyMods_mods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMyMods_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMyVersionsImplementors = []string{"GetMyVersions"}

func (ec *executionContext) _GetMyVersions(ctx context.Context, sel ast.SelectionSet, obj *GetMyVersions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMyVersionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMyVersions")
		case "versions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMyVersions_versions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMyVersions_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getSMLVersionsImplementors = []string{"GetSMLVersions"}

func (ec *executionContext) _GetSMLVersions(ctx context.Context, sel ast.SelectionSet, obj *GetSMLVersions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getSMLVersionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetSMLVersions")
		case "sml_versions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetSMLVersions_sml_versions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetSMLVersions_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getVersionsImplementors = []string{"GetVersions"}

func (ec *executionContext) _GetVersions(ctx context.Context, sel ast.SelectionSet, obj *GetVersions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getVersionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetVersions")
		case "versions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetVersions_versions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetVersions_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupImplementors = []string{"Group"}

func (ec *executionContext) _Group(ctx context.Context, sel ast.SelectionSet, obj *Group) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Group")
		case "id":
			out.Values[i] = ec._Group_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Group_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var guideImplementors = []string{"Guide"}

func (ec *executionContext) _Guide(ctx context.Context, sel ast.SelectionSet, obj *Guide) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, guideImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Guide")
		case "id":
			out.Values[i] = ec._Guide_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Guide_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "short_description":
			out.Values[i] = ec._Guide_short_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "guide":
			out.Values[i] = ec._Guide_guide(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "views":
			out.Values[i] = ec._Guide_views(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user_id":
			out.Values[i] = ec._Guide_user_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updated_at":
			out.Values[i] = ec._Guide_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "created_at":
			out.Values[i] = ec._Guide_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			out.Values[i] = ec._Guide_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Guide_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var latestVersionsImplementors = []string{"LatestVersions"}

func (ec *executionContext) _LatestVersions(ctx context.Context, sel ast.SelectionSet, obj *LatestVersions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, latestVersionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LatestVersions")
		case "alpha":
			out.Values[i] = ec._LatestVersions_alpha(ctx, field, obj)
		case "beta":
			out.Values[i] = ec._LatestVersions_beta(ctx, field, obj)
		case "release":
			out.Values[i] = ec._LatestVersions_release(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modImplementors = []string{"Mod"}

func (ec *executionContext) _Mod(ctx context.Context, sel ast.SelectionSet, obj *Mod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mod")
		case "id":
			out.Values[i] = ec._Mod_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Mod_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "short_description":
			out.Values[i] = ec._Mod_short_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "full_description":
			out.Values[i] = ec._Mod_full_description(ctx, field, obj)
		case "logo":
			out.Values[i] = ec._Mod_logo(ctx, field, obj)
		case "source_url":
			out.Values[i] = ec._Mod_source_url(ctx, field, obj)
		case "creator_id":
			out.Values[i] = ec._Mod_creator_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "approved":
			out.Values[i] = ec._Mod_approved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "views":
			out.Values[i] = ec._Mod_views(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "downloads":
			out.Values[i] = ec._Mod_downloads(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hotness":
			out.Values[i] = ec._Mod_hotness(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "popularity":
			out.Values[i] = ec._Mod_popularity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updated_at":
			out.Values[i] = ec._Mod_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "created_at":
			out.Values[i] = ec._Mod_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "last_version_date":
			out.Values[i] = ec._Mod_last_version_date(ctx, field, obj)
		case "mod_reference":
			out.Values[i] = ec._Mod_mod_reference(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hidden":
			out.Values[i] = ec._Mod_hidden(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			out.Values[i] = ec._Mod_tags(ctx, field, obj)
		case "compatibility":
			out.Values[i] = ec._Mod_compatibility(ctx, field, obj)
		case "authors":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Mod_authors(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "version":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Mod_version(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "versions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Mod_versions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "latestVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Mod_latestVersions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modVersionImplementors = []string{"ModVersion"}

func (ec *executionContext) _ModVersion(ctx context.Context, sel ast.SelectionSet, obj *ModVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModVersion")
		case "id":
			out.Values[i] = ec._ModVersion_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mod_reference":
			out.Values[i] = ec._ModVersion_mod_reference(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versions":
			out.Values[i] = ec._ModVersion_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "discourseSSO":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_discourseSSO(ctx, field)
			})
		case "createAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createAnnouncement(ctx, field)
			})
		case "updateAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateModCompatibility":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateModCompatibility(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMultipleModCompatibilities":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMultipleModCompatibilities(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createGuide":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createGuide(ctx, field)
			})
		case "updateGuide":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateGuide(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteGuide":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGuide(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMod":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMod(ctx, field)
			})
		case "updateMod":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMod(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteMod":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteMod(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approveMod":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_approveMod(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "denyMod":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_denyMod(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createSatisfactoryVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSatisfactoryVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSatisfactoryVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSatisfactoryVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSatisfactoryVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSatisfactoryVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTag(ctx, field)
			})
		case "createMultipleTags":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMultipleTags(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "logout":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_logout(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oAuthGithub":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_oAuthGithub(ctx, field)
			})
		case "oAuthGoogle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_oAuthGoogle(ctx, field)
			})
		case "oAuthFacebook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_oAuthFacebook(ctx, field)
			})
		case "createVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uploadVersionPart":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_uploadVersionPart(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "finalizeCreateVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_finalizeCreateVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approveVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_approveVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "denyVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_denyVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuthOptionsImplementors = []string{"OAuthOptions"}

func (ec *executionContext) _OAuthOptions(ctx context.Context, sel ast.SelectionSet, obj *OAuthOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuthOptionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuthOptions")
		case "github":
			out.Values[i] = ec._OAuthOptions_github(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "google":
			out.Values[i] = ec._OAuthOptions_google(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "facebook":
			out.Values[i] = ec._OAuthOptions_facebook(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getOAuthOptions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getOAuthOptions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getAnnouncement":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAnnouncement(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getAnnouncements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAnnouncements(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getAnnouncementsByImportance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAnnouncementsByImportance(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getGuide":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getGuide(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getGuides":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getGuides(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMod":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMod(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getModByReference":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getModByReference(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getModByIdOrReference":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getModByIdOrReference(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMods(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUnapprovedMods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUnapprovedMods(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMyMods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMyMods(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMyUnapprovedMods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMyUnapprovedMods(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "resolveModVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_resolveModVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getModAssetList":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getModAssetList(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getSatisfactoryVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getSatisfactoryVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getSatisfactoryVersion":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getSatisfactoryVersion(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getSMLVersion":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getSMLVersion(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getSMLVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getSMLVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getTag":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getTag(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getTags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMe":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMe(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUser":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUser(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getVersion":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getVersion(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUnapprovedVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUnapprovedVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "checkVersionUploadState":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_checkVersionUploadState(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMyVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMyVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMyUnapprovedVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMyUnapprovedVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sMLVersionImplementors = []string{"SMLVersion"}

func (ec *executionContext) _SMLVersion(ctx context.Context, sel ast.SelectionSet, obj *SMLVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sMLVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SMLVersion")
		case "id":
			out.Values[i] = ec._SMLVersion_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._SMLVersion_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "satisfactory_version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SMLVersion_satisfactory_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stability":
			out.Values[i] = ec._SMLVersion_stability(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "link":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SMLVersion_link(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "targets":
			out.Values[i] = ec._SMLVersion_targets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "changelog":
			out.Values[i] = ec._SMLVersion_changelog(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "date":
			out.Values[i] = ec._SMLVersion_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "bootstrap_version":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SMLVersion_bootstrap_version(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "engine_version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SMLVersion_engine_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updated_at":
			out.Values[i] = ec._SMLVersion_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "created_at":
			out.Values[i] = ec._SMLVersion_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sMLVersionTargetImplementors = []string{"SMLVersionTarget"}

func (ec *executionContext) _SMLVersionTarget(ctx context.Context, sel ast.SelectionSet, obj *SMLVersionTarget) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sMLVersionTargetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SMLVersionTarget")
		case "VersionID":
			out.Values[i] = ec._SMLVersionTarget_VersionID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetName":
			out.Values[i] = ec._SMLVersionTarget_targetName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "link":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SMLVersionTarget_link(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var satisfactoryVersionImplementors = []string{"SatisfactoryVersion"}

func (ec *executionContext) _SatisfactoryVersion(ctx context.Context, sel ast.SelectionSet, obj *SatisfactoryVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, satisfactoryVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SatisfactoryVersion")
		case "id":
			out.Values[i] = ec._SatisfactoryVersion_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._SatisfactoryVersion_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "engine_version":
			out.Values[i] = ec._SatisfactoryVersion_engine_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagImplementors = []string{"Tag"}

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "id":
			out.Values[i] = ec._Tag_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Tag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Tag_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
		case "username":
			out.Values[i] = ec._User_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "avatar":
			out.Values[i] = ec._User_avatar(ctx, field, obj)
		case "created_at":
			out.Values[i] = ec._User_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "github_id":
			out.Values[i] = ec._User_github_id(ctx, field, obj)
		case "google_id":
			out.Values[i] = ec._User_google_id(ctx, field, obj)
		case "facebook_id":
			out.Values[i] = ec._User_facebook_id(ctx, field, obj)
		case "roles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_roles(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_groups(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_mods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "guides":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_guides(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userModImplementors = []string{"UserMod"}

func (ec *executionContext) _UserMod(ctx context.Context, sel ast.SelectionSet, obj *UserMod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userModImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserMod")
		case "user_id":
			out.Values[i] = ec._UserMod_user_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mod_id":
			out.Values[i] = ec._UserMod_mod_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "role":
			out.Values[i] = ec._UserMod_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserMod_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mod":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserMod_mod(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userRolesImplementors = []string{"UserRoles"}

func (ec *executionContext) _UserRoles(ctx context.Context, sel ast.SelectionSet, obj *UserRoles) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userRolesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserRoles")
		case "approveMods":
			out.Values[i] = ec._UserRoles_approveMods(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approveVersions":
			out.Values[i] = ec._UserRoles_approveVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteContent":
			out.Values[i] = ec._UserRoles_deleteContent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editContent":
			out.Values[i] = ec._UserRoles_editContent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editUsers":
			out.Values[i] = ec._UserRoles_editUsers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editSatisfactoryVersions":
			out.Values[i] = ec._UserRoles_editSatisfactoryVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editBootstrapVersions":
			out.Values[i] = ec._UserRoles_editBootstrapVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editAnyModCompatibility":
			out.Values[i] = ec._UserRoles_editAnyModCompatibility(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSessionImplementors = []string{"UserSession"}

func (ec *executionContext) _UserSession(ctx context.Context, sel ast.SelectionSet, obj *UserSession) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSessionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSession")
		case "token":
			out.Values[i] = ec._UserSession_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionImplementors = []string{"Version"}

func (ec *executionContext) _Version(ctx context.Context, sel ast.SelectionSet, obj *Version) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Version")
		case "id":
			out.Values[i] = ec._Version_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mod_id":
			out.Values[i] = ec._Version_mod_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._Version_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sml_version":
			out.Values[i] = ec._Version_sml_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "changelog":
			out.Values[i] = ec._Version_changelog(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "downloads":
			out.Values[i] = ec._Version_downloads(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stability":
			out.Values[i] = ec._Version_stability(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "approved":
			out.Values[i] = ec._Version_approved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updated_at":
			out.Values[i] = ec._Version_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "created_at":
			out.Values[i] = ec._Version_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "link":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_link(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "targets":
			out.Values[i] = ec._Version_targets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._Version_metadata(ctx, field, obj)
		case "size":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_size(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hash":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_hash(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mod":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_mod(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dependencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_dependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionDependencyImplementors = []string{"VersionDependency"}

func (ec *executionContext) _VersionDependency(ctx context.Context, sel ast.SelectionSet, obj *VersionDependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionDependencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionDependency")
		case "version_id":
			out.Values[i] = ec._VersionDependency_version_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mod_id":
			out.Values[i] = ec._VersionDependency_mod_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "condition":
			out.Values[i] = ec._VersionDependency_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "optional":
			out.Values[i] = ec._VersionDependency_optional(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mod":
			out.Values[i] = ec._VersionDependency_mod(ctx, field, obj)
		case "version":
			out.Values[i] = ec._VersionDependency_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionTargetImplementors = []string{"VersionTarget"}

func (ec *executionContext) _VersionTarget(ctx context.Context, sel ast.SelectionSet, obj *VersionTarget) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionTargetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionTarget")
		case "VersionID":
			out.Values[i] = ec._VersionTarget_VersionID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetName":
			out.Values[i] = ec._VersionTarget_targetName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "link":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionTarget_link(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "size":
			out.Values[i] = ec._VersionTarget_size(ctx, field, obj)
		case "hash":
			out.Values[i] = ec._VersionTarget_hash(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAnnouncement2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncement(ctx context.Context, sel ast.SelectionSet, v Announcement) graphql.Marshaler {
	return ec._Announcement(ctx, sel, &v)
}

func (ec *executionContext) marshalNAnnouncement2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncementᚄ(ctx context.Context, sel ast.SelectionSet, v []*Announcement) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAnnouncement2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAnnouncement2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncement(ctx context.Context, sel ast.SelectionSet, v *Announcement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Announcement(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAnnouncementID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAnnouncementID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNAnnouncementImportance2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncementImportance(ctx context.Context, v interface{}) (AnnouncementImportance, error) {
	var res AnnouncementImportance
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAnnouncementImportance2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncementImportance(ctx context.Context, sel ast.SelectionSet, v AnnouncementImportance) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCompatibility2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibility(ctx context.Context, sel ast.SelectionSet, v *Compatibility) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Compatibility(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCompatibilityInfoInput2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityInfoInput(ctx context.Context, v interface{}) (CompatibilityInfoInput, error) {
	res, err := ec.unmarshalInputCompatibilityInfoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCompatibilityInput2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityInput(ctx context.Context, v interface{}) (*CompatibilityInput, error) {
	res, err := ec.unmarshalInputCompatibilityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCompatibilityState2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityState(ctx context.Context, v interface{}) (CompatibilityState, error) {
	var res CompatibilityState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCompatibilityState2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityState(ctx context.Context, sel ast.SelectionSet, v CompatibilityState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDate2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNGetGuides2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetGuides(ctx context.Context, sel ast.SelectionSet, v GetGuides) graphql.Marshaler {
	return ec._GetGuides(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetGuides2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetGuides(ctx context.Context, sel ast.SelectionSet, v *GetGuides) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetGuides(ctx, sel, v)
}

func (ec *executionContext) marshalNGetMods2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetMods(ctx context.Context, sel ast.SelectionSet, v GetMods) graphql.Marshaler {
	return ec._GetMods(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMods2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetMods(ctx context.Context, sel ast.SelectionSet, v *GetMods) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMods(ctx, sel, v)
}

func (ec *executionContext) marshalNGetMyMods2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetMyMods(ctx context.Context, sel ast.SelectionSet, v GetMyMods) graphql.Marshaler {
	return ec._GetMyMods(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMyMods2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetMyMods(ctx context.Context, sel ast.SelectionSet, v *GetMyMods) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMyMods(ctx, sel, v)
}

func (ec *executionContext) marshalNGetMyVersions2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetMyVersions(ctx context.Context, sel ast.SelectionSet, v GetMyVersions) graphql.Marshaler {
	return ec._GetMyVersions(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMyVersions2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetMyVersions(ctx context.Context, sel ast.SelectionSet, v *GetMyVersions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMyVersions(ctx, sel, v)
}

func (ec *executionContext) marshalNGetSMLVersions2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetSMLVersions(ctx context.Context, sel ast.SelectionSet, v GetSMLVersions) graphql.Marshaler {
	return ec._GetSMLVersions(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetSMLVersions2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetSMLVersions(ctx context.Context, sel ast.SelectionSet, v *GetSMLVersions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetSMLVersions(ctx, sel, v)
}

func (ec *executionContext) marshalNGetVersions2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetVersions(ctx context.Context, sel ast.SelectionSet, v GetVersions) graphql.Marshaler {
	return ec._GetVersions(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetVersions2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGetVersions(ctx context.Context, sel ast.SelectionSet, v *GetVersions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetVersions(ctx, sel, v)
}

func (ec *executionContext) marshalNGroup2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGroupᚄ(ctx context.Context, sel ast.SelectionSet, v []*Group) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroup2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGroup2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGroup(ctx context.Context, sel ast.SelectionSet, v *Group) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Group(ctx, sel, v)
}

func (ec *executionContext) marshalNGuide2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuide(ctx context.Context, sel ast.SelectionSet, v Guide) graphql.Marshaler {
	return ec._Guide(ctx, sel, &v)
}

func (ec *executionContext) marshalNGuide2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuideᚄ(ctx context.Context, sel ast.SelectionSet, v []*Guide) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGuide2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuide(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGuide2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuide(ctx context.Context, sel ast.SelectionSet, v *Guide) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Guide(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGuideID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGuideID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLatestVersions2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐLatestVersions(ctx context.Context, sel ast.SelectionSet, v LatestVersions) graphql.Marshaler {
	return ec._LatestVersions(ctx, sel, &v)
}

func (ec *executionContext) marshalNLatestVersions2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐLatestVersions(ctx context.Context, sel ast.SelectionSet, v *LatestVersions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LatestVersions(ctx, sel, v)
}

func (ec *executionContext) marshalNMod2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐMod(ctx context.Context, sel ast.SelectionSet, v Mod) graphql.Marshaler {
	return ec._Mod(ctx, sel, &v)
}

func (ec *executionContext) marshalNMod2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModᚄ(ctx context.Context, sel ast.SelectionSet, v []*Mod) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐMod(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐMod(ctx context.Context, sel ast.SelectionSet, v *Mod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Mod(ctx, sel, v)
}

func (ec *executionContext) unmarshalNModID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNModID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNModID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNModID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNModID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNModID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNModReference2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNModReference2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNModVersion2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*ModVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNModVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNModVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModVersion(ctx context.Context, sel ast.SelectionSet, v *ModVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ModVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNModVersionConstraint2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModVersionConstraintᚄ(ctx context.Context, v interface{}) ([]*ModVersionConstraint, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ModVersionConstraint, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNModVersionConstraint2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModVersionConstraint(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNModVersionConstraint2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModVersionConstraint(ctx context.Context, v interface{}) (*ModVersionConstraint, error) {
	res, err := ec.unmarshalInputModVersionConstraint(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewAnnouncement2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewAnnouncement(ctx context.Context, v interface{}) (NewAnnouncement, error) {
	res, err := ec.unmarshalInputNewAnnouncement(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewGuide2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewGuide(ctx context.Context, v interface{}) (NewGuide, error) {
	res, err := ec.unmarshalInputNewGuide(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewMod2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewMod(ctx context.Context, v interface{}) (NewMod, error) {
	res, err := ec.unmarshalInputNewMod(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewSatisfactoryVersion2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewSatisfactoryVersion(ctx context.Context, v interface{}) (NewSatisfactoryVersion, error) {
	res, err := ec.unmarshalInputNewSatisfactoryVersion(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewTag2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewTagᚄ(ctx context.Context, v interface{}) ([]*NewTag, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*NewTag, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNewTag2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewTag(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNNewTag2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewTag(ctx context.Context, v interface{}) (*NewTag, error) {
	res, err := ec.unmarshalInputNewTag(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewVersion2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐNewVersion(ctx context.Context, v interface{}) (NewVersion, error) {
	res, err := ec.unmarshalInputNewVersion(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOAuthOptions2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐOAuthOptions(ctx context.Context, sel ast.SelectionSet, v OAuthOptions) graphql.Marshaler {
	return ec._OAuthOptions(ctx, sel, &v)
}

func (ec *executionContext) marshalNOAuthOptions2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐOAuthOptions(ctx context.Context, sel ast.SelectionSet, v *OAuthOptions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OAuthOptions(ctx, sel, v)
}

func (ec *executionContext) marshalNSMLVersion2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*SMLVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSMLVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSMLVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersion(ctx context.Context, sel ast.SelectionSet, v *SMLVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SMLVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSMLVersionID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSMLVersionID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNSMLVersionTarget2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersionTarget(ctx context.Context, sel ast.SelectionSet, v []*SMLVersionTarget) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSMLVersionTarget2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersionTarget(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNSatisfactoryVersion2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSatisfactoryVersion(ctx context.Context, sel ast.SelectionSet, v SatisfactoryVersion) graphql.Marshaler {
	return ec._SatisfactoryVersion(ctx, sel, &v)
}

func (ec *executionContext) marshalNSatisfactoryVersion2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSatisfactoryVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*SatisfactoryVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSatisfactoryVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSatisfactoryVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSatisfactoryVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSatisfactoryVersion(ctx context.Context, sel ast.SelectionSet, v *SatisfactoryVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SatisfactoryVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSatisfactoryVersionID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSatisfactoryVersionID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTag2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTag(ctx context.Context, sel ast.SelectionSet, v Tag) graphql.Marshaler {
	return ec._Tag(ctx, sel, &v)
}

func (ec *executionContext) marshalNTag2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTagᚄ(ctx context.Context, sel ast.SelectionSet, v []*Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTag2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTag(ctx context.Context, sel ast.SelectionSet, v *Tag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTagID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTagName2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagName2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTargetName2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTargetName(ctx context.Context, v interface{}) (TargetName, error) {
	var res TargetName
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTargetName2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTargetName(ctx context.Context, sel ast.SelectionSet, v TargetName) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUpdateAnnouncement2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateAnnouncement(ctx context.Context, v interface{}) (UpdateAnnouncement, error) {
	res, err := ec.unmarshalInputUpdateAnnouncement(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateGuide2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateGuide(ctx context.Context, v interface{}) (UpdateGuide, error) {
	res, err := ec.unmarshalInputUpdateGuide(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMod2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateMod(ctx context.Context, v interface{}) (UpdateMod, error) {
	res, err := ec.unmarshalInputUpdateMod(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSatisfactoryVersion2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateSatisfactoryVersion(ctx context.Context, v interface{}) (UpdateSatisfactoryVersion, error) {
	res, err := ec.unmarshalInputUpdateSatisfactoryVersion(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUser2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateUser(ctx context.Context, v interface{}) (UpdateUser, error) {
	res, err := ec.unmarshalInputUpdateUser(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserMod2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateUserMod(ctx context.Context, v interface{}) (UpdateUserMod, error) {
	res, err := ec.unmarshalInputUpdateUserMod(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateVersion2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateVersion(ctx context.Context, v interface{}) (UpdateVersion, error) {
	res, err := ec.unmarshalInputUpdateVersion(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, v interface{}) (graphql.Upload, error) {
	res, err := graphql.UnmarshalUpload(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, sel ast.SelectionSet, v graphql.Upload) graphql.Marshaler {
	res := graphql.MarshalUpload(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUser(ctx context.Context, sel ast.SelectionSet, v User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUser(ctx context.Context, sel ast.SelectionSet, v []*User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUserID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNUserID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNUserID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserMod2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUserModᚄ(ctx context.Context, sel ast.SelectionSet, v []*UserMod) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUserMod(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUserMod(ctx context.Context, sel ast.SelectionSet, v *UserMod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserMod(ctx, sel, v)
}

func (ec *executionContext) marshalNUserRoles2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUserRoles(ctx context.Context, sel ast.SelectionSet, v UserRoles) graphql.Marshaler {
	return ec._UserRoles(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserRoles2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUserRoles(ctx context.Context, sel ast.SelectionSet, v *UserRoles) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserRoles(ctx, sel, v)
}

func (ec *executionContext) marshalNVersion2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersion(ctx context.Context, sel ast.SelectionSet, v Version) graphql.Marshaler {
	return ec._Version(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersion2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*Version) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersion(ctx context.Context, sel ast.SelectionSet, v *Version) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalNVersionDependency2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionDependencyᚄ(ctx context.Context, sel ast.SelectionSet, v []*VersionDependency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersionDependency2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVersionDependency2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionDependency(ctx context.Context, sel ast.SelectionSet, v *VersionDependency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VersionDependency(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVersionID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersionID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNVersionStabilities2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionStabilities(ctx context.Context, v interface{}) (VersionStabilities, error) {
	var res VersionStabilities
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersionStabilities2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionStabilities(ctx context.Context, sel ast.SelectionSet, v VersionStabilities) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNVersionTarget2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionTarget(ctx context.Context, sel ast.SelectionSet, v []*VersionTarget) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOVersionTarget2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionTarget(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAnnouncement2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncement(ctx context.Context, sel ast.SelectionSet, v *Announcement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Announcement(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAnnouncementImportance2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncementImportance(ctx context.Context, v interface{}) (*AnnouncementImportance, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(AnnouncementImportance)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAnnouncementImportance2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐAnnouncementImportance(ctx context.Context, sel ast.SelectionSet, v *AnnouncementImportance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCompatibilityInfo2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityInfo(ctx context.Context, sel ast.SelectionSet, v *CompatibilityInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompatibilityInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCompatibilityInfoInput2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCompatibilityInfoInput(ctx context.Context, v interface{}) (*CompatibilityInfoInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCompatibilityInfoInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCreateVersionResponse2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐCreateVersionResponse(ctx context.Context, sel ast.SelectionSet, v *CreateVersionResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CreateVersionResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalODate2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODate2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOGuide2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuide(ctx context.Context, sel ast.SelectionSet, v *Guide) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Guide(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGuideFields2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuideFields(ctx context.Context, v interface{}) (*GuideFields, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(GuideFields)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGuideFields2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐGuideFields(ctx context.Context, sel ast.SelectionSet, v *GuideFields) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOGuideFilter2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGuideFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOMod2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐMod(ctx context.Context, sel ast.SelectionSet, v *Mod) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Mod(ctx, sel, v)
}

func (ec *executionContext) unmarshalOModFields2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModFields(ctx context.Context, v interface{}) (*ModFields, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ModFields)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOModFields2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐModFields(ctx context.Context, sel ast.SelectionSet, v *ModFields) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOModFilter2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputModFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOModReference2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOModReference2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOOrder2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐOrder(ctx context.Context, v interface{}) (*Order, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(Order)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrder2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐOrder(ctx context.Context, sel ast.SelectionSet, v *Order) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOSMLVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersion(ctx context.Context, sel ast.SelectionSet, v *SMLVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SMLVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSMLVersionFields2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersionFields(ctx context.Context, v interface{}) (*SMLVersionFields, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(SMLVersionFields)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSMLVersionFields2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersionFields(ctx context.Context, sel ast.SelectionSet, v *SMLVersionFields) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSMLVersionFilter2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSMLVersionFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSMLVersionTarget2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSMLVersionTarget(ctx context.Context, sel ast.SelectionSet, v *SMLVersionTarget) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SMLVersionTarget(ctx, sel, v)
}

func (ec *executionContext) marshalOSatisfactoryVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐSatisfactoryVersion(ctx context.Context, sel ast.SelectionSet, v *SatisfactoryVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SatisfactoryVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTag2ᚕᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTagᚄ(ctx context.Context, sel ast.SelectionSet, v []*Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTag2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTag(ctx context.Context, sel ast.SelectionSet, v *Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTagFilter2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐTagFilter(ctx context.Context, v interface{}) (*TagFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTagFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTagID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTagID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTagID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTagID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUpdateUserMod2ᚕgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateUserModᚄ(ctx context.Context, v interface{}) ([]UpdateUserMod, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]UpdateUserMod, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUpdateUserMod2githubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUpdateUserMod(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUpload2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, v interface{}) (*graphql.Upload, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUpload(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpload2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, sel ast.SelectionSet, v *graphql.Upload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalUpload(*v)
	return res
}

func (ec *executionContext) marshalOUser2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalOUserSession2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐUserSession(ctx context.Context, sel ast.SelectionSet, v *UserSession) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserSession(ctx, sel, v)
}

func (ec *executionContext) marshalOVersion2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersion(ctx context.Context, sel ast.SelectionSet, v *Version) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) unmarshalOVersionFields2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionFields(ctx context.Context, v interface{}) (*VersionFields, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(VersionFields)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersionFields2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionFields(ctx context.Context, sel ast.SelectionSet, v *VersionFields) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOVersionFilter2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputVersionFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOVersionStabilities2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionStabilities(ctx context.Context, v interface{}) (*VersionStabilities, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(VersionStabilities)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersionStabilities2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionStabilities(ctx context.Context, sel ast.SelectionSet, v *VersionStabilities) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOVersionTarget2ᚖgithubᚗcomᚋsatisfactorymoddingᚋsmrᚑapiᚋgeneratedᚐVersionTarget(ctx context.Context, sel ast.SelectionSet, v *VersionTarget) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VersionTarget(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************

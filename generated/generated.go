// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	GetGuides() GetGuidesResolver
	GetMods() GetModsResolver
	GetMyMods() GetMyModsResolver
	GetMyVersions() GetMyVersionsResolver
	GetSMLVersions() GetSMLVersionsResolver
	GetVersions() GetVersionsResolver
	Guide() GuideResolver
	Mod() ModResolver
	Mutation() MutationResolver
	Query() QueryResolver
	User() UserResolver
	UserMod() UserModResolver
	Version() VersionResolver
	VersionTarget() VersionTargetResolver
}

type DirectiveRoot struct {
	CanApproveMods           func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	CanApproveVersions       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	CanEditAnnouncements     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	CanEditBootstrapVersions func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	CanEditGuide             func(ctx context.Context, obj interface{}, next graphql.Resolver, field string) (res interface{}, err error)
	CanEditMod               func(ctx context.Context, obj interface{}, next graphql.Resolver, field string) (res interface{}, err error)
	CanEditModCompatibility  func(ctx context.Context, obj interface{}, next graphql.Resolver, field *string) (res interface{}, err error)
	CanEditSMLVersions       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	CanEditUser              func(ctx context.Context, obj interface{}, next graphql.Resolver, field string, object bool) (res interface{}, err error)
	CanEditUsers             func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	CanEditVersion           func(ctx context.Context, obj interface{}, next graphql.Resolver, field string) (res interface{}, err error)
	CanManageTags            func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	IsLoggedIn               func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	IsNotLoggedIn            func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Announcement struct {
		ID         func(childComplexity int) int
		Importance func(childComplexity int) int
		Message    func(childComplexity int) int
	}

	Compatibility struct {
		Note  func(childComplexity int) int
		State func(childComplexity int) int
	}

	CompatibilityInfo struct {
		Ea  func(childComplexity int) int
		Exp func(childComplexity int) int
	}

	CreateVersionResponse struct {
		AutoApproved func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	GetGuides struct {
		Count  func(childComplexity int) int
		Guides func(childComplexity int) int
	}

	GetMods struct {
		Count func(childComplexity int) int
		Mods  func(childComplexity int) int
	}

	GetMyMods struct {
		Count func(childComplexity int) int
		Mods  func(childComplexity int) int
	}

	GetMyVersions struct {
		Count    func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	GetSMLVersions struct {
		Count       func(childComplexity int) int
		SmlVersions func(childComplexity int) int
	}

	GetVersions struct {
		Count    func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	Group struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Guide struct {
		CreatedAt        func(childComplexity int) int
		Guide            func(childComplexity int) int
		ID               func(childComplexity int) int
		Name             func(childComplexity int) int
		ShortDescription func(childComplexity int) int
		Tags             func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		User             func(childComplexity int) int
		UserID           func(childComplexity int) int
		Views            func(childComplexity int) int
	}

	LatestVersions struct {
		Alpha   func(childComplexity int) int
		Beta    func(childComplexity int) int
		Release func(childComplexity int) int
	}

	Mod struct {
		Approved         func(childComplexity int) int
		Authors          func(childComplexity int) int
		Compatibility    func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		CreatorID        func(childComplexity int) int
		Downloads        func(childComplexity int) int
		FullDescription  func(childComplexity int) int
		Hidden           func(childComplexity int) int
		Hotness          func(childComplexity int) int
		ID               func(childComplexity int) int
		LastVersionDate  func(childComplexity int) int
		LatestVersions   func(childComplexity int) int
		Logo             func(childComplexity int) int
		ModReference     func(childComplexity int) int
		Name             func(childComplexity int) int
		Popularity       func(childComplexity int) int
		ShortDescription func(childComplexity int) int
		SourceURL        func(childComplexity int) int
		Tags             func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		Version          func(childComplexity int, version string) int
		Versions         func(childComplexity int, filter map[string]interface{}) int
		Views            func(childComplexity int) int
	}

	ModVersion struct {
		ID           func(childComplexity int) int
		ModReference func(childComplexity int) int
		Versions     func(childComplexity int) int
	}

	Mutation struct {
		ApproveMod                       func(childComplexity int, modID string) int
		ApproveVersion                   func(childComplexity int, versionID string) int
		CreateAnnouncement               func(childComplexity int, announcement NewAnnouncement) int
		CreateGuide                      func(childComplexity int, guide NewGuide) int
		CreateMod                        func(childComplexity int, mod NewMod) int
		CreateMultipleTags               func(childComplexity int, tagNames []string) int
		CreateSMLVersion                 func(childComplexity int, smlVersion NewSMLVersion) int
		CreateTag                        func(childComplexity int, tagName string) int
		CreateVersion                    func(childComplexity int, modID string) int
		DeleteAnnouncement               func(childComplexity int, announcementID string) int
		DeleteGuide                      func(childComplexity int, guideID string) int
		DeleteMod                        func(childComplexity int, modID string) int
		DeleteSMLVersion                 func(childComplexity int, smlVersionID string) int
		DeleteTag                        func(childComplexity int, tagID string) int
		DeleteVersion                    func(childComplexity int, versionID string) int
		DenyMod                          func(childComplexity int, modID string) int
		DenyVersion                      func(childComplexity int, versionID string) int
		DiscourseSso                     func(childComplexity int, sso string, sig string) int
		FinalizeCreateVersion            func(childComplexity int, modID string, versionID string, version NewVersion) int
		Logout                           func(childComplexity int) int
		OAuthFacebook                    func(childComplexity int, code string, state string) int
		OAuthGithub                      func(childComplexity int, code string, state string) int
		OAuthGoogle                      func(childComplexity int, code string, state string) int
		UpdateAnnouncement               func(childComplexity int, announcementID string, announcement UpdateAnnouncement) int
		UpdateGuide                      func(childComplexity int, guideID string, guide UpdateGuide) int
		UpdateMod                        func(childComplexity int, modID string, mod UpdateMod) int
		UpdateModCompatibility           func(childComplexity int, modID string, compatibility CompatibilityInfoInput) int
		UpdateMultipleModCompatibilities func(childComplexity int, modIDs []string, compatibility CompatibilityInfoInput) int
		UpdateSMLVersion                 func(childComplexity int, smlVersionID string, smlVersion UpdateSMLVersion) int
		UpdateTag                        func(childComplexity int, tagID string, newName string) int
		UpdateUser                       func(childComplexity int, userID string, input UpdateUser) int
		UpdateVersion                    func(childComplexity int, versionID string, version UpdateVersion) int
		UploadVersionPart                func(childComplexity int, modID string, versionID string, part int, file graphql.Upload) int
	}

	OAuthOptions struct {
		Facebook func(childComplexity int) int
		Github   func(childComplexity int) int
		Google   func(childComplexity int) int
	}

	Query struct {
		CheckVersionUploadState      func(childComplexity int, modID string, versionID string) int
		GetAnnouncement              func(childComplexity int, announcementID string) int
		GetAnnouncements             func(childComplexity int) int
		GetAnnouncementsByImportance func(childComplexity int, importance AnnouncementImportance) int
		GetGuide                     func(childComplexity int, guideID string) int
		GetGuides                    func(childComplexity int, filter map[string]interface{}) int
		GetMe                        func(childComplexity int) int
		GetMod                       func(childComplexity int, modID string) int
		GetModByIDOrReference        func(childComplexity int, modIDOrReference string) int
		GetModByReference            func(childComplexity int, modReference string) int
		GetMods                      func(childComplexity int, filter map[string]interface{}) int
		GetMyMods                    func(childComplexity int, filter map[string]interface{}) int
		GetMyUnapprovedMods          func(childComplexity int, filter map[string]interface{}) int
		GetMyUnapprovedVersions      func(childComplexity int, filter map[string]interface{}) int
		GetMyVersions                func(childComplexity int, filter map[string]interface{}) int
		GetOAuthOptions              func(childComplexity int, callbackURL string) int
		GetSMLVersion                func(childComplexity int, smlVersionID string) int
		GetSMLVersions               func(childComplexity int, filter map[string]interface{}) int
		GetTag                       func(childComplexity int, tagID string) int
		GetTags                      func(childComplexity int, filter *TagFilter) int
		GetUnapprovedMods            func(childComplexity int, filter map[string]interface{}) int
		GetUnapprovedVersions        func(childComplexity int, filter map[string]interface{}) int
		GetUser                      func(childComplexity int, userID string) int
		GetUsers                     func(childComplexity int, userIds []string) int
		GetVersion                   func(childComplexity int, versionID string) int
		GetVersions                  func(childComplexity int, filter map[string]interface{}) int
		ResolveModVersions           func(childComplexity int, filter []*ModVersionConstraint) int
	}

	SMLVersion struct {
		BootstrapVersion    func(childComplexity int) int
		Changelog           func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		Date                func(childComplexity int) int
		EngineVersion       func(childComplexity int) int
		ID                  func(childComplexity int) int
		Link                func(childComplexity int) int
		SatisfactoryVersion func(childComplexity int) int
		Stability           func(childComplexity int) int
		Targets             func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
		Version             func(childComplexity int) int
	}

	SMLVersionTarget struct {
		Link       func(childComplexity int) int
		TargetName func(childComplexity int) int
		VersionID  func(childComplexity int) int
	}

	Tag struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	User struct {
		Avatar     func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		Email      func(childComplexity int) int
		FacebookID func(childComplexity int) int
		GithubID   func(childComplexity int) int
		GoogleID   func(childComplexity int) int
		Groups     func(childComplexity int) int
		Guides     func(childComplexity int) int
		ID         func(childComplexity int) int
		Mods       func(childComplexity int) int
		Roles      func(childComplexity int) int
		Username   func(childComplexity int) int
	}

	UserMod struct {
		Mod    func(childComplexity int) int
		ModID  func(childComplexity int) int
		Role   func(childComplexity int) int
		User   func(childComplexity int) int
		UserID func(childComplexity int) int
	}

	UserRoles struct {
		ApproveMods             func(childComplexity int) int
		ApproveVersions         func(childComplexity int) int
		DeleteContent           func(childComplexity int) int
		EditAnyModCompatibility func(childComplexity int) int
		EditBootstrapVersions   func(childComplexity int) int
		EditContent             func(childComplexity int) int
		EditSMLVersions         func(childComplexity int) int
		EditUsers               func(childComplexity int) int
	}

	UserSession struct {
		Token func(childComplexity int) int
	}

	Version struct {
		Approved     func(childComplexity int) int
		Changelog    func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Dependencies func(childComplexity int) int
		Downloads    func(childComplexity int) int
		Hash         func(childComplexity int) int
		ID           func(childComplexity int) int
		Link         func(childComplexity int) int
		Metadata     func(childComplexity int) int
		Mod          func(childComplexity int) int
		ModID        func(childComplexity int) int
		Size         func(childComplexity int) int
		SmlVersion   func(childComplexity int) int
		Stability    func(childComplexity int) int
		Targets      func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	VersionDependency struct {
		Condition func(childComplexity int) int
		Mod       func(childComplexity int) int
		ModID     func(childComplexity int) int
		Optional  func(childComplexity int) int
		Version   func(childComplexity int) int
		VersionID func(childComplexity int) int
	}

	VersionTarget struct {
		Hash       func(childComplexity int) int
		Link       func(childComplexity int) int
		Size       func(childComplexity int) int
		TargetName func(childComplexity int) int
		VersionID  func(childComplexity int) int
	}
}

type GetGuidesResolver interface {
	Guides(ctx context.Context, obj *GetGuides) ([]*Guide, error)
	Count(ctx context.Context, obj *GetGuides) (int, error)
}
type GetModsResolver interface {
	Mods(ctx context.Context, obj *GetMods) ([]*Mod, error)
	Count(ctx context.Context, obj *GetMods) (int, error)
}
type GetMyModsResolver interface {
	Mods(ctx context.Context, obj *GetMyMods) ([]*Mod, error)
	Count(ctx context.Context, obj *GetMyMods) (int, error)
}
type GetMyVersionsResolver interface {
	Versions(ctx context.Context, obj *GetMyVersions) ([]*Version, error)
	Count(ctx context.Context, obj *GetMyVersions) (int, error)
}
type GetSMLVersionsResolver interface {
	SmlVersions(ctx context.Context, obj *GetSMLVersions) ([]*SMLVersion, error)
	Count(ctx context.Context, obj *GetSMLVersions) (int, error)
}
type GetVersionsResolver interface {
	Versions(ctx context.Context, obj *GetVersions) ([]*Version, error)
	Count(ctx context.Context, obj *GetVersions) (int, error)
}
type GuideResolver interface {
	User(ctx context.Context, obj *Guide) (*User, error)
}
type ModResolver interface {
	Authors(ctx context.Context, obj *Mod) ([]*UserMod, error)
	Version(ctx context.Context, obj *Mod, version string) (*Version, error)
	Versions(ctx context.Context, obj *Mod, filter map[string]interface{}) ([]*Version, error)
	LatestVersions(ctx context.Context, obj *Mod) (*LatestVersions, error)
}
type MutationResolver interface {
	DiscourseSso(ctx context.Context, sso string, sig string) (*string, error)
	CreateAnnouncement(ctx context.Context, announcement NewAnnouncement) (*Announcement, error)
	UpdateAnnouncement(ctx context.Context, announcementID string, announcement UpdateAnnouncement) (*Announcement, error)
	DeleteAnnouncement(ctx context.Context, announcementID string) (bool, error)
	UpdateModCompatibility(ctx context.Context, modID string, compatibility CompatibilityInfoInput) (bool, error)
	UpdateMultipleModCompatibilities(ctx context.Context, modIDs []string, compatibility CompatibilityInfoInput) (bool, error)
	CreateGuide(ctx context.Context, guide NewGuide) (*Guide, error)
	UpdateGuide(ctx context.Context, guideID string, guide UpdateGuide) (*Guide, error)
	DeleteGuide(ctx context.Context, guideID string) (bool, error)
	CreateMod(ctx context.Context, mod NewMod) (*Mod, error)
	UpdateMod(ctx context.Context, modID string, mod UpdateMod) (*Mod, error)
	DeleteMod(ctx context.Context, modID string) (bool, error)
	ApproveMod(ctx context.Context, modID string) (bool, error)
	DenyMod(ctx context.Context, modID string) (bool, error)
	CreateSMLVersion(ctx context.Context, smlVersion NewSMLVersion) (*SMLVersion, error)
	UpdateSMLVersion(ctx context.Context, smlVersionID string, smlVersion UpdateSMLVersion) (*SMLVersion, error)
	DeleteSMLVersion(ctx context.Context, smlVersionID string) (bool, error)
	CreateTag(ctx context.Context, tagName string) (*Tag, error)
	CreateMultipleTags(ctx context.Context, tagNames []string) ([]*Tag, error)
	UpdateTag(ctx context.Context, tagID string, newName string) (*Tag, error)
	DeleteTag(ctx context.Context, tagID string) (bool, error)
	UpdateUser(ctx context.Context, userID string, input UpdateUser) (*User, error)
	Logout(ctx context.Context) (bool, error)
	OAuthGithub(ctx context.Context, code string, state string) (*UserSession, error)
	OAuthGoogle(ctx context.Context, code string, state string) (*UserSession, error)
	OAuthFacebook(ctx context.Context, code string, state string) (*UserSession, error)
	CreateVersion(ctx context.Context, modID string) (string, error)
	UploadVersionPart(ctx context.Context, modID string, versionID string, part int, file graphql.Upload) (bool, error)
	FinalizeCreateVersion(ctx context.Context, modID string, versionID string, version NewVersion) (bool, error)
	UpdateVersion(ctx context.Context, versionID string, version UpdateVersion) (*Version, error)
	DeleteVersion(ctx context.Context, versionID string) (bool, error)
	ApproveVersion(ctx context.Context, versionID string) (bool, error)
	DenyVersion(ctx context.Context, versionID string) (bool, error)
}
type QueryResolver interface {
	GetOAuthOptions(ctx context.Context, callbackURL string) (*OAuthOptions, error)
	GetAnnouncement(ctx context.Context, announcementID string) (*Announcement, error)
	GetAnnouncements(ctx context.Context) ([]*Announcement, error)
	GetAnnouncementsByImportance(ctx context.Context, importance AnnouncementImportance) ([]*Announcement, error)
	GetGuide(ctx context.Context, guideID string) (*Guide, error)
	GetGuides(ctx context.Context, filter map[string]interface{}) (*GetGuides, error)
	GetMod(ctx context.Context, modID string) (*Mod, error)
	GetModByReference(ctx context.Context, modReference string) (*Mod, error)
	GetModByIDOrReference(ctx context.Context, modIDOrReference string) (*Mod, error)
	GetMods(ctx context.Context, filter map[string]interface{}) (*GetMods, error)
	GetUnapprovedMods(ctx context.Context, filter map[string]interface{}) (*GetMods, error)
	GetMyMods(ctx context.Context, filter map[string]interface{}) (*GetMyMods, error)
	GetMyUnapprovedMods(ctx context.Context, filter map[string]interface{}) (*GetMyMods, error)
	ResolveModVersions(ctx context.Context, filter []*ModVersionConstraint) ([]*ModVersion, error)
	GetSMLVersion(ctx context.Context, smlVersionID string) (*SMLVersion, error)
	GetSMLVersions(ctx context.Context, filter map[string]interface{}) (*GetSMLVersions, error)
	GetTag(ctx context.Context, tagID string) (*Tag, error)
	GetTags(ctx context.Context, filter *TagFilter) ([]*Tag, error)
	GetMe(ctx context.Context) (*User, error)
	GetUser(ctx context.Context, userID string) (*User, error)
	GetUsers(ctx context.Context, userIds []string) ([]*User, error)
	GetVersion(ctx context.Context, versionID string) (*Version, error)
	GetVersions(ctx context.Context, filter map[string]interface{}) (*GetVersions, error)
	GetUnapprovedVersions(ctx context.Context, filter map[string]interface{}) (*GetVersions, error)
	CheckVersionUploadState(ctx context.Context, modID string, versionID string) (*CreateVersionResponse, error)
	GetMyVersions(ctx context.Context, filter map[string]interface{}) (*GetMyVersions, error)
	GetMyUnapprovedVersions(ctx context.Context, filter map[string]interface{}) (*GetMyVersions, error)
}
type UserResolver interface {
	Roles(ctx context.Context, obj *User) (*UserRoles, error)
	Groups(ctx context.Context, obj *User) ([]*Group, error)
	Mods(ctx context.Context, obj *User) ([]*UserMod, error)
	Guides(ctx context.Context, obj *User) ([]*Guide, error)
}
type UserModResolver interface {
	User(ctx context.Context, obj *UserMod) (*User, error)
	Mod(ctx context.Context, obj *UserMod) (*Mod, error)
}
type VersionResolver interface {
	Link(ctx context.Context, obj *Version) (string, error)

	Size(ctx context.Context, obj *Version) (*int, error)
	Hash(ctx context.Context, obj *Version) (*string, error)
	Mod(ctx context.Context, obj *Version) (*Mod, error)
	Dependencies(ctx context.Context, obj *Version) ([]*VersionDependency, error)
}
type VersionTargetResolver interface {
	Link(ctx context.Context, obj *VersionTarget) (string, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Announcement.id":
		if e.complexity.Announcement.ID == nil {
			break
		}

		return e.complexity.Announcement.ID(childComplexity), true

	case "Announcement.importance":
		if e.complexity.Announcement.Importance == nil {
			break
		}

		return e.complexity.Announcement.Importance(childComplexity), true

	case "Announcement.message":
		if e.complexity.Announcement.Message == nil {
			break
		}

		return e.complexity.Announcement.Message(childComplexity), true

	case "Compatibility.note":
		if e.complexity.Compatibility.Note == nil {
			break
		}

		return e.complexity.Compatibility.Note(childComplexity), true

	case "Compatibility.state":
		if e.complexity.Compatibility.State == nil {
			break
		}

		return e.complexity.Compatibility.State(childComplexity), true

	case "CompatibilityInfo.EA":
		if e.complexity.CompatibilityInfo.Ea == nil {
			break
		}

		return e.complexity.CompatibilityInfo.Ea(childComplexity), true

	case "CompatibilityInfo.EXP":
		if e.complexity.CompatibilityInfo.Exp == nil {
			break
		}

		return e.complexity.CompatibilityInfo.Exp(childComplexity), true

	case "CreateVersionResponse.auto_approved":
		if e.complexity.CreateVersionResponse.AutoApproved == nil {
			break
		}

		return e.complexity.CreateVersionResponse.AutoApproved(childComplexity), true

	case "CreateVersionResponse.version":
		if e.complexity.CreateVersionResponse.Version == nil {
			break
		}

		return e.complexity.CreateVersionResponse.Version(childComplexity), true

	case "GetGuides.count":
		if e.complexity.GetGuides.Count == nil {
			break
		}

		return e.complexity.GetGuides.Count(childComplexity), true

	case "GetGuides.guides":
		if e.complexity.GetGuides.Guides == nil {
			break
		}

		return e.complexity.GetGuides.Guides(childComplexity), true

	case "GetMods.count":
		if e.complexity.GetMods.Count == nil {
			break
		}

		return e.complexity.GetMods.Count(childComplexity), true

	case "GetMods.mods":
		if e.complexity.GetMods.Mods == nil {
			break
		}

		return e.complexity.GetMods.Mods(childComplexity), true

	case "GetMyMods.count":
		if e.complexity.GetMyMods.Count == nil {
			break
		}

		return e.complexity.GetMyMods.Count(childComplexity), true

	case "GetMyMods.mods":
		if e.complexity.GetMyMods.Mods == nil {
			break
		}

		return e.complexity.GetMyMods.Mods(childComplexity), true

	case "GetMyVersions.count":
		if e.complexity.GetMyVersions.Count == nil {
			break
		}

		return e.complexity.GetMyVersions.Count(childComplexity), true

	case "GetMyVersions.versions":
		if e.complexity.GetMyVersions.Versions == nil {
			break
		}

		return e.complexity.GetMyVersions.Versions(childComplexity), true

	case "GetSMLVersions.count":
		if e.complexity.GetSMLVersions.Count == nil {
			break
		}

		return e.complexity.GetSMLVersions.Count(childComplexity), true

	case "GetSMLVersions.sml_versions":
		if e.complexity.GetSMLVersions.SmlVersions == nil {
			break
		}

		return e.complexity.GetSMLVersions.SmlVersions(childComplexity), true

	case "GetVersions.count":
		if e.complexity.GetVersions.Count == nil {
			break
		}

		return e.complexity.GetVersions.Count(childComplexity), true

	case "GetVersions.versions":
		if e.complexity.GetVersions.Versions == nil {
			break
		}

		return e.complexity.GetVersions.Versions(childComplexity), true

	case "Group.id":
		if e.complexity.Group.ID == nil {
			break
		}

		return e.complexity.Group.ID(childComplexity), true

	case "Group.name":
		if e.complexity.Group.Name == nil {
			break
		}

		return e.complexity.Group.Name(childComplexity), true

	case "Guide.created_at":
		if e.complexity.Guide.CreatedAt == nil {
			break
		}

		return e.complexity.Guide.CreatedAt(childComplexity), true

	case "Guide.guide":
		if e.complexity.Guide.Guide == nil {
			break
		}

		return e.complexity.Guide.Guide(childComplexity), true

	case "Guide.id":
		if e.complexity.Guide.ID == nil {
			break
		}

		return e.complexity.Guide.ID(childComplexity), true

	case "Guide.name":
		if e.complexity.Guide.Name == nil {
			break
		}

		return e.complexity.Guide.Name(childComplexity), true

	case "Guide.short_description":
		if e.complexity.Guide.ShortDescription == nil {
			break
		}

		return e.complexity.Guide.ShortDescription(childComplexity), true

	case "Guide.tags":
		if e.complexity.Guide.Tags == nil {
			break
		}

		return e.complexity.Guide.Tags(childComplexity), true

	case "Guide.updated_at":
		if e.complexity.Guide.UpdatedAt == nil {
			break
		}

		return e.complexity.Guide.UpdatedAt(childComplexity), true

	case "Guide.user":
		if e.complexity.Guide.User == nil {
			break
		}

		return e.complexity.Guide.User(childComplexity), true

	case "Guide.user_id":
		if e.complexity.Guide.UserID == nil {
			break
		}

		return e.complexity.Guide.UserID(childComplexity), true

	case "Guide.views":
		if e.complexity.Guide.Views == nil {
			break
		}

		return e.complexity.Guide.Views(childComplexity), true

	case "LatestVersions.alpha":
		if e.complexity.LatestVersions.Alpha == nil {
			break
		}

		return e.complexity.LatestVersions.Alpha(childComplexity), true

	case "LatestVersions.beta":
		if e.complexity.LatestVersions.Beta == nil {
			break
		}

		return e.complexity.LatestVersions.Beta(childComplexity), true

	case "LatestVersions.release":
		if e.complexity.LatestVersions.Release == nil {
			break
		}

		return e.complexity.LatestVersions.Release(childComplexity), true

	case "Mod.approved":
		if e.complexity.Mod.Approved == nil {
			break
		}

		return e.complexity.Mod.Approved(childComplexity), true

	case "Mod.authors":
		if e.complexity.Mod.Authors == nil {
			break
		}

		return e.complexity.Mod.Authors(childComplexity), true

	case "Mod.compatibility":
		if e.complexity.Mod.Compatibility == nil {
			break
		}

		return e.complexity.Mod.Compatibility(childComplexity), true

	case "Mod.created_at":
		if e.complexity.Mod.CreatedAt == nil {
			break
		}

		return e.complexity.Mod.CreatedAt(childComplexity), true

	case "Mod.creator_id":
		if e.complexity.Mod.CreatorID == nil {
			break
		}

		return e.complexity.Mod.CreatorID(childComplexity), true

	case "Mod.downloads":
		if e.complexity.Mod.Downloads == nil {
			break
		}

		return e.complexity.Mod.Downloads(childComplexity), true

	case "Mod.full_description":
		if e.complexity.Mod.FullDescription == nil {
			break
		}

		return e.complexity.Mod.FullDescription(childComplexity), true

	case "Mod.hidden":
		if e.complexity.Mod.Hidden == nil {
			break
		}

		return e.complexity.Mod.Hidden(childComplexity), true

	case "Mod.hotness":
		if e.complexity.Mod.Hotness == nil {
			break
		}

		return e.complexity.Mod.Hotness(childComplexity), true

	case "Mod.id":
		if e.complexity.Mod.ID == nil {
			break
		}

		return e.complexity.Mod.ID(childComplexity), true

	case "Mod.last_version_date":
		if e.complexity.Mod.LastVersionDate == nil {
			break
		}

		return e.complexity.Mod.LastVersionDate(childComplexity), true

	case "Mod.latestVersions":
		if e.complexity.Mod.LatestVersions == nil {
			break
		}

		return e.complexity.Mod.LatestVersions(childComplexity), true

	case "Mod.logo":
		if e.complexity.Mod.Logo == nil {
			break
		}

		return e.complexity.Mod.Logo(childComplexity), true

	case "Mod.mod_reference":
		if e.complexity.Mod.ModReference == nil {
			break
		}

		return e.complexity.Mod.ModReference(childComplexity), true

	case "Mod.name":
		if e.complexity.Mod.Name == nil {
			break
		}

		return e.complexity.Mod.Name(childComplexity), true

	case "Mod.popularity":
		if e.complexity.Mod.Popularity == nil {
			break
		}

		return e.complexity.Mod.Popularity(childComplexity), true

	case "Mod.short_description":
		if e.complexity.Mod.ShortDescription == nil {
			break
		}

		return e.complexity.Mod.ShortDescription(childComplexity), true

	case "Mod.source_url":
		if e.complexity.Mod.SourceURL == nil {
			break
		}

		return e.complexity.Mod.SourceURL(childComplexity), true

	case "Mod.tags":
		if e.complexity.Mod.Tags == nil {
			break
		}

		return e.complexity.Mod.Tags(childComplexity), true

	case "Mod.updated_at":
		if e.complexity.Mod.UpdatedAt == nil {
			break
		}

		return e.complexity.Mod.UpdatedAt(childComplexity), true

	case "Mod.version":
		if e.complexity.Mod.Version == nil {
			break
		}

		args, err := ec.field_Mod_version_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mod.Version(childComplexity, args["version"].(string)), true

	case "Mod.versions":
		if e.complexity.Mod.Versions == nil {
			break
		}

		args, err := ec.field_Mod_versions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mod.Versions(childComplexity, args["filter"].(map[string]interface{})), true

	case "Mod.views":
		if e.complexity.Mod.Views == nil {
			break
		}

		return e.complexity.Mod.Views(childComplexity), true

	case "ModVersion.id":
		if e.complexity.ModVersion.ID == nil {
			break
		}

		return e.complexity.ModVersion.ID(childComplexity), true

	case "ModVersion.mod_reference":
		if e.complexity.ModVersion.ModReference == nil {
			break
		}

		return e.complexity.ModVersion.ModReference(childComplexity), true

	case "ModVersion.versions":
		if e.complexity.ModVersion.Versions == nil {
			break
		}

		return e.complexity.ModVersion.Versions(childComplexity), true

	case "Mutation.approveMod":
		if e.complexity.Mutation.ApproveMod == nil {
			break
		}

		args, err := ec.field_Mutation_approveMod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApproveMod(childComplexity, args["modId"].(string)), true

	case "Mutation.approveVersion":
		if e.complexity.Mutation.ApproveVersion == nil {
			break
		}

		args, err := ec.field_Mutation_approveVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApproveVersion(childComplexity, args["versionId"].(string)), true

	case "Mutation.createAnnouncement":
		if e.complexity.Mutation.CreateAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_createAnnouncement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAnnouncement(childComplexity, args["announcement"].(NewAnnouncement)), true

	case "Mutation.createGuide":
		if e.complexity.Mutation.CreateGuide == nil {
			break
		}

		args, err := ec.field_Mutation_createGuide_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateGuide(childComplexity, args["guide"].(NewGuide)), true

	case "Mutation.createMod":
		if e.complexity.Mutation.CreateMod == nil {
			break
		}

		args, err := ec.field_Mutation_createMod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMod(childComplexity, args["mod"].(NewMod)), true

	case "Mutation.createMultipleTags":
		if e.complexity.Mutation.CreateMultipleTags == nil {
			break
		}

		args, err := ec.field_Mutation_createMultipleTags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMultipleTags(childComplexity, args["tagNames"].([]string)), true

	case "Mutation.createSMLVersion":
		if e.complexity.Mutation.CreateSMLVersion == nil {
			break
		}

		args, err := ec.field_Mutation_createSMLVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSMLVersion(childComplexity, args["smlVersion"].(NewSMLVersion)), true

	case "Mutation.createTag":
		if e.complexity.Mutation.CreateTag == nil {
			break
		}

		args, err := ec.field_Mutation_createTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTag(childComplexity, args["tagName"].(string)), true

	case "Mutation.createVersion":
		if e.complexity.Mutation.CreateVersion == nil {
			break
		}

		args, err := ec.field_Mutation_createVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateVersion(childComplexity, args["modId"].(string)), true

	case "Mutation.deleteAnnouncement":
		if e.complexity.Mutation.DeleteAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAnnouncement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAnnouncement(childComplexity, args["announcementId"].(string)), true

	case "Mutation.deleteGuide":
		if e.complexity.Mutation.DeleteGuide == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGuide_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGuide(childComplexity, args["guideId"].(string)), true

	case "Mutation.deleteMod":
		if e.complexity.Mutation.DeleteMod == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMod(childComplexity, args["modId"].(string)), true

	case "Mutation.deleteSMLVersion":
		if e.complexity.Mutation.DeleteSMLVersion == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSMLVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSMLVersion(childComplexity, args["smlVersionId"].(string)), true

	case "Mutation.deleteTag":
		if e.complexity.Mutation.DeleteTag == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTag(childComplexity, args["tagID"].(string)), true

	case "Mutation.deleteVersion":
		if e.complexity.Mutation.DeleteVersion == nil {
			break
		}

		args, err := ec.field_Mutation_deleteVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteVersion(childComplexity, args["versionId"].(string)), true

	case "Mutation.denyMod":
		if e.complexity.Mutation.DenyMod == nil {
			break
		}

		args, err := ec.field_Mutation_denyMod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DenyMod(childComplexity, args["modId"].(string)), true

	case "Mutation.denyVersion":
		if e.complexity.Mutation.DenyVersion == nil {
			break
		}

		args, err := ec.field_Mutation_denyVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DenyVersion(childComplexity, args["versionId"].(string)), true

	case "Mutation.discourseSSO":
		if e.complexity.Mutation.DiscourseSso == nil {
			break
		}

		args, err := ec.field_Mutation_discourseSSO_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DiscourseSso(childComplexity, args["sso"].(string), args["sig"].(string)), true

	case "Mutation.finalizeCreateVersion":
		if e.complexity.Mutation.FinalizeCreateVersion == nil {
			break
		}

		args, err := ec.field_Mutation_finalizeCreateVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FinalizeCreateVersion(childComplexity, args["modId"].(string), args["versionId"].(string), args["version"].(NewVersion)), true

	case "Mutation.logout":
		if e.complexity.Mutation.Logout == nil {
			break
		}

		return e.complexity.Mutation.Logout(childComplexity), true

	case "Mutation.oAuthFacebook":
		if e.complexity.Mutation.OAuthFacebook == nil {
			break
		}

		args, err := ec.field_Mutation_oAuthFacebook_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OAuthFacebook(childComplexity, args["code"].(string), args["state"].(string)), true

	case "Mutation.oAuthGithub":
		if e.complexity.Mutation.OAuthGithub == nil {
			break
		}

		args, err := ec.field_Mutation_oAuthGithub_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OAuthGithub(childComplexity, args["code"].(string), args["state"].(string)), true

	case "Mutation.oAuthGoogle":
		if e.complexity.Mutation.OAuthGoogle == nil {
			break
		}

		args, err := ec.field_Mutation_oAuthGoogle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OAuthGoogle(childComplexity, args["code"].(string), args["state"].(string)), true

	case "Mutation.updateAnnouncement":
		if e.complexity.Mutation.UpdateAnnouncement == nil {
			break
		}

		args, err := ec.field_Mutation_updateAnnouncement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAnnouncement(childComplexity, args["announcementId"].(string), args["announcement"].(UpdateAnnouncement)), true

	case "Mutation.updateGuide":
		if e.complexity.Mutation.UpdateGuide == nil {
			break
		}

		args, err := ec.field_Mutation_updateGuide_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGuide(childComplexity, args["guideId"].(string), args["guide"].(UpdateGuide)), true

	case "Mutation.updateMod":
		if e.complexity.Mutation.UpdateMod == nil {
			break
		}

		args, err := ec.field_Mutation_updateMod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMod(childComplexity, args["modId"].(string), args["mod"].(UpdateMod)), true

	case "Mutation.updateModCompatibility":
		if e.complexity.Mutation.UpdateModCompatibility == nil {
			break
		}

		args, err := ec.field_Mutation_updateModCompatibility_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateModCompatibility(childComplexity, args["modId"].(string), args["compatibility"].(CompatibilityInfoInput)), true

	case "Mutation.updateMultipleModCompatibilities":
		if e.complexity.Mutation.UpdateMultipleModCompatibilities == nil {
			break
		}

		args, err := ec.field_Mutation_updateMultipleModCompatibilities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMultipleModCompatibilities(childComplexity, args["modIDs"].([]string), args["compatibility"].(CompatibilityInfoInput)), true

	case "Mutation.updateSMLVersion":
		if e.complexity.Mutation.UpdateSMLVersion == nil {
			break
		}

		args, err := ec.field_Mutation_updateSMLVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSMLVersion(childComplexity, args["smlVersionId"].(string), args["smlVersion"].(UpdateSMLVersion)), true

	case "Mutation.updateTag":
		if e.complexity.Mutation.UpdateTag == nil {
			break
		}

		args, err := ec.field_Mutation_updateTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTag(childComplexity, args["tagID"].(string), args["NewName"].(string)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["userId"].(string), args["input"].(UpdateUser)), true

	case "Mutation.updateVersion":
		if e.complexity.Mutation.UpdateVersion == nil {
			break
		}

		args, err := ec.field_Mutation_updateVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVersion(childComplexity, args["versionId"].(string), args["version"].(UpdateVersion)), true

	case "Mutation.uploadVersionPart":
		if e.complexity.Mutation.UploadVersionPart == nil {
			break
		}

		args, err := ec.field_Mutation_uploadVersionPart_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadVersionPart(childComplexity, args["modId"].(string), args["versionId"].(string), args["part"].(int), args["file"].(graphql.Upload)), true

	case "OAuthOptions.facebook":
		if e.complexity.OAuthOptions.Facebook == nil {
			break
		}

		return e.complexity.OAuthOptions.Facebook(childComplexity), true

	case "OAuthOptions.github":
		if e.complexity.OAuthOptions.Github == nil {
			break
		}

		return e.complexity.OAuthOptions.Github(childComplexity), true

	case "OAuthOptions.google":
		if e.complexity.OAuthOptions.Google == nil {
			break
		}

		return e.complexity.OAuthOptions.Google(childComplexity), true

	case "Query.checkVersionUploadState":
		if e.complexity.Query.CheckVersionUploadState == nil {
			break
		}

		args, err := ec.field_Query_checkVersionUploadState_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CheckVersionUploadState(childComplexity, args["modId"].(string), args["versionId"].(string)), true

	case "Query.getAnnouncement":
		if e.complexity.Query.GetAnnouncement == nil {
			break
		}

		args, err := ec.field_Query_getAnnouncement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAnnouncement(childComplexity, args["announcementId"].(string)), true

	case "Query.getAnnouncements":
		if e.complexity.Query.GetAnnouncements == nil {
			break
		}

		return e.complexity.Query.GetAnnouncements(childComplexity), true

	case "Query.getAnnouncementsByImportance":
		if e.complexity.Query.GetAnnouncementsByImportance == nil {
			break
		}

		args, err := ec.field_Query_getAnnouncementsByImportance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAnnouncementsByImportance(childComplexity, args["importance"].(AnnouncementImportance)), true

	case "Query.getGuide":
		if e.complexity.Query.GetGuide == nil {
			break
		}

		args, err := ec.field_Query_getGuide_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetGuide(childComplexity, args["guideId"].(string)), true

	case "Query.getGuides":
		if e.complexity.Query.GetGuides == nil {
			break
		}

		args, err := ec.field_Query_getGuides_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetGuides(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getMe":
		if e.complexity.Query.GetMe == nil {
			break
		}

		return e.complexity.Query.GetMe(childComplexity), true

	case "Query.getMod":
		if e.complexity.Query.GetMod == nil {
			break
		}

		args, err := ec.field_Query_getMod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMod(childComplexity, args["modId"].(string)), true

	case "Query.getModByIdOrReference":
		if e.complexity.Query.GetModByIDOrReference == nil {
			break
		}

		args, err := ec.field_Query_getModByIdOrReference_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetModByIDOrReference(childComplexity, args["modIdOrReference"].(string)), true

	case "Query.getModByReference":
		if e.complexity.Query.GetModByReference == nil {
			break
		}

		args, err := ec.field_Query_getModByReference_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetModByReference(childComplexity, args["modReference"].(string)), true

	case "Query.getMods":
		if e.complexity.Query.GetMods == nil {
			break
		}

		args, err := ec.field_Query_getMods_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMods(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getMyMods":
		if e.complexity.Query.GetMyMods == nil {
			break
		}

		args, err := ec.field_Query_getMyMods_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMyMods(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getMyUnapprovedMods":
		if e.complexity.Query.GetMyUnapprovedMods == nil {
			break
		}

		args, err := ec.field_Query_getMyUnapprovedMods_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMyUnapprovedMods(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getMyUnapprovedVersions":
		if e.complexity.Query.GetMyUnapprovedVersions == nil {
			break
		}

		args, err := ec.field_Query_getMyUnapprovedVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMyUnapprovedVersions(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getMyVersions":
		if e.complexity.Query.GetMyVersions == nil {
			break
		}

		args, err := ec.field_Query_getMyVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMyVersions(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getOAuthOptions":
		if e.complexity.Query.GetOAuthOptions == nil {
			break
		}

		args, err := ec.field_Query_getOAuthOptions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetOAuthOptions(childComplexity, args["callback_url"].(string)), true

	case "Query.getSMLVersion":
		if e.complexity.Query.GetSMLVersion == nil {
			break
		}

		args, err := ec.field_Query_getSMLVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSMLVersion(childComplexity, args["smlVersionID"].(string)), true

	case "Query.getSMLVersions":
		if e.complexity.Query.GetSMLVersions == nil {
			break
		}

		args, err := ec.field_Query_getSMLVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSMLVersions(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getTag":
		if e.complexity.Query.GetTag == nil {
			break
		}

		args, err := ec.field_Query_getTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTag(childComplexity, args["tagID"].(string)), true

	case "Query.getTags":
		if e.complexity.Query.GetTags == nil {
			break
		}

		args, err := ec.field_Query_getTags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTags(childComplexity, args["filter"].(*TagFilter)), true

	case "Query.getUnapprovedMods":
		if e.complexity.Query.GetUnapprovedMods == nil {
			break
		}

		args, err := ec.field_Query_getUnapprovedMods_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUnapprovedMods(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getUnapprovedVersions":
		if e.complexity.Query.GetUnapprovedVersions == nil {
			break
		}

		args, err := ec.field_Query_getUnapprovedVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUnapprovedVersions(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.getUser":
		if e.complexity.Query.GetUser == nil {
			break
		}

		args, err := ec.field_Query_getUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUser(childComplexity, args["userId"].(string)), true

	case "Query.getUsers":
		if e.complexity.Query.GetUsers == nil {
			break
		}

		args, err := ec.field_Query_getUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUsers(childComplexity, args["userIds"].([]string)), true

	case "Query.getVersion":
		if e.complexity.Query.GetVersion == nil {
			break
		}

		args, err := ec.field_Query_getVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetVersion(childComplexity, args["versionId"].(string)), true

	case "Query.getVersions":
		if e.complexity.Query.GetVersions == nil {
			break
		}

		args, err := ec.field_Query_getVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetVersions(childComplexity, args["filter"].(map[string]interface{})), true

	case "Query.resolveModVersions":
		if e.complexity.Query.ResolveModVersions == nil {
			break
		}

		args, err := ec.field_Query_resolveModVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ResolveModVersions(childComplexity, args["filter"].([]*ModVersionConstraint)), true

	case "SMLVersion.bootstrap_version":
		if e.complexity.SMLVersion.BootstrapVersion == nil {
			break
		}

		return e.complexity.SMLVersion.BootstrapVersion(childComplexity), true

	case "SMLVersion.changelog":
		if e.complexity.SMLVersion.Changelog == nil {
			break
		}

		return e.complexity.SMLVersion.Changelog(childComplexity), true

	case "SMLVersion.created_at":
		if e.complexity.SMLVersion.CreatedAt == nil {
			break
		}

		return e.complexity.SMLVersion.CreatedAt(childComplexity), true

	case "SMLVersion.date":
		if e.complexity.SMLVersion.Date == nil {
			break
		}

		return e.complexity.SMLVersion.Date(childComplexity), true

	case "SMLVersion.engine_version":
		if e.complexity.SMLVersion.EngineVersion == nil {
			break
		}

		return e.complexity.SMLVersion.EngineVersion(childComplexity), true

	case "SMLVersion.id":
		if e.complexity.SMLVersion.ID == nil {
			break
		}

		return e.complexity.SMLVersion.ID(childComplexity), true

	case "SMLVersion.link":
		if e.complexity.SMLVersion.Link == nil {
			break
		}

		return e.complexity.SMLVersion.Link(childComplexity), true

	case "SMLVersion.satisfactory_version":
		if e.complexity.SMLVersion.SatisfactoryVersion == nil {
			break
		}

		return e.complexity.SMLVersion.SatisfactoryVersion(childComplexity), true

	case "SMLVersion.stability":
		if e.complexity.SMLVersion.Stability == nil {
			break
		}

		return e.complexity.SMLVersion.Stability(childComplexity), true

	case "SMLVersion.targets":
		if e.complexity.SMLVersion.Targets == nil {
			break
		}

		return e.complexity.SMLVersion.Targets(childComplexity), true

	case "SMLVersion.updated_at":
		if e.complexity.SMLVersion.UpdatedAt == nil {
			break
		}

		return e.complexity.SMLVersion.UpdatedAt(childComplexity), true

	case "SMLVersion.version":
		if e.complexity.SMLVersion.Version == nil {
			break
		}

		return e.complexity.SMLVersion.Version(childComplexity), true

	case "SMLVersionTarget.link":
		if e.complexity.SMLVersionTarget.Link == nil {
			break
		}

		return e.complexity.SMLVersionTarget.Link(childComplexity), true

	case "SMLVersionTarget.targetName":
		if e.complexity.SMLVersionTarget.TargetName == nil {
			break
		}

		return e.complexity.SMLVersionTarget.TargetName(childComplexity), true

	case "SMLVersionTarget.VersionID":
		if e.complexity.SMLVersionTarget.VersionID == nil {
			break
		}

		return e.complexity.SMLVersionTarget.VersionID(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "User.avatar":
		if e.complexity.User.Avatar == nil {
			break
		}

		return e.complexity.User.Avatar(childComplexity), true

	case "User.created_at":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.facebook_id":
		if e.complexity.User.FacebookID == nil {
			break
		}

		return e.complexity.User.FacebookID(childComplexity), true

	case "User.github_id":
		if e.complexity.User.GithubID == nil {
			break
		}

		return e.complexity.User.GithubID(childComplexity), true

	case "User.google_id":
		if e.complexity.User.GoogleID == nil {
			break
		}

		return e.complexity.User.GoogleID(childComplexity), true

	case "User.groups":
		if e.complexity.User.Groups == nil {
			break
		}

		return e.complexity.User.Groups(childComplexity), true

	case "User.guides":
		if e.complexity.User.Guides == nil {
			break
		}

		return e.complexity.User.Guides(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.mods":
		if e.complexity.User.Mods == nil {
			break
		}

		return e.complexity.User.Mods(childComplexity), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "UserMod.mod":
		if e.complexity.UserMod.Mod == nil {
			break
		}

		return e.complexity.UserMod.Mod(childComplexity), true

	case "UserMod.mod_id":
		if e.complexity.UserMod.ModID == nil {
			break
		}

		return e.complexity.UserMod.ModID(childComplexity), true

	case "UserMod.role":
		if e.complexity.UserMod.Role == nil {
			break
		}

		return e.complexity.UserMod.Role(childComplexity), true

	case "UserMod.user":
		if e.complexity.UserMod.User == nil {
			break
		}

		return e.complexity.UserMod.User(childComplexity), true

	case "UserMod.user_id":
		if e.complexity.UserMod.UserID == nil {
			break
		}

		return e.complexity.UserMod.UserID(childComplexity), true

	case "UserRoles.approveMods":
		if e.complexity.UserRoles.ApproveMods == nil {
			break
		}

		return e.complexity.UserRoles.ApproveMods(childComplexity), true

	case "UserRoles.approveVersions":
		if e.complexity.UserRoles.ApproveVersions == nil {
			break
		}

		return e.complexity.UserRoles.ApproveVersions(childComplexity), true

	case "UserRoles.deleteContent":
		if e.complexity.UserRoles.DeleteContent == nil {
			break
		}

		return e.complexity.UserRoles.DeleteContent(childComplexity), true

	case "UserRoles.editAnyModCompatibility":
		if e.complexity.UserRoles.EditAnyModCompatibility == nil {
			break
		}

		return e.complexity.UserRoles.EditAnyModCompatibility(childComplexity), true

	case "UserRoles.editBootstrapVersions":
		if e.complexity.UserRoles.EditBootstrapVersions == nil {
			break
		}

		return e.complexity.UserRoles.EditBootstrapVersions(childComplexity), true

	case "UserRoles.editContent":
		if e.complexity.UserRoles.EditContent == nil {
			break
		}

		return e.complexity.UserRoles.EditContent(childComplexity), true

	case "UserRoles.editSMLVersions":
		if e.complexity.UserRoles.EditSMLVersions == nil {
			break
		}

		return e.complexity.UserRoles.EditSMLVersions(childComplexity), true

	case "UserRoles.editUsers":
		if e.complexity.UserRoles.EditUsers == nil {
			break
		}

		return e.complexity.UserRoles.EditUsers(childComplexity), true

	case "UserSession.token":
		if e.complexity.UserSession.Token == nil {
			break
		}

		return e.complexity.UserSession.Token(childComplexity), true

	case "Version.approved":
		if e.complexity.Version.Approved == nil {
			break
		}

		return e.complexity.Version.Approved(childComplexity), true

	case "Version.changelog":
		if e.complexity.Version.Changelog == nil {
			break
		}

		return e.complexity.Version.Changelog(childComplexity), true

	case "Version.created_at":
		if e.complexity.Version.CreatedAt == nil {
			break
		}

		return e.complexity.Version.CreatedAt(childComplexity), true

	case "Version.dependencies":
		if e.complexity.Version.Dependencies == nil {
			break
		}

		return e.complexity.Version.Dependencies(childComplexity), true

	case "Version.downloads":
		if e.complexity.Version.Downloads == nil {
			break
		}

		return e.complexity.Version.Downloads(childComplexity), true

	case "Version.hash":
		if e.complexity.Version.Hash == nil {
			break
		}

		return e.complexity.Version.Hash(childComplexity), true

	case "Version.id":
		if e.complexity.Version.ID == nil {
			break
		}

		return e.complexity.Version.ID(childComplexity), true

	case "Version.link":
		if e.complexity.Version.Link == nil {
			break
		}

		return e.complexity.Version.Link(childComplexity), true

	case "Version.metadata":
		if e.complexity.Version.Metadata == nil {
			break
		}

		return e.complexity.Version.Metadata(childComplexity), true

	case "Version.mod":
		if e.complexity.Version.Mod == nil {
			break
		}

		return e.complexity.Version.Mod(childComplexity), true

	case "Version.mod_id":
		if e.complexity.Version.ModID == nil {
			break
		}

		return e.complexity.Version.ModID(childComplexity), true

	case "Version.size":
		if e.complexity.Version.Size == nil {
			break
		}

		return e.complexity.Version.Size(childComplexity), true

	case "Version.sml_version":
		if e.complexity.Version.SmlVersion == nil {
			break
		}

		return e.complexity.Version.SmlVersion(childComplexity), true

	case "Version.stability":
		if e.complexity.Version.Stability == nil {
			break
		}

		return e.complexity.Version.Stability(childComplexity), true

	case "Version.targets":
		if e.complexity.Version.Targets == nil {
			break
		}

		return e.complexity.Version.Targets(childComplexity), true

	case "Version.updated_at":
		if e.complexity.Version.UpdatedAt == nil {
			break
		}

		return e.complexity.Version.UpdatedAt(childComplexity), true

	case "Version.version":
		if e.complexity.Version.Version == nil {
			break
		}

		return e.complexity.Version.Version(childComplexity), true

	case "VersionDependency.condition":
		if e.complexity.VersionDependency.Condition == nil {
			break
		}

		return e.complexity.VersionDependency.Condition(childComplexity), true

	case "VersionDependency.mod":
		if e.complexity.VersionDependency.Mod == nil {
			break
		}

		return e.complexity.VersionDependency.Mod(childComplexity), true

	case "VersionDependency.mod_id":
		if e.complexity.VersionDependency.ModID == nil {
			break
		}

		return e.complexity.VersionDependency.ModID(childComplexity), true

	case "VersionDependency.optional":
		if e.complexity.VersionDependency.Optional == nil {
			break
		}

		return e.complexity.VersionDependency.Optional(childComplexity), true

	case "VersionDependency.version":
		if e.complexity.VersionDependency.Version == nil {
			break
		}

		return e.complexity.VersionDependency.Version(childComplexity), true

	case "VersionDependency.version_id":
		if e.complexity.VersionDependency.VersionID == nil {
			break
		}

		return e.complexity.VersionDependency.VersionID(childComplexity), true

	case "VersionTarget.hash":
		if e.complexity.VersionTarget.Hash == nil {
			break
		}

		return e.complexity.VersionTarget.Hash(childComplexity), true

	case "VersionTarget.link":
		if e.complexity.VersionTarget.Link == nil {
			break
		}

		return e.complexity.VersionTarget.Link(childComplexity), true

	case "VersionTarget.size":
		if e.complexity.VersionTarget.Size == nil {
			break
		}

		return e.complexity.VersionTarget.Size(childComplexity), true

	case "VersionTarget.targetName":
		if e.complexity.VersionTarget.TargetName == nil {
			break
		}

		return e.complexity.VersionTarget.TargetName(childComplexity), true

	case "VersionTarget.VersionID":
		if e.complexity.VersionTarget.VersionID == nil {
			break
		}

		return e.complexity.VersionTarget.VersionID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCompatibilityInfoInput,
		ec.unmarshalInputCompatibilityInput,
		ec.unmarshalInputModVersionConstraint,
		ec.unmarshalInputNewAnnouncement,
		ec.unmarshalInputNewGuide,
		ec.unmarshalInputNewMod,
		ec.unmarshalInputNewSMLVersion,
		ec.unmarshalInputNewSMLVersionTarget,
		ec.unmarshalInputNewVersion,
		ec.unmarshalInputTagFilter,
		ec.unmarshalInputUpdateAnnouncement,
		ec.unmarshalInputUpdateGuide,
		ec.unmarshalInputUpdateMod,
		ec.unmarshalInputUpdateSMLVersion,
		ec.unmarshalInputUpdateSMLVersionTarget,
		ec.unmarshalInputUpdateUser,
		ec.unmarshalInputUpdateUserMod,
		ec.unmarshalInputUpdateVersion,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/announcements.graphql", Input: `### Types

scalar AnnouncementID

enum AnnouncementImportance {
    Fix
    Info
    Warning
    Alert
}

type Announcement {
    id: AnnouncementID!
    message: String!
    importance: AnnouncementImportance!
}

### Inputs

input NewAnnouncement {
    message: String!
    importance: AnnouncementImportance!
}

input UpdateAnnouncement {
    message: String
    importance: AnnouncementImportance
}

### Queries

extend type Query {
    getAnnouncement(announcementId: AnnouncementID!): Announcement
    getAnnouncements: [Announcement!]!
    getAnnouncementsByImportance(importance: AnnouncementImportance!): [Announcement!]!
}

### Mutations

extend type Mutation {
    createAnnouncement(announcement: NewAnnouncement!): Announcement @canEditAnnouncements @isLoggedIn
    updateAnnouncement(announcementId: AnnouncementID!, announcement: UpdateAnnouncement!): Announcement! @canEditAnnouncements @isLoggedIn
    deleteAnnouncement(announcementId: AnnouncementID!): Boolean! @canEditAnnouncements @isLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/base.graphql", Input: `scalar Upload

scalar Date

enum Order {
    asc
    desc
}

type OAuthOptions {
    github: String!
    google: String!
    facebook: String!
}

type Query {
    getOAuthOptions(callback_url: String!): OAuthOptions!
}

type Mutation {
    discourseSSO(sso: String!, sig: String!): String @isLoggedIn
}
`, BuiltIn: false},
	{Name: "../schemas/compatibility.graphql", Input: `enum CompatibilityState {
    Works
    Damaged
    Broken
}

type Compatibility {
    state: CompatibilityState!
    note: String
}

input CompatibilityInput {
    state: CompatibilityState!
    note: String
}

type CompatibilityInfo {
    EA: Compatibility!
    EXP: Compatibility!
}

input CompatibilityInfoInput {
    EA: CompatibilityInput!
    EXP: CompatibilityInput!
}

extend type Mutation {
    updateModCompatibility(modId: ModID!, compatibility: CompatibilityInfoInput!): Boolean! @canEditModCompatibility(field: "modId") @isLoggedIn
    updateMultipleModCompatibilities(modIDs: [ModID!]!, compatibility: CompatibilityInfoInput!): Boolean! @canEditModCompatibility @isLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/directives.graphql", Input: `directive @isLoggedIn on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @isNotLoggedIn on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @canEditMod(field: String!) on FIELD_DEFINITION
directive @canEditVersion(field: String!) on FIELD_DEFINITION
directive @canEditUser(field: String!, object: Boolean!) on FIELD_DEFINITION
directive @canEditGuide(field: String!) on FIELD_DEFINITION
directive @canEditModCompatibility(field: String) on FIELD_DEFINITION

directive @canApproveMods on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @canApproveVersions on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @canEditUsers on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @canEditSMLVersions on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @canEditBootstrapVersions on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @canEditAnnouncements on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @canManageTags on FIELD_DEFINITION | INPUT_FIELD_DEFINITION`, BuiltIn: false},
	{Name: "../schemas/guide.graphql", Input: `### Types

scalar GuideID

enum GuideFields {
    name
    created_at
    updated_at
    views
}

type Guide {
    id: GuideID!
    name: String!
    short_description: String!
    guide: String!
    views: Int!
    user_id: UserID!
    updated_at: Date!
    created_at: Date!
    tags: [Tag!]!

    user: User!
}

type GetGuides {
    guides: [Guide!]!
    count: Int!
}

### Inputs

input NewGuide {
    name: String!
    short_description: String!
    guide: String!
    tagIDs: [TagID!]
}

input UpdateGuide {
    name: String
    short_description: String
    guide: String
    tagIDs: [TagID!]
}

input GuideFilter {
    limit: Int
    offset: Int
    order_by: GuideFields
    order: Order
    search: String
    ids: [String!]
    tagIDs: [TagID!]
}

### Queries

extend type Query {
    getGuide(guideId: GuideID!): Guide
    getGuides(filter: GuideFilter): GetGuides!
}

### Mutations

extend type Mutation {
    createGuide(guide: NewGuide!): Guide @isLoggedIn
    updateGuide(guideId: GuideID!, guide: UpdateGuide!): Guide! @canEditGuide(field: "guideId") @isLoggedIn
    deleteGuide(guideId: GuideID!): Boolean! @canEditGuide(field: "guideId") @isLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/mod.graphql", Input: `### Types

scalar ModID
scalar ModReference

enum ModFields {
    created_at
    updated_at
    name
    views
    downloads
    hotness
    popularity
    last_version_date
    search
}

type Mod {
    id: ModID!
    name: String!
    short_description: String!
    full_description: String
    logo: String
    source_url: String
    creator_id: UserID!
    approved: Boolean!
    views: Int!
    downloads: Int!
    hotness: Int!
    popularity: Int!
    updated_at: Date!
    created_at: Date!
    last_version_date: Date
    mod_reference: ModReference!
    hidden: Boolean!
    tags: [Tag!]
    compatibility: CompatibilityInfo

    authors: [UserMod!]!
    version(version: String!): Version
    versions(filter: VersionFilter): [Version!]!
    latestVersions: LatestVersions!
}

type GetMods {
    mods: [Mod!]!
    count: Int!
}

type GetMyMods {
    mods: [Mod!]!
    count: Int!
}

type ModVersion {
    id: ModID!
    mod_reference: ModReference!
    versions: [Version!]!
}

### Inputs

input ModFilter {
    limit: Int
    offset: Int
    order_by: ModFields
    order: Order
    search: String
    ids: [String!]
    references: [String!]
    hidden: Boolean
    tagIDs: [TagID!]
}

input NewMod {
    name: String!
    short_description: String!
    full_description: String
    logo: Upload
    source_url: String
    mod_reference: ModReference!
    hidden: Boolean
    tagIDs: [TagID!]
}

input UpdateMod {
    name: String
    short_description: String
    full_description: String
    logo: Upload
    source_url: String
    mod_reference: ModReference
    authors: [UpdateUserMod!]
    hidden: Boolean
    tagIDs: [TagID!]
    compatibility: CompatibilityInfoInput
}

input UpdateUserMod {
    user_id: UserID!
    role: String!
}

input ModVersionConstraint {
    modIdOrReference: String!
    version: String!
}

### Queries

extend type Query {
    getMod(modId: ModID!): Mod
    getModByReference(modReference: ModReference!): Mod
    getModByIdOrReference(modIdOrReference: String!): Mod
    getMods(filter: ModFilter): GetMods!
    getUnapprovedMods(filter: ModFilter): GetMods! @canApproveMods @isLoggedIn

    getMyMods(filter: ModFilter): GetMyMods! @isLoggedIn
    getMyUnapprovedMods(filter: ModFilter): GetMyMods! @isLoggedIn

    resolveModVersions(filter: [ModVersionConstraint!]!): [ModVersion!]!
}

### Mutations

extend type Mutation {
    createMod(mod: NewMod!): Mod @isLoggedIn
    updateMod(modId: ModID!, mod: UpdateMod!): Mod! @canEditMod(field: "modId") @isLoggedIn
    deleteMod(modId: ModID!): Boolean! @canEditMod(field: "modId") @isLoggedIn

    approveMod(modId: ModID!): Boolean! @canApproveMods @isLoggedIn
    denyMod(modId: ModID!): Boolean! @canApproveMods @isLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/sml_version.graphql", Input: `### Types

scalar SMLVersionID

type SMLVersion {
    id: SMLVersionID!
    version: String!
    satisfactory_version: Int!
    stability: VersionStabilities!
    link: String!
    targets: [SMLVersionTarget]!
    changelog: String!
    date: Date!
    bootstrap_version: String
    engine_version: String!

    updated_at: Date!
    created_at: Date!
}

type SMLVersionTarget {
    VersionID: SMLVersionID!
    targetName: TargetName!
    link: String!
}

type GetSMLVersions {
    sml_versions: [SMLVersion!]!
    count: Int!
}

enum SMLVersionFields {
    name
    created_at
    updated_at
    satisfactory_version
    date
}

### Inputs

input NewSMLVersion {
    version: String!
    satisfactory_version: Int!
    stability: VersionStabilities!
    link: String!
    targets: [NewSMLVersionTarget!]!
    changelog: String!
    date: Date!
    bootstrap_version: String
    engine_version: String!
}

input UpdateSMLVersion {
    version: String
    satisfactory_version: Int
    stability: VersionStabilities
    link: String
    targets: [UpdateSMLVersionTarget]!
    changelog: String
    date: Date
    bootstrap_version: String
    engine_version: String
}

input NewSMLVersionTarget {
    targetName: TargetName!
    link: String!
}

input UpdateSMLVersionTarget {
    targetName: TargetName!
    link: String!
}

input SMLVersionFilter {
    limit: Int
    offset: Int
    order_by: SMLVersionFields
    order: Order
    search: String
    ids: [String!]
}

### Queries

extend type Query {
    getSMLVersion(smlVersionID: SMLVersionID!): SMLVersion
    getSMLVersions(filter: SMLVersionFilter): GetSMLVersions!
}

### Mutations

extend type Mutation {
    createSMLVersion(smlVersion: NewSMLVersion!): SMLVersion @isLoggedIn
    updateSMLVersion(smlVersionId: SMLVersionID!, smlVersion: UpdateSMLVersion!): SMLVersion! @canEditSMLVersions @isLoggedIn
    deleteSMLVersion(smlVersionId: SMLVersionID!): Boolean! @canEditSMLVersions @isLoggedIn
}
`, BuiltIn: false},
	{Name: "../schemas/tags.graphql", Input: `scalar TagID
scalar TagName

type Tag {
    id: TagID!
    name: TagName!
}

input TagFilter {
    limit: Int
    offset: Int
    order: Order
    search: String
    ids: [TagID!]
}

extend type Query {
    getTag(tagID: TagID!): Tag
    getTags(filter: TagFilter): [Tag!]!
}

### Mutations

extend type Mutation {
    createTag(tagName: TagName!): Tag @isLoggedIn
    createMultipleTags(tagNames: [TagName!]!): [Tag!]! @canManageTags @isLoggedIn
    updateTag(tagID: TagID!, NewName: TagName!): Tag! @canManageTags @isLoggedIn
    deleteTag(tagID: TagID!): Boolean! @canManageTags @isLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/user.graphql", Input: `### Types

scalar UserID

type UserRoles {
    approveMods: Boolean!
    approveVersions: Boolean!
    deleteContent: Boolean!
    editContent: Boolean!
    editUsers: Boolean!
    editSMLVersions: Boolean!
    editBootstrapVersions: Boolean!
    editAnyModCompatibility: Boolean!
}

type Group {
    id: String!
    name: String!
}

type User {
    id: UserID!
    email: String @canEditUser(field: "ID", object: true) @isLoggedIn
    username: String!
    avatar: String
    created_at: Date!

    github_id: String @canEditUser(field: "ID", object: true) @isLoggedIn
    google_id: String @canEditUser(field: "ID", object: true) @isLoggedIn
    facebook_id: String @canEditUser(field: "ID", object: true) @isLoggedIn

    roles: UserRoles! @canEditUser(field: "ID", object: true) @isLoggedIn
    groups: [Group!]! @canEditUser(field: "ID", object: true) @isLoggedIn

    mods: [UserMod!]!
    guides: [Guide!]!
}

type UserSession {
    token: String!
}

type UserMod {
    user_id: UserID!
    mod_id: ModID!
    role: String!

    user: User!
    mod: Mod!
}

### Inputs

input UpdateUser {
    avatar: Upload
    groups: [String!] @canEditUsers @isLoggedIn
    username: String
}

### Queries

extend type Query {
    getMe: User @isLoggedIn
    getUser(userId: UserID!): User
    getUsers(userIds: [UserID!]!): [User]!
}

### Mutations

extend type Mutation {
    updateUser(userId: UserID!, input: UpdateUser!): User! @canEditUser(field: "userId", object: false) @isLoggedIn
    logout: Boolean! @isLoggedIn

    oAuthGithub(code: String!, state: String!): UserSession @isNotLoggedIn
    oAuthGoogle(code: String!, state: String!): UserSession @isNotLoggedIn
    oAuthFacebook(code: String!, state: String!): UserSession @isNotLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/version.graphql", Input: `### Types

scalar VersionID

type LatestVersions {
    alpha: Version
    beta: Version
    release: Version
}

enum VersionFields {
    created_at
    updated_at
    downloads
}

enum VersionStabilities {
    alpha
    beta
    release
}

type Version {
    id: VersionID!
    mod_id: ModID!
    version: String!
    sml_version: String!
    changelog: String!
    downloads: Int!
    stability: VersionStabilities!
    approved: Boolean!
    updated_at: Date!
    created_at: Date!
    link: String!
    targets: [VersionTarget]!
    metadata: String
    size: Int
    hash: String

    mod: Mod!
    dependencies: [VersionDependency!]!
}

type VersionTarget {
    VersionID: VersionID!
    targetName: TargetName!
    link: String!
    size: Int
    hash: String
}

type CreateVersionResponse {
    auto_approved: Boolean!
    version: Version
}

type GetVersions {
    versions: [Version!]!
    count: Int!
}

type GetMyVersions {
    versions: [Version!]!
    count: Int!
}

type VersionDependency {
    version_id: VersionID!
    mod_id: ModID!
    condition: String!
    optional: Boolean!

    mod: Mod
    version: Version
}

### Inputs

input VersionFilter {
    limit: Int
    offset: Int
    order_by: VersionFields
    order: Order
    search: String
    ids: [String!]
}

input NewVersion {
    changelog: String!
    stability: VersionStabilities!
}

input UpdateVersion {
    changelog: String
    stability: VersionStabilities
}

### Queries

extend type Query {
    getVersion(versionId: VersionID!): Version
    getVersions(filter: VersionFilter): GetVersions!
    getUnapprovedVersions(filter: VersionFilter): GetVersions! @canApproveVersions @isLoggedIn

    checkVersionUploadState(modId: ModID!, versionId: VersionID!): CreateVersionResponse @canEditMod(field: "modId") @isLoggedIn

    getMyVersions(filter: VersionFilter): GetMyVersions! @isLoggedIn
    getMyUnapprovedVersions(filter: VersionFilter): GetMyVersions! @isLoggedIn
}

### Mutations

extend type Mutation {
    createVersion(modId: ModID!): VersionID! @canEditMod(field: "modId") @isLoggedIn
    uploadVersionPart(modId: ModID!, versionId: VersionID!, part: Int!, file: Upload!): Boolean! @canEditMod(field: "modId") @isLoggedIn
    finalizeCreateVersion(modId: ModID!, versionId: VersionID!, version: NewVersion!): Boolean! @canEditMod(field: "modId") @isLoggedIn

    updateVersion(versionId: VersionID!, version: UpdateVersion!): Version! @canEditVersion(field: "versionId") @isLoggedIn
    deleteVersion(versionId: VersionID!): Boolean! @canEditVersion(field: "versionId") @isLoggedIn

    approveVersion(versionId: VersionID!): Boolean! @canApproveVersions @isLoggedIn
    denyVersion(versionId: VersionID!): Boolean! @canApproveVersions @isLoggedIn
}`, BuiltIn: false},
	{Name: "../schemas/version_target.graphql", Input: `enum TargetName {
    Windows,
    WindowsServer,
    LinuxServer
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_canEditGuide_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["field"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["field"] = arg0
	return args, nil
}

func (ec *executionContext) dir_canEditModCompatibility_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["field"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["field"] = arg0
	return args, nil
}

func (ec *executionContext) dir_canEditMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["field"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["field"] = arg0
	return args, nil
}

func (ec *executionContext) dir_canEditUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["field"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["field"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["object"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("object"))
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["object"] = arg1
	return args, nil
}

func (ec *executionContext) dir_canEditVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["field"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["field"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mod_version_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["version"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["version"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mod_versions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOVersionFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_approveMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_approveVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg0, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createAnnouncement_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 NewAnnouncement
	if tmp, ok := rawArgs["announcement"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("announcement"))
		arg0, err = ec.unmarshalNNewAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedNewAnnouncement(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["announcement"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createGuide_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 NewGuide
	if tmp, ok := rawArgs["guide"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guide"))
		arg0, err = ec.unmarshalNNewGuide2githubcomsatisfactorymoddingsmrapigeneratedNewGuide(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guide"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 NewMod
	if tmp, ok := rawArgs["mod"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mod"))
		arg0, err = ec.unmarshalNNewMod2githubcomsatisfactorymoddingsmrapigeneratedNewMod(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mod"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createMultipleTags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["tagNames"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagNames"))
		arg0, err = ec.unmarshalNTagName2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tagNames"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSMLVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 NewSMLVersion
	if tmp, ok := rawArgs["smlVersion"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("smlVersion"))
		arg0, err = ec.unmarshalNNewSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedNewSMLVersion(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["smlVersion"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tagName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagName"))
		arg0, err = ec.unmarshalNTagName2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tagName"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteAnnouncement_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["announcementId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("announcementId"))
		arg0, err = ec.unmarshalNAnnouncementID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["announcementId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteGuide_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["guideId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guideId"))
		arg0, err = ec.unmarshalNGuideID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guideId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSMLVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["smlVersionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("smlVersionId"))
		arg0, err = ec.unmarshalNSMLVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["smlVersionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tagID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
		arg0, err = ec.unmarshalNTagID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tagID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg0, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_denyMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_denyVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg0, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_discourseSSO_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["sso"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sso"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sso"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["sig"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sig"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sig"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_finalizeCreateVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg1, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg1
	var arg2 NewVersion
	if tmp, ok := rawArgs["version"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
		arg2, err = ec.unmarshalNNewVersion2githubcomsatisfactorymoddingsmrapigeneratedNewVersion(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["version"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_oAuthFacebook_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["state"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["state"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_oAuthGithub_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["state"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["state"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_oAuthGoogle_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["code"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["code"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["state"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["state"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateAnnouncement_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["announcementId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("announcementId"))
		arg0, err = ec.unmarshalNAnnouncementID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["announcementId"] = arg0
	var arg1 UpdateAnnouncement
	if tmp, ok := rawArgs["announcement"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("announcement"))
		arg1, err = ec.unmarshalNUpdateAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedUpdateAnnouncement(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["announcement"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateGuide_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["guideId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guideId"))
		arg0, err = ec.unmarshalNGuideID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guideId"] = arg0
	var arg1 UpdateGuide
	if tmp, ok := rawArgs["guide"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guide"))
		arg1, err = ec.unmarshalNUpdateGuide2githubcomsatisfactorymoddingsmrapigeneratedUpdateGuide(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guide"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateModCompatibility_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	var arg1 CompatibilityInfoInput
	if tmp, ok := rawArgs["compatibility"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compatibility"))
		arg1, err = ec.unmarshalNCompatibilityInfoInput2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityInfoInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["compatibility"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	var arg1 UpdateMod
	if tmp, ok := rawArgs["mod"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mod"))
		arg1, err = ec.unmarshalNUpdateMod2githubcomsatisfactorymoddingsmrapigeneratedUpdateMod(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mod"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMultipleModCompatibilities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["modIDs"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modIDs"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modIDs"] = arg0
	var arg1 CompatibilityInfoInput
	if tmp, ok := rawArgs["compatibility"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compatibility"))
		arg1, err = ec.unmarshalNCompatibilityInfoInput2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityInfoInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["compatibility"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSMLVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["smlVersionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("smlVersionId"))
		arg0, err = ec.unmarshalNSMLVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["smlVersionId"] = arg0
	var arg1 UpdateSMLVersion
	if tmp, ok := rawArgs["smlVersion"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("smlVersion"))
		arg1, err = ec.unmarshalNUpdateSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedUpdateSMLVersion(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["smlVersion"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tagID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
		arg0, err = ec.unmarshalNTagID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tagID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["NewName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("NewName"))
		arg1, err = ec.unmarshalNTagName2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["NewName"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNUserID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 UpdateUser
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateUser2githubcomsatisfactorymoddingsmrapigeneratedUpdateUser(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg0, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg0
	var arg1 UpdateVersion
	if tmp, ok := rawArgs["version"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
		arg1, err = ec.unmarshalNUpdateVersion2githubcomsatisfactorymoddingsmrapigeneratedUpdateVersion(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["version"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_uploadVersionPart_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg1, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["part"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("part"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["part"] = arg2
	var arg3 graphql.Upload
	if tmp, ok := rawArgs["file"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file"))
		arg3, err = ec.unmarshalNUpload2githubcom99designsgqlgengraphqlUpload(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["file"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_checkVersionUploadState_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg1, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getAnnouncement_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["announcementId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("announcementId"))
		arg0, err = ec.unmarshalNAnnouncementID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["announcementId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getAnnouncementsByImportance_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 AnnouncementImportance
	if tmp, ok := rawArgs["importance"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("importance"))
		arg0, err = ec.unmarshalNAnnouncementImportance2githubcomsatisfactorymoddingsmrapigeneratedAnnouncementImportance(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["importance"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getGuide_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["guideId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guideId"))
		arg0, err = ec.unmarshalNGuideID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["guideId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getGuides_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOGuideFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getModByIdOrReference_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modIdOrReference"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modIdOrReference"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modIdOrReference"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getModByReference_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modReference"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modReference"))
		arg0, err = ec.unmarshalNModReference2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modReference"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["modId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modId"))
		arg0, err = ec.unmarshalNModID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["modId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMods_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOModFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMyMods_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOModFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMyUnapprovedMods_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOModFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMyUnapprovedVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOVersionFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getMyVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOVersionFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getOAuthOptions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["callback_url"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("callback_url"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["callback_url"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getSMLVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["smlVersionID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("smlVersionID"))
		arg0, err = ec.unmarshalNSMLVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["smlVersionID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getSMLVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOSMLVersionFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tagID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
		arg0, err = ec.unmarshalNTagID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tagID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getTags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *TagFilter
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOTagFilter2githubcomsatisfactorymoddingsmrapigeneratedTagFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUnapprovedMods_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOModFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUnapprovedVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOVersionFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNUserID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["userIds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIds"))
		arg0, err = ec.unmarshalNUserID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg0, err = ec.unmarshalNVersionID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOVersionFilter2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_resolveModVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*ModVersionConstraint
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalNModVersionConstraint2githubcomsatisfactorymoddingsmrapigeneratedModVersionConstraint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Announcement_id(ctx context.Context, field graphql.CollectedField, obj *Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAnnouncementID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AnnouncementID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_message(ctx context.Context, field graphql.CollectedField, obj *Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_importance(ctx context.Context, field graphql.CollectedField, obj *Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_importance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Importance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AnnouncementImportance)
	fc.Result = res
	return ec.marshalNAnnouncementImportance2githubcomsatisfactorymoddingsmrapigeneratedAnnouncementImportance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_importance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AnnouncementImportance does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Compatibility_state(ctx context.Context, field graphql.CollectedField, obj *Compatibility) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Compatibility_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(CompatibilityState)
	fc.Result = res
	return ec.marshalNCompatibilityState2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Compatibility_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Compatibility",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CompatibilityState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Compatibility_note(ctx context.Context, field graphql.CollectedField, obj *Compatibility) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Compatibility_note(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Compatibility_note(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Compatibility",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompatibilityInfo_EA(ctx context.Context, field graphql.CollectedField, obj *CompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompatibilityInfo_EA(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ea, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Compatibility)
	fc.Result = res
	return ec.marshalNCompatibility2githubcomsatisfactorymoddingsmrapigeneratedCompatibility(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompatibilityInfo_EA(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_Compatibility_state(ctx, field)
			case "note":
				return ec.fieldContext_Compatibility_note(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Compatibility", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CompatibilityInfo_EXP(ctx context.Context, field graphql.CollectedField, obj *CompatibilityInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CompatibilityInfo_EXP(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Compatibility)
	fc.Result = res
	return ec.marshalNCompatibility2githubcomsatisfactorymoddingsmrapigeneratedCompatibility(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CompatibilityInfo_EXP(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CompatibilityInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_Compatibility_state(ctx, field)
			case "note":
				return ec.fieldContext_Compatibility_note(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Compatibility", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateVersionResponse_auto_approved(ctx context.Context, field graphql.CollectedField, obj *CreateVersionResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateVersionResponse_auto_approved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AutoApproved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateVersionResponse_auto_approved(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateVersionResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateVersionResponse_version(ctx context.Context, field graphql.CollectedField, obj *CreateVersionResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateVersionResponse_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateVersionResponse_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateVersionResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetGuides_guides(ctx context.Context, field graphql.CollectedField, obj *GetGuides) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetGuides_guides(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetGuides().Guides(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Guide)
	fc.Result = res
	return ec.marshalNGuide2githubcomsatisfactorymoddingsmrapigeneratedGuide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetGuides_guides(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetGuides",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Guide_id(ctx, field)
			case "name":
				return ec.fieldContext_Guide_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Guide_short_description(ctx, field)
			case "guide":
				return ec.fieldContext_Guide_guide(ctx, field)
			case "views":
				return ec.fieldContext_Guide_views(ctx, field)
			case "user_id":
				return ec.fieldContext_Guide_user_id(ctx, field)
			case "updated_at":
				return ec.fieldContext_Guide_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Guide_created_at(ctx, field)
			case "tags":
				return ec.fieldContext_Guide_tags(ctx, field)
			case "user":
				return ec.fieldContext_Guide_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Guide", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetGuides_count(ctx context.Context, field graphql.CollectedField, obj *GetGuides) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetGuides_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetGuides().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetGuides_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetGuides",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMods_mods(ctx context.Context, field graphql.CollectedField, obj *GetMods) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMods_mods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetMods().Mods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Mod)
	fc.Result = res
	return ec.marshalNMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMods_mods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMods",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMods_count(ctx context.Context, field graphql.CollectedField, obj *GetMods) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMods_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetMods().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMods_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMods",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMyMods_mods(ctx context.Context, field graphql.CollectedField, obj *GetMyMods) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMyMods_mods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetMyMods().Mods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Mod)
	fc.Result = res
	return ec.marshalNMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMyMods_mods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMyMods",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMyMods_count(ctx context.Context, field graphql.CollectedField, obj *GetMyMods) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMyMods_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetMyMods().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMyMods_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMyMods",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMyVersions_versions(ctx context.Context, field graphql.CollectedField, obj *GetMyVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMyVersions_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetMyVersions().Versions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Version)
	fc.Result = res
	return ec.marshalNVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMyVersions_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMyVersions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetMyVersions_count(ctx context.Context, field graphql.CollectedField, obj *GetMyVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetMyVersions_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetMyVersions().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetMyVersions_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetMyVersions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetSMLVersions_sml_versions(ctx context.Context, field graphql.CollectedField, obj *GetSMLVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetSMLVersions_sml_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetSMLVersions().SmlVersions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*SMLVersion)
	fc.Result = res
	return ec.marshalNSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedSMLVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetSMLVersions_sml_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetSMLVersions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SMLVersion_id(ctx, field)
			case "version":
				return ec.fieldContext_SMLVersion_version(ctx, field)
			case "satisfactory_version":
				return ec.fieldContext_SMLVersion_satisfactory_version(ctx, field)
			case "stability":
				return ec.fieldContext_SMLVersion_stability(ctx, field)
			case "link":
				return ec.fieldContext_SMLVersion_link(ctx, field)
			case "targets":
				return ec.fieldContext_SMLVersion_targets(ctx, field)
			case "changelog":
				return ec.fieldContext_SMLVersion_changelog(ctx, field)
			case "date":
				return ec.fieldContext_SMLVersion_date(ctx, field)
			case "bootstrap_version":
				return ec.fieldContext_SMLVersion_bootstrap_version(ctx, field)
			case "engine_version":
				return ec.fieldContext_SMLVersion_engine_version(ctx, field)
			case "updated_at":
				return ec.fieldContext_SMLVersion_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_SMLVersion_created_at(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMLVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetSMLVersions_count(ctx context.Context, field graphql.CollectedField, obj *GetSMLVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetSMLVersions_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetSMLVersions().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetSMLVersions_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetSMLVersions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetVersions_versions(ctx context.Context, field graphql.CollectedField, obj *GetVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetVersions_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetVersions().Versions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Version)
	fc.Result = res
	return ec.marshalNVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetVersions_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetVersions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GetVersions_count(ctx context.Context, field graphql.CollectedField, obj *GetVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GetVersions_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GetVersions().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GetVersions_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GetVersions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_id(ctx context.Context, field graphql.CollectedField, obj *Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_name(ctx context.Context, field graphql.CollectedField, obj *Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_id(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNGuideID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GuideID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_name(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_short_description(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_short_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_short_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_guide(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_guide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Guide, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_guide(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_views(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_views(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Views, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_views(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_user_id(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_user_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNUserID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_user_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_updated_at(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_created_at(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_tags(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalNTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Guide_user(ctx context.Context, field graphql.CollectedField, obj *Guide) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Guide_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Guide().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalNUser2githubcomsatisfactorymoddingsmrapigeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Guide_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Guide",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatar":
				return ec.fieldContext_User_avatar(ctx, field)
			case "created_at":
				return ec.fieldContext_User_created_at(ctx, field)
			case "github_id":
				return ec.fieldContext_User_github_id(ctx, field)
			case "google_id":
				return ec.fieldContext_User_google_id(ctx, field)
			case "facebook_id":
				return ec.fieldContext_User_facebook_id(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "mods":
				return ec.fieldContext_User_mods(ctx, field)
			case "guides":
				return ec.fieldContext_User_guides(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LatestVersions_alpha(ctx context.Context, field graphql.CollectedField, obj *LatestVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LatestVersions_alpha(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alpha, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LatestVersions_alpha(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LatestVersions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LatestVersions_beta(ctx context.Context, field graphql.CollectedField, obj *LatestVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LatestVersions_beta(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Beta, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LatestVersions_beta(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LatestVersions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LatestVersions_release(ctx context.Context, field graphql.CollectedField, obj *LatestVersions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LatestVersions_release(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Release, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LatestVersions_release(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LatestVersions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_id(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_name(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_short_description(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_short_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_short_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_full_description(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_full_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FullDescription, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_full_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_logo(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_logo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_logo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_source_url(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_source_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_source_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_creator_id(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_creator_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatorID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNUserID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_creator_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_approved(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_approved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Approved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_approved(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_views(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_views(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Views, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_views(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_downloads(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_downloads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Downloads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_downloads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_hotness(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_hotness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_hotness(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_popularity(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_popularity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Popularity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_popularity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_updated_at(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_created_at(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_last_version_date(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_last_version_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastVersionDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_last_version_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_mod_reference(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_mod_reference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModReference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModReference2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_mod_reference(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModReference does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_hidden(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_hidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hidden, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_hidden(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_tags(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_compatibility(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_compatibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Compatibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CompatibilityInfo)
	fc.Result = res
	return ec.marshalOCompatibilityInfo2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_compatibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "EA":
				return ec.fieldContext_CompatibilityInfo_EA(ctx, field)
			case "EXP":
				return ec.fieldContext_CompatibilityInfo_EXP(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CompatibilityInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_authors(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_authors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mod().Authors(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*UserMod)
	fc.Result = res
	return ec.marshalNUserMod2githubcomsatisfactorymoddingsmrapigeneratedUserMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_authors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user_id":
				return ec.fieldContext_UserMod_user_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_UserMod_mod_id(ctx, field)
			case "role":
				return ec.fieldContext_UserMod_role(ctx, field)
			case "user":
				return ec.fieldContext_UserMod_user(ctx, field)
			case "mod":
				return ec.fieldContext_UserMod_mod(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserMod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mod_version(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mod().Version(rctx, obj, fc.Args["version"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mod_version_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mod_versions(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mod().Versions(rctx, obj, fc.Args["filter"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Version)
	fc.Result = res
	return ec.marshalNVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mod_versions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mod_latestVersions(ctx context.Context, field graphql.CollectedField, obj *Mod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mod_latestVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mod().LatestVersions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*LatestVersions)
	fc.Result = res
	return ec.marshalNLatestVersions2githubcomsatisfactorymoddingsmrapigeneratedLatestVersions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mod_latestVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alpha":
				return ec.fieldContext_LatestVersions_alpha(ctx, field)
			case "beta":
				return ec.fieldContext_LatestVersions_beta(ctx, field)
			case "release":
				return ec.fieldContext_LatestVersions_release(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LatestVersions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModVersion_id(ctx context.Context, field graphql.CollectedField, obj *ModVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModVersion_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModVersion_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModVersion_mod_reference(ctx context.Context, field graphql.CollectedField, obj *ModVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModVersion_mod_reference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModReference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModReference2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModVersion_mod_reference(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModReference does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModVersion_versions(ctx context.Context, field graphql.CollectedField, obj *ModVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModVersion_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Version)
	fc.Result = res
	return ec.marshalNVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModVersion_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_discourseSSO(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_discourseSSO(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DiscourseSso(rctx, fc.Args["sso"].(string), fc.Args["sig"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_discourseSSO(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_discourseSSO_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateAnnouncement(rctx, fc.Args["announcement"].(NewAnnouncement))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditAnnouncements == nil {
				return nil, errors.New("directive canEditAnnouncements is not implemented")
			}
			return ec.directives.CanEditAnnouncements(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Announcement); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Announcement`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Announcement)
	fc.Result = res
	return ec.marshalOAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "message":
				return ec.fieldContext_Announcement_message(ctx, field)
			case "importance":
				return ec.fieldContext_Announcement_importance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateAnnouncement(rctx, fc.Args["announcementId"].(string), fc.Args["announcement"].(UpdateAnnouncement))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditAnnouncements == nil {
				return nil, errors.New("directive canEditAnnouncements is not implemented")
			}
			return ec.directives.CanEditAnnouncements(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Announcement); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Announcement`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "message":
				return ec.fieldContext_Announcement_message(ctx, field)
			case "importance":
				return ec.fieldContext_Announcement_importance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteAnnouncement(rctx, fc.Args["announcementId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditAnnouncements == nil {
				return nil, errors.New("directive canEditAnnouncements is not implemented")
			}
			return ec.directives.CanEditAnnouncements(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateModCompatibility(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateModCompatibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateModCompatibility(rctx, fc.Args["modId"].(string), fc.Args["compatibility"].(CompatibilityInfoInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalOString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditModCompatibility == nil {
				return nil, errors.New("directive canEditModCompatibility is not implemented")
			}
			return ec.directives.CanEditModCompatibility(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateModCompatibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateModCompatibility_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMultipleModCompatibilities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMultipleModCompatibilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMultipleModCompatibilities(rctx, fc.Args["modIDs"].([]string), fc.Args["compatibility"].(CompatibilityInfoInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditModCompatibility == nil {
				return nil, errors.New("directive canEditModCompatibility is not implemented")
			}
			return ec.directives.CanEditModCompatibility(ctx, nil, directive0, nil)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMultipleModCompatibilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMultipleModCompatibilities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createGuide(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createGuide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateGuide(rctx, fc.Args["guide"].(NewGuide))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Guide); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Guide`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Guide)
	fc.Result = res
	return ec.marshalOGuide2githubcomsatisfactorymoddingsmrapigeneratedGuide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createGuide(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Guide_id(ctx, field)
			case "name":
				return ec.fieldContext_Guide_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Guide_short_description(ctx, field)
			case "guide":
				return ec.fieldContext_Guide_guide(ctx, field)
			case "views":
				return ec.fieldContext_Guide_views(ctx, field)
			case "user_id":
				return ec.fieldContext_Guide_user_id(ctx, field)
			case "updated_at":
				return ec.fieldContext_Guide_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Guide_created_at(ctx, field)
			case "tags":
				return ec.fieldContext_Guide_tags(ctx, field)
			case "user":
				return ec.fieldContext_Guide_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Guide", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createGuide_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateGuide(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateGuide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateGuide(rctx, fc.Args["guideId"].(string), fc.Args["guide"].(UpdateGuide))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "guideId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditGuide == nil {
				return nil, errors.New("directive canEditGuide is not implemented")
			}
			return ec.directives.CanEditGuide(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Guide); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Guide`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Guide)
	fc.Result = res
	return ec.marshalNGuide2githubcomsatisfactorymoddingsmrapigeneratedGuide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateGuide(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Guide_id(ctx, field)
			case "name":
				return ec.fieldContext_Guide_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Guide_short_description(ctx, field)
			case "guide":
				return ec.fieldContext_Guide_guide(ctx, field)
			case "views":
				return ec.fieldContext_Guide_views(ctx, field)
			case "user_id":
				return ec.fieldContext_Guide_user_id(ctx, field)
			case "updated_at":
				return ec.fieldContext_Guide_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Guide_created_at(ctx, field)
			case "tags":
				return ec.fieldContext_Guide_tags(ctx, field)
			case "user":
				return ec.fieldContext_Guide_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Guide", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateGuide_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGuide(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGuide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteGuide(rctx, fc.Args["guideId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "guideId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditGuide == nil {
				return nil, errors.New("directive canEditGuide is not implemented")
			}
			return ec.directives.CanEditGuide(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGuide(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGuide_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateMod(rctx, fc.Args["mod"].(NewMod))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Mod); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Mod`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalOMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateMod(rctx, fc.Args["modId"].(string), fc.Args["mod"].(UpdateMod))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditMod == nil {
				return nil, errors.New("directive canEditMod is not implemented")
			}
			return ec.directives.CanEditMod(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Mod); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Mod`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalNMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteMod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteMod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteMod(rctx, fc.Args["modId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditMod == nil {
				return nil, errors.New("directive canEditMod is not implemented")
			}
			return ec.directives.CanEditMod(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteMod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteMod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_approveMod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_approveMod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ApproveMod(rctx, fc.Args["modId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanApproveMods == nil {
				return nil, errors.New("directive canApproveMods is not implemented")
			}
			return ec.directives.CanApproveMods(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_approveMod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_approveMod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_denyMod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_denyMod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DenyMod(rctx, fc.Args["modId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanApproveMods == nil {
				return nil, errors.New("directive canApproveMods is not implemented")
			}
			return ec.directives.CanApproveMods(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_denyMod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_denyMod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSMLVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSMLVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateSMLVersion(rctx, fc.Args["smlVersion"].(NewSMLVersion))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*SMLVersion); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.SMLVersion`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SMLVersion)
	fc.Result = res
	return ec.marshalOSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedSMLVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSMLVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SMLVersion_id(ctx, field)
			case "version":
				return ec.fieldContext_SMLVersion_version(ctx, field)
			case "satisfactory_version":
				return ec.fieldContext_SMLVersion_satisfactory_version(ctx, field)
			case "stability":
				return ec.fieldContext_SMLVersion_stability(ctx, field)
			case "link":
				return ec.fieldContext_SMLVersion_link(ctx, field)
			case "targets":
				return ec.fieldContext_SMLVersion_targets(ctx, field)
			case "changelog":
				return ec.fieldContext_SMLVersion_changelog(ctx, field)
			case "date":
				return ec.fieldContext_SMLVersion_date(ctx, field)
			case "bootstrap_version":
				return ec.fieldContext_SMLVersion_bootstrap_version(ctx, field)
			case "engine_version":
				return ec.fieldContext_SMLVersion_engine_version(ctx, field)
			case "updated_at":
				return ec.fieldContext_SMLVersion_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_SMLVersion_created_at(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMLVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSMLVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSMLVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSMLVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSMLVersion(rctx, fc.Args["smlVersionId"].(string), fc.Args["smlVersion"].(UpdateSMLVersion))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditSMLVersions == nil {
				return nil, errors.New("directive canEditSMLVersions is not implemented")
			}
			return ec.directives.CanEditSMLVersions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*SMLVersion); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.SMLVersion`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SMLVersion)
	fc.Result = res
	return ec.marshalNSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedSMLVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSMLVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SMLVersion_id(ctx, field)
			case "version":
				return ec.fieldContext_SMLVersion_version(ctx, field)
			case "satisfactory_version":
				return ec.fieldContext_SMLVersion_satisfactory_version(ctx, field)
			case "stability":
				return ec.fieldContext_SMLVersion_stability(ctx, field)
			case "link":
				return ec.fieldContext_SMLVersion_link(ctx, field)
			case "targets":
				return ec.fieldContext_SMLVersion_targets(ctx, field)
			case "changelog":
				return ec.fieldContext_SMLVersion_changelog(ctx, field)
			case "date":
				return ec.fieldContext_SMLVersion_date(ctx, field)
			case "bootstrap_version":
				return ec.fieldContext_SMLVersion_bootstrap_version(ctx, field)
			case "engine_version":
				return ec.fieldContext_SMLVersion_engine_version(ctx, field)
			case "updated_at":
				return ec.fieldContext_SMLVersion_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_SMLVersion_created_at(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMLVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSMLVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSMLVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSMLVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSMLVersion(rctx, fc.Args["smlVersionId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanEditSMLVersions == nil {
				return nil, errors.New("directive canEditSMLVersions is not implemented")
			}
			return ec.directives.CanEditSMLVersions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSMLVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSMLVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTag(rctx, fc.Args["tagName"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMultipleTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMultipleTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateMultipleTags(rctx, fc.Args["tagNames"].([]string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanManageTags == nil {
				return nil, errors.New("directive canManageTags is not implemented")
			}
			return ec.directives.CanManageTags(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/satisfactorymodding/smr-api/generated.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalNTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMultipleTags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMultipleTags_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTag(rctx, fc.Args["tagID"].(string), fc.Args["NewName"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanManageTags == nil {
				return nil, errors.New("directive canManageTags is not implemented")
			}
			return ec.directives.CanManageTags(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Tag)
	fc.Result = res
	return ec.marshalNTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTag(rctx, fc.Args["tagID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanManageTags == nil {
				return nil, errors.New("directive canManageTags is not implemented")
			}
			return ec.directives.CanManageTags(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateUser(rctx, fc.Args["userId"].(string), fc.Args["input"].(UpdateUser))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "userId")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, false)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, nil, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalNUser2githubcomsatisfactorymoddingsmrapigeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatar":
				return ec.fieldContext_User_avatar(ctx, field)
			case "created_at":
				return ec.fieldContext_User_created_at(ctx, field)
			case "github_id":
				return ec.fieldContext_User_github_id(ctx, field)
			case "google_id":
				return ec.fieldContext_User_google_id(ctx, field)
			case "facebook_id":
				return ec.fieldContext_User_facebook_id(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "mods":
				return ec.fieldContext_User_mods(ctx, field)
			case "guides":
				return ec.fieldContext_User_guides(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_logout(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_logout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Logout(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_logout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_oAuthGithub(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_oAuthGithub(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().OAuthGithub(rctx, fc.Args["code"].(string), fc.Args["state"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsNotLoggedIn == nil {
				return nil, errors.New("directive isNotLoggedIn is not implemented")
			}
			return ec.directives.IsNotLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*UserSession); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.UserSession`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserSession)
	fc.Result = res
	return ec.marshalOUserSession2githubcomsatisfactorymoddingsmrapigeneratedUserSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_oAuthGithub(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_UserSession_token(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSession", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_oAuthGithub_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_oAuthGoogle(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_oAuthGoogle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().OAuthGoogle(rctx, fc.Args["code"].(string), fc.Args["state"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsNotLoggedIn == nil {
				return nil, errors.New("directive isNotLoggedIn is not implemented")
			}
			return ec.directives.IsNotLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*UserSession); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.UserSession`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserSession)
	fc.Result = res
	return ec.marshalOUserSession2githubcomsatisfactorymoddingsmrapigeneratedUserSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_oAuthGoogle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_UserSession_token(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSession", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_oAuthGoogle_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_oAuthFacebook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_oAuthFacebook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().OAuthFacebook(rctx, fc.Args["code"].(string), fc.Args["state"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsNotLoggedIn == nil {
				return nil, errors.New("directive isNotLoggedIn is not implemented")
			}
			return ec.directives.IsNotLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*UserSession); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.UserSession`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserSession)
	fc.Result = res
	return ec.marshalOUserSession2githubcomsatisfactorymoddingsmrapigeneratedUserSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_oAuthFacebook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "token":
				return ec.fieldContext_UserSession_token(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSession", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_oAuthFacebook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateVersion(rctx, fc.Args["modId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditMod == nil {
				return nil, errors.New("directive canEditMod is not implemented")
			}
			return ec.directives.CanEditMod(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_uploadVersionPart(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_uploadVersionPart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UploadVersionPart(rctx, fc.Args["modId"].(string), fc.Args["versionId"].(string), fc.Args["part"].(int), fc.Args["file"].(graphql.Upload))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditMod == nil {
				return nil, errors.New("directive canEditMod is not implemented")
			}
			return ec.directives.CanEditMod(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_uploadVersionPart(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_uploadVersionPart_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_finalizeCreateVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_finalizeCreateVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FinalizeCreateVersion(rctx, fc.Args["modId"].(string), fc.Args["versionId"].(string), fc.Args["version"].(NewVersion))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditMod == nil {
				return nil, errors.New("directive canEditMod is not implemented")
			}
			return ec.directives.CanEditMod(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_finalizeCreateVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_finalizeCreateVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateVersion(rctx, fc.Args["versionId"].(string), fc.Args["version"].(UpdateVersion))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "versionId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditVersion == nil {
				return nil, errors.New("directive canEditVersion is not implemented")
			}
			return ec.directives.CanEditVersion(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Version); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.Version`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalNVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteVersion(rctx, fc.Args["versionId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "versionId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditVersion == nil {
				return nil, errors.New("directive canEditVersion is not implemented")
			}
			return ec.directives.CanEditVersion(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_approveVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_approveVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ApproveVersion(rctx, fc.Args["versionId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanApproveVersions == nil {
				return nil, errors.New("directive canApproveVersions is not implemented")
			}
			return ec.directives.CanApproveVersions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_approveVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_approveVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_denyVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_denyVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DenyVersion(rctx, fc.Args["versionId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanApproveVersions == nil {
				return nil, errors.New("directive canApproveVersions is not implemented")
			}
			return ec.directives.CanApproveVersions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_denyVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_denyVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _OAuthOptions_github(ctx context.Context, field graphql.CollectedField, obj *OAuthOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuthOptions_github(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Github, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuthOptions_github(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuthOptions_google(ctx context.Context, field graphql.CollectedField, obj *OAuthOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuthOptions_google(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Google, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuthOptions_google(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuthOptions_facebook(ctx context.Context, field graphql.CollectedField, obj *OAuthOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuthOptions_facebook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Facebook, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuthOptions_facebook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getOAuthOptions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getOAuthOptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetOAuthOptions(rctx, fc.Args["callback_url"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OAuthOptions)
	fc.Result = res
	return ec.marshalNOAuthOptions2githubcomsatisfactorymoddingsmrapigeneratedOAuthOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getOAuthOptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "github":
				return ec.fieldContext_OAuthOptions_github(ctx, field)
			case "google":
				return ec.fieldContext_OAuthOptions_google(ctx, field)
			case "facebook":
				return ec.fieldContext_OAuthOptions_facebook(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuthOptions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getOAuthOptions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAnnouncement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAnnouncement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetAnnouncement(rctx, fc.Args["announcementId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Announcement)
	fc.Result = res
	return ec.marshalOAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAnnouncement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "message":
				return ec.fieldContext_Announcement_message(ctx, field)
			case "importance":
				return ec.fieldContext_Announcement_importance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAnnouncement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAnnouncements(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAnnouncements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetAnnouncements(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAnnouncements(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "message":
				return ec.fieldContext_Announcement_message(ctx, field)
			case "importance":
				return ec.fieldContext_Announcement_importance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAnnouncementsByImportance(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAnnouncementsByImportance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetAnnouncementsByImportance(rctx, fc.Args["importance"].(AnnouncementImportance))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAnnouncementsByImportance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "message":
				return ec.fieldContext_Announcement_message(ctx, field)
			case "importance":
				return ec.fieldContext_Announcement_importance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAnnouncementsByImportance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getGuide(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getGuide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetGuide(rctx, fc.Args["guideId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Guide)
	fc.Result = res
	return ec.marshalOGuide2githubcomsatisfactorymoddingsmrapigeneratedGuide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getGuide(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Guide_id(ctx, field)
			case "name":
				return ec.fieldContext_Guide_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Guide_short_description(ctx, field)
			case "guide":
				return ec.fieldContext_Guide_guide(ctx, field)
			case "views":
				return ec.fieldContext_Guide_views(ctx, field)
			case "user_id":
				return ec.fieldContext_Guide_user_id(ctx, field)
			case "updated_at":
				return ec.fieldContext_Guide_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Guide_created_at(ctx, field)
			case "tags":
				return ec.fieldContext_Guide_tags(ctx, field)
			case "user":
				return ec.fieldContext_Guide_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Guide", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getGuide_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getGuides(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getGuides(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetGuides(rctx, fc.Args["filter"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetGuides)
	fc.Result = res
	return ec.marshalNGetGuides2githubcomsatisfactorymoddingsmrapigeneratedGetGuides(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getGuides(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "guides":
				return ec.fieldContext_GetGuides_guides(ctx, field)
			case "count":
				return ec.fieldContext_GetGuides_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetGuides", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getGuides_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMod(rctx, fc.Args["modId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalOMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getModByReference(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getModByReference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetModByReference(rctx, fc.Args["modReference"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalOMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getModByReference(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getModByReference_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getModByIdOrReference(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getModByIdOrReference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetModByIDOrReference(rctx, fc.Args["modIdOrReference"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalOMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getModByIdOrReference(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getModByIdOrReference_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMods(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMods(rctx, fc.Args["filter"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetMods)
	fc.Result = res
	return ec.marshalNGetMods2githubcomsatisfactorymoddingsmrapigeneratedGetMods(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mods":
				return ec.fieldContext_GetMods_mods(ctx, field)
			case "count":
				return ec.fieldContext_GetMods_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMods", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMods_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUnapprovedMods(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUnapprovedMods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetUnapprovedMods(rctx, fc.Args["filter"].(map[string]interface{}))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanApproveMods == nil {
				return nil, errors.New("directive canApproveMods is not implemented")
			}
			return ec.directives.CanApproveMods(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GetMods); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.GetMods`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetMods)
	fc.Result = res
	return ec.marshalNGetMods2githubcomsatisfactorymoddingsmrapigeneratedGetMods(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUnapprovedMods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mods":
				return ec.fieldContext_GetMods_mods(ctx, field)
			case "count":
				return ec.fieldContext_GetMods_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMods", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getUnapprovedMods_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMyMods(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMyMods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMyMods(rctx, fc.Args["filter"].(map[string]interface{}))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GetMyMods); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.GetMyMods`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetMyMods)
	fc.Result = res
	return ec.marshalNGetMyMods2githubcomsatisfactorymoddingsmrapigeneratedGetMyMods(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMyMods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mods":
				return ec.fieldContext_GetMyMods_mods(ctx, field)
			case "count":
				return ec.fieldContext_GetMyMods_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMyMods", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMyMods_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMyUnapprovedMods(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMyUnapprovedMods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMyUnapprovedMods(rctx, fc.Args["filter"].(map[string]interface{}))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GetMyMods); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.GetMyMods`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetMyMods)
	fc.Result = res
	return ec.marshalNGetMyMods2githubcomsatisfactorymoddingsmrapigeneratedGetMyMods(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMyUnapprovedMods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mods":
				return ec.fieldContext_GetMyMods_mods(ctx, field)
			case "count":
				return ec.fieldContext_GetMyMods_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMyMods", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMyUnapprovedMods_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_resolveModVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_resolveModVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ResolveModVersions(rctx, fc.Args["filter"].([]*ModVersionConstraint))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ModVersion)
	fc.Result = res
	return ec.marshalNModVersion2githubcomsatisfactorymoddingsmrapigeneratedModVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_resolveModVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ModVersion_id(ctx, field)
			case "mod_reference":
				return ec.fieldContext_ModVersion_mod_reference(ctx, field)
			case "versions":
				return ec.fieldContext_ModVersion_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_resolveModVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getSMLVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getSMLVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetSMLVersion(rctx, fc.Args["smlVersionID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*SMLVersion)
	fc.Result = res
	return ec.marshalOSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedSMLVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getSMLVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SMLVersion_id(ctx, field)
			case "version":
				return ec.fieldContext_SMLVersion_version(ctx, field)
			case "satisfactory_version":
				return ec.fieldContext_SMLVersion_satisfactory_version(ctx, field)
			case "stability":
				return ec.fieldContext_SMLVersion_stability(ctx, field)
			case "link":
				return ec.fieldContext_SMLVersion_link(ctx, field)
			case "targets":
				return ec.fieldContext_SMLVersion_targets(ctx, field)
			case "changelog":
				return ec.fieldContext_SMLVersion_changelog(ctx, field)
			case "date":
				return ec.fieldContext_SMLVersion_date(ctx, field)
			case "bootstrap_version":
				return ec.fieldContext_SMLVersion_bootstrap_version(ctx, field)
			case "engine_version":
				return ec.fieldContext_SMLVersion_engine_version(ctx, field)
			case "updated_at":
				return ec.fieldContext_SMLVersion_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_SMLVersion_created_at(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMLVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getSMLVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getSMLVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getSMLVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetSMLVersions(rctx, fc.Args["filter"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetSMLVersions)
	fc.Result = res
	return ec.marshalNGetSMLVersions2githubcomsatisfactorymoddingsmrapigeneratedGetSMLVersions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getSMLVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sml_versions":
				return ec.fieldContext_GetSMLVersions_sml_versions(ctx, field)
			case "count":
				return ec.fieldContext_GetSMLVersions_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetSMLVersions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getSMLVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetTag(rctx, fc.Args["tagID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetTags(rctx, fc.Args["filter"].(*TagFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalNTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getTags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getTags_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMe(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMe(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMe(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2githubcomsatisfactorymoddingsmrapigeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMe(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatar":
				return ec.fieldContext_User_avatar(ctx, field)
			case "created_at":
				return ec.fieldContext_User_created_at(ctx, field)
			case "github_id":
				return ec.fieldContext_User_github_id(ctx, field)
			case "google_id":
				return ec.fieldContext_User_google_id(ctx, field)
			case "facebook_id":
				return ec.fieldContext_User_facebook_id(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "mods":
				return ec.fieldContext_User_mods(ctx, field)
			case "guides":
				return ec.fieldContext_User_guides(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetUser(rctx, fc.Args["userId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2githubcomsatisfactorymoddingsmrapigeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatar":
				return ec.fieldContext_User_avatar(ctx, field)
			case "created_at":
				return ec.fieldContext_User_created_at(ctx, field)
			case "github_id":
				return ec.fieldContext_User_github_id(ctx, field)
			case "google_id":
				return ec.fieldContext_User_google_id(ctx, field)
			case "facebook_id":
				return ec.fieldContext_User_facebook_id(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "mods":
				return ec.fieldContext_User_mods(ctx, field)
			case "guides":
				return ec.fieldContext_User_guides(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetUsers(rctx, fc.Args["userIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*User)
	fc.Result = res
	return ec.marshalNUser2githubcomsatisfactorymoddingsmrapigeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatar":
				return ec.fieldContext_User_avatar(ctx, field)
			case "created_at":
				return ec.fieldContext_User_created_at(ctx, field)
			case "github_id":
				return ec.fieldContext_User_github_id(ctx, field)
			case "google_id":
				return ec.fieldContext_User_google_id(ctx, field)
			case "facebook_id":
				return ec.fieldContext_User_facebook_id(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "mods":
				return ec.fieldContext_User_mods(ctx, field)
			case "guides":
				return ec.fieldContext_User_guides(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetVersion(rctx, fc.Args["versionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetVersions(rctx, fc.Args["filter"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetVersions)
	fc.Result = res
	return ec.marshalNGetVersions2githubcomsatisfactorymoddingsmrapigeneratedGetVersions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "versions":
				return ec.fieldContext_GetVersions_versions(ctx, field)
			case "count":
				return ec.fieldContext_GetVersions_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetVersions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUnapprovedVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUnapprovedVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetUnapprovedVersions(rctx, fc.Args["filter"].(map[string]interface{}))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CanApproveVersions == nil {
				return nil, errors.New("directive canApproveVersions is not implemented")
			}
			return ec.directives.CanApproveVersions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GetVersions); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.GetVersions`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetVersions)
	fc.Result = res
	return ec.marshalNGetVersions2githubcomsatisfactorymoddingsmrapigeneratedGetVersions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUnapprovedVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "versions":
				return ec.fieldContext_GetVersions_versions(ctx, field)
			case "count":
				return ec.fieldContext_GetVersions_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetVersions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getUnapprovedVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_checkVersionUploadState(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_checkVersionUploadState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CheckVersionUploadState(rctx, fc.Args["modId"].(string), fc.Args["versionId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "modId")
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditMod == nil {
				return nil, errors.New("directive canEditMod is not implemented")
			}
			return ec.directives.CanEditMod(ctx, nil, directive0, field)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*CreateVersionResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.CreateVersionResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CreateVersionResponse)
	fc.Result = res
	return ec.marshalOCreateVersionResponse2githubcomsatisfactorymoddingsmrapigeneratedCreateVersionResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_checkVersionUploadState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "auto_approved":
				return ec.fieldContext_CreateVersionResponse_auto_approved(ctx, field)
			case "version":
				return ec.fieldContext_CreateVersionResponse_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateVersionResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_checkVersionUploadState_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMyVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMyVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMyVersions(rctx, fc.Args["filter"].(map[string]interface{}))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GetMyVersions); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.GetMyVersions`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetMyVersions)
	fc.Result = res
	return ec.marshalNGetMyVersions2githubcomsatisfactorymoddingsmrapigeneratedGetMyVersions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMyVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "versions":
				return ec.fieldContext_GetMyVersions_versions(ctx, field)
			case "count":
				return ec.fieldContext_GetMyVersions_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMyVersions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMyVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMyUnapprovedVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMyUnapprovedVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetMyUnapprovedVersions(rctx, fc.Args["filter"].(map[string]interface{}))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*GetMyVersions); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.GetMyVersions`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GetMyVersions)
	fc.Result = res
	return ec.marshalNGetMyVersions2githubcomsatisfactorymoddingsmrapigeneratedGetMyVersions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMyUnapprovedVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "versions":
				return ec.fieldContext_GetMyVersions_versions(ctx, field)
			case "count":
				return ec.fieldContext_GetMyVersions_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GetMyVersions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMyUnapprovedVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_id(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNSMLVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SMLVersionID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_version(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_satisfactory_version(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_satisfactory_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SatisfactoryVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_satisfactory_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_stability(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_stability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(VersionStabilities)
	fc.Result = res
	return ec.marshalNVersionStabilities2githubcomsatisfactorymoddingsmrapigeneratedVersionStabilities(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_stability(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionStabilities does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_link(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_link(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Link, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_link(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_targets(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_targets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Targets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*SMLVersionTarget)
	fc.Result = res
	return ec.marshalNSMLVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedSMLVersionTarget(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_targets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "VersionID":
				return ec.fieldContext_SMLVersionTarget_VersionID(ctx, field)
			case "targetName":
				return ec.fieldContext_SMLVersionTarget_targetName(ctx, field)
			case "link":
				return ec.fieldContext_SMLVersionTarget_link(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SMLVersionTarget", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_changelog(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_changelog(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Changelog, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_changelog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_date(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_bootstrap_version(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_bootstrap_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BootstrapVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_bootstrap_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_engine_version(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_engine_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EngineVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_engine_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_updated_at(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersion_created_at(ctx context.Context, field graphql.CollectedField, obj *SMLVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersion_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersion_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersionTarget_VersionID(ctx context.Context, field graphql.CollectedField, obj *SMLVersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersionTarget_VersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNSMLVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersionTarget_VersionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SMLVersionID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersionTarget_targetName(ctx context.Context, field graphql.CollectedField, obj *SMLVersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersionTarget_targetName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TargetName)
	fc.Result = res
	return ec.marshalNTargetName2githubcomsatisfactorymoddingsmrapigeneratedTargetName(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersionTarget_targetName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TargetName does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SMLVersionTarget_link(ctx context.Context, field graphql.CollectedField, obj *SMLVersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SMLVersionTarget_link(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Link, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SMLVersionTarget_link(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SMLVersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_id(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNTagID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TagID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_name(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNTagName2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TagName does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNUserID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Email, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "ID")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, obj, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, obj, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_username(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_avatar(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_avatar(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Avatar, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_avatar(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_created_at(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_github_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_github_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GithubID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "ID")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, obj, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, obj, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_github_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_google_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_google_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GoogleID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "ID")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, obj, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, obj, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_google_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_facebook_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_facebook_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.FacebookID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "ID")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, obj, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, obj, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_facebook_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_roles(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().Roles(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "ID")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, obj, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, obj, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*UserRoles); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/satisfactorymodding/smr-api/generated.UserRoles`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*UserRoles)
	fc.Result = res
	return ec.marshalNUserRoles2githubcomsatisfactorymoddingsmrapigeneratedUserRoles(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_roles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "approveMods":
				return ec.fieldContext_UserRoles_approveMods(ctx, field)
			case "approveVersions":
				return ec.fieldContext_UserRoles_approveVersions(ctx, field)
			case "deleteContent":
				return ec.fieldContext_UserRoles_deleteContent(ctx, field)
			case "editContent":
				return ec.fieldContext_UserRoles_editContent(ctx, field)
			case "editUsers":
				return ec.fieldContext_UserRoles_editUsers(ctx, field)
			case "editSMLVersions":
				return ec.fieldContext_UserRoles_editSMLVersions(ctx, field)
			case "editBootstrapVersions":
				return ec.fieldContext_UserRoles_editBootstrapVersions(ctx, field)
			case "editAnyModCompatibility":
				return ec.fieldContext_UserRoles_editAnyModCompatibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRoles", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_groups(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().Groups(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			field, err := ec.unmarshalNString2string(ctx, "ID")
			if err != nil {
				return nil, err
			}
			object, err := ec.unmarshalNBoolean2bool(ctx, true)
			if err != nil {
				return nil, err
			}
			if ec.directives.CanEditUser == nil {
				return nil, errors.New("directive canEditUser is not implemented")
			}
			return ec.directives.CanEditUser(ctx, obj, directive0, field, object)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedIn == nil {
				return nil, errors.New("directive isLoggedIn is not implemented")
			}
			return ec.directives.IsLoggedIn(ctx, obj, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Group); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/satisfactorymodding/smr-api/generated.Group`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Group)
	fc.Result = res
	return ec.marshalNGroup2githubcomsatisfactorymoddingsmrapigeneratedGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_mods(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_mods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Mods(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*UserMod)
	fc.Result = res
	return ec.marshalNUserMod2githubcomsatisfactorymoddingsmrapigeneratedUserMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_mods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user_id":
				return ec.fieldContext_UserMod_user_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_UserMod_mod_id(ctx, field)
			case "role":
				return ec.fieldContext_UserMod_role(ctx, field)
			case "user":
				return ec.fieldContext_UserMod_user(ctx, field)
			case "mod":
				return ec.fieldContext_UserMod_mod(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserMod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_guides(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_guides(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Guides(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Guide)
	fc.Result = res
	return ec.marshalNGuide2githubcomsatisfactorymoddingsmrapigeneratedGuide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_guides(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Guide_id(ctx, field)
			case "name":
				return ec.fieldContext_Guide_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Guide_short_description(ctx, field)
			case "guide":
				return ec.fieldContext_Guide_guide(ctx, field)
			case "views":
				return ec.fieldContext_Guide_views(ctx, field)
			case "user_id":
				return ec.fieldContext_Guide_user_id(ctx, field)
			case "updated_at":
				return ec.fieldContext_Guide_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Guide_created_at(ctx, field)
			case "tags":
				return ec.fieldContext_Guide_tags(ctx, field)
			case "user":
				return ec.fieldContext_Guide_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Guide", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserMod_user_id(ctx context.Context, field graphql.CollectedField, obj *UserMod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserMod_user_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNUserID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserMod_user_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserMod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserMod_mod_id(ctx context.Context, field graphql.CollectedField, obj *UserMod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserMod_mod_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserMod_mod_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserMod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserMod_role(ctx context.Context, field graphql.CollectedField, obj *UserMod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserMod_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserMod_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserMod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserMod_user(ctx context.Context, field graphql.CollectedField, obj *UserMod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserMod_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserMod().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalNUser2githubcomsatisfactorymoddingsmrapigeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserMod_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserMod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "avatar":
				return ec.fieldContext_User_avatar(ctx, field)
			case "created_at":
				return ec.fieldContext_User_created_at(ctx, field)
			case "github_id":
				return ec.fieldContext_User_github_id(ctx, field)
			case "google_id":
				return ec.fieldContext_User_google_id(ctx, field)
			case "facebook_id":
				return ec.fieldContext_User_facebook_id(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "mods":
				return ec.fieldContext_User_mods(ctx, field)
			case "guides":
				return ec.fieldContext_User_guides(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserMod_mod(ctx context.Context, field graphql.CollectedField, obj *UserMod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserMod_mod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserMod().Mod(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalNMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserMod_mod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserMod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_approveMods(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_approveMods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApproveMods, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_approveMods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_approveVersions(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_approveVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApproveVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_approveVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_deleteContent(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_deleteContent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeleteContent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_deleteContent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_editContent(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_editContent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditContent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_editContent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_editUsers(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_editUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_editUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_editSMLVersions(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_editSMLVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditSMLVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_editSMLVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_editBootstrapVersions(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_editBootstrapVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditBootstrapVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_editBootstrapVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRoles_editAnyModCompatibility(ctx context.Context, field graphql.CollectedField, obj *UserRoles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRoles_editAnyModCompatibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditAnyModCompatibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRoles_editAnyModCompatibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRoles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSession_token(ctx context.Context, field graphql.CollectedField, obj *UserSession) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSession_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSession_token(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSession",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_id(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_mod_id(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_mod_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_mod_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_version(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_sml_version(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_sml_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SmlVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_sml_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_changelog(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_changelog(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Changelog, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_changelog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_downloads(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_downloads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Downloads, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_downloads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_stability(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_stability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(VersionStabilities)
	fc.Result = res
	return ec.marshalNVersionStabilities2githubcomsatisfactorymoddingsmrapigeneratedVersionStabilities(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_stability(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionStabilities does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_approved(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_approved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Approved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_approved(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_updated_at(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_created_at(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_link(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_link(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Link(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_link(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_targets(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_targets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Targets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*VersionTarget)
	fc.Result = res
	return ec.marshalNVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedVersionTarget(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_targets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "VersionID":
				return ec.fieldContext_VersionTarget_VersionID(ctx, field)
			case "targetName":
				return ec.fieldContext_VersionTarget_targetName(ctx, field)
			case "link":
				return ec.fieldContext_VersionTarget_link(ctx, field)
			case "size":
				return ec.fieldContext_VersionTarget_size(ctx, field)
			case "hash":
				return ec.fieldContext_VersionTarget_hash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionTarget", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_metadata(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_size(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Size(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_hash(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Hash(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_mod(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_mod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Mod(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalNMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_mod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_dependencies(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_dependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Dependencies(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*VersionDependency)
	fc.Result = res
	return ec.marshalNVersionDependency2githubcomsatisfactorymoddingsmrapigeneratedVersionDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_dependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version_id":
				return ec.fieldContext_VersionDependency_version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_VersionDependency_mod_id(ctx, field)
			case "condition":
				return ec.fieldContext_VersionDependency_condition(ctx, field)
			case "optional":
				return ec.fieldContext_VersionDependency_optional(ctx, field)
			case "mod":
				return ec.fieldContext_VersionDependency_mod(ctx, field)
			case "version":
				return ec.fieldContext_VersionDependency_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionDependency_version_id(ctx context.Context, field graphql.CollectedField, obj *VersionDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionDependency_version_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionDependency_version_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionDependency_mod_id(ctx context.Context, field graphql.CollectedField, obj *VersionDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionDependency_mod_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNModID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionDependency_mod_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ModID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionDependency_condition(ctx context.Context, field graphql.CollectedField, obj *VersionDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionDependency_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionDependency_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionDependency_optional(ctx context.Context, field graphql.CollectedField, obj *VersionDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionDependency_optional(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Optional, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionDependency_optional(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionDependency_mod(ctx context.Context, field graphql.CollectedField, obj *VersionDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionDependency_mod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Mod)
	fc.Result = res
	return ec.marshalOMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionDependency_mod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Mod_id(ctx, field)
			case "name":
				return ec.fieldContext_Mod_name(ctx, field)
			case "short_description":
				return ec.fieldContext_Mod_short_description(ctx, field)
			case "full_description":
				return ec.fieldContext_Mod_full_description(ctx, field)
			case "logo":
				return ec.fieldContext_Mod_logo(ctx, field)
			case "source_url":
				return ec.fieldContext_Mod_source_url(ctx, field)
			case "creator_id":
				return ec.fieldContext_Mod_creator_id(ctx, field)
			case "approved":
				return ec.fieldContext_Mod_approved(ctx, field)
			case "views":
				return ec.fieldContext_Mod_views(ctx, field)
			case "downloads":
				return ec.fieldContext_Mod_downloads(ctx, field)
			case "hotness":
				return ec.fieldContext_Mod_hotness(ctx, field)
			case "popularity":
				return ec.fieldContext_Mod_popularity(ctx, field)
			case "updated_at":
				return ec.fieldContext_Mod_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Mod_created_at(ctx, field)
			case "last_version_date":
				return ec.fieldContext_Mod_last_version_date(ctx, field)
			case "mod_reference":
				return ec.fieldContext_Mod_mod_reference(ctx, field)
			case "hidden":
				return ec.fieldContext_Mod_hidden(ctx, field)
			case "tags":
				return ec.fieldContext_Mod_tags(ctx, field)
			case "compatibility":
				return ec.fieldContext_Mod_compatibility(ctx, field)
			case "authors":
				return ec.fieldContext_Mod_authors(ctx, field)
			case "version":
				return ec.fieldContext_Mod_version(ctx, field)
			case "versions":
				return ec.fieldContext_Mod_versions(ctx, field)
			case "latestVersions":
				return ec.fieldContext_Mod_latestVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Mod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionDependency_version(ctx context.Context, field graphql.CollectedField, obj *VersionDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionDependency_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalOVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionDependency_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "mod_id":
				return ec.fieldContext_Version_mod_id(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			case "sml_version":
				return ec.fieldContext_Version_sml_version(ctx, field)
			case "changelog":
				return ec.fieldContext_Version_changelog(ctx, field)
			case "downloads":
				return ec.fieldContext_Version_downloads(ctx, field)
			case "stability":
				return ec.fieldContext_Version_stability(ctx, field)
			case "approved":
				return ec.fieldContext_Version_approved(ctx, field)
			case "updated_at":
				return ec.fieldContext_Version_updated_at(ctx, field)
			case "created_at":
				return ec.fieldContext_Version_created_at(ctx, field)
			case "link":
				return ec.fieldContext_Version_link(ctx, field)
			case "targets":
				return ec.fieldContext_Version_targets(ctx, field)
			case "metadata":
				return ec.fieldContext_Version_metadata(ctx, field)
			case "size":
				return ec.fieldContext_Version_size(ctx, field)
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "mod":
				return ec.fieldContext_Version_mod(ctx, field)
			case "dependencies":
				return ec.fieldContext_Version_dependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTarget_VersionID(ctx context.Context, field graphql.CollectedField, obj *VersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTarget_VersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNVersionID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTarget_VersionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTarget_targetName(ctx context.Context, field graphql.CollectedField, obj *VersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTarget_targetName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TargetName)
	fc.Result = res
	return ec.marshalNTargetName2githubcomsatisfactorymoddingsmrapigeneratedTargetName(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTarget_targetName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TargetName does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTarget_link(ctx context.Context, field graphql.CollectedField, obj *VersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTarget_link(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.VersionTarget().Link(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTarget_link(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTarget",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTarget_size(ctx context.Context, field graphql.CollectedField, obj *VersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTarget_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTarget_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTarget_hash(ctx context.Context, field graphql.CollectedField, obj *VersionTarget) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTarget_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTarget_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTarget",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCompatibilityInfoInput(ctx context.Context, obj interface{}) (CompatibilityInfoInput, error) {
	var it CompatibilityInfoInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"EA", "EXP"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "EA":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("EA"))
			data, err := ec.unmarshalNCompatibilityInput2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ea = data
		case "EXP":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("EXP"))
			data, err := ec.unmarshalNCompatibilityInput2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Exp = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCompatibilityInput(ctx context.Context, obj interface{}) (CompatibilityInput, error) {
	var it CompatibilityInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"state", "note"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "state":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("state"))
			data, err := ec.unmarshalNCompatibilityState2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityState(ctx, v)
			if err != nil {
				return it, err
			}
			it.State = data
		case "note":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("note"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Note = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputModVersionConstraint(ctx context.Context, obj interface{}) (ModVersionConstraint, error) {
	var it ModVersionConstraint
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"modIdOrReference", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "modIdOrReference":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modIdOrReference"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModIDOrReference = data
		case "version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewAnnouncement(ctx context.Context, obj interface{}) (NewAnnouncement, error) {
	var it NewAnnouncement
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"message", "importance"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "message":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "importance":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("importance"))
			data, err := ec.unmarshalNAnnouncementImportance2githubcomsatisfactorymoddingsmrapigeneratedAnnouncementImportance(ctx, v)
			if err != nil {
				return it, err
			}
			it.Importance = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewGuide(ctx context.Context, obj interface{}) (NewGuide, error) {
	var it NewGuide
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "short_description", "guide", "tagIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "short_description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("short_description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShortDescription = data
		case "guide":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guide"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Guide = data
		case "tagIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagIDs"))
			data, err := ec.unmarshalOTagID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewMod(ctx context.Context, obj interface{}) (NewMod, error) {
	var it NewMod
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "short_description", "full_description", "logo", "source_url", "mod_reference", "hidden", "tagIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "short_description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("short_description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShortDescription = data
		case "full_description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("full_description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullDescription = data
		case "logo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logo"))
			data, err := ec.unmarshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx, v)
			if err != nil {
				return it, err
			}
			it.Logo = data
		case "source_url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source_url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURL = data
		case "mod_reference":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mod_reference"))
			data, err := ec.unmarshalNModReference2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModReference = data
		case "hidden":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hidden = data
		case "tagIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagIDs"))
			data, err := ec.unmarshalOTagID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewSMLVersion(ctx context.Context, obj interface{}) (NewSMLVersion, error) {
	var it NewSMLVersion
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version", "satisfactory_version", "stability", "link", "targets", "changelog", "date", "bootstrap_version", "engine_version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "satisfactory_version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("satisfactory_version"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SatisfactoryVersion = data
		case "stability":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stability"))
			data, err := ec.unmarshalNVersionStabilities2githubcomsatisfactorymoddingsmrapigeneratedVersionStabilities(ctx, v)
			if err != nil {
				return it, err
			}
			it.Stability = data
		case "link":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("link"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Link = data
		case "targets":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targets"))
			data, err := ec.unmarshalNNewSMLVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedNewSMLVersionTarget(ctx, v)
			if err != nil {
				return it, err
			}
			it.Targets = data
		case "changelog":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changelog"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Changelog = data
		case "date":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalNDate2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		case "bootstrap_version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bootstrap_version"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BootstrapVersion = data
		case "engine_version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("engine_version"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EngineVersion = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewSMLVersionTarget(ctx context.Context, obj interface{}) (NewSMLVersionTarget, error) {
	var it NewSMLVersionTarget
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"targetName", "link"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "targetName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetName"))
			data, err := ec.unmarshalNTargetName2githubcomsatisfactorymoddingsmrapigeneratedTargetName(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetName = data
		case "link":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("link"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Link = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewVersion(ctx context.Context, obj interface{}) (NewVersion, error) {
	var it NewVersion
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"changelog", "stability"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "changelog":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changelog"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Changelog = data
		case "stability":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stability"))
			data, err := ec.unmarshalNVersionStabilities2githubcomsatisfactorymoddingsmrapigeneratedVersionStabilities(ctx, v)
			if err != nil {
				return it, err
			}
			it.Stability = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagFilter(ctx context.Context, obj interface{}) (TagFilter, error) {
	var it TagFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"limit", "offset", "order", "search", "ids"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "offset":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "order":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOOrder2githubcomsatisfactorymoddingsmrapigeneratedOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "search":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			data, err := ec.unmarshalOTagID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ids = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateAnnouncement(ctx context.Context, obj interface{}) (UpdateAnnouncement, error) {
	var it UpdateAnnouncement
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"message", "importance"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "message":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "importance":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("importance"))
			data, err := ec.unmarshalOAnnouncementImportance2githubcomsatisfactorymoddingsmrapigeneratedAnnouncementImportance(ctx, v)
			if err != nil {
				return it, err
			}
			it.Importance = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateGuide(ctx context.Context, obj interface{}) (UpdateGuide, error) {
	var it UpdateGuide
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "short_description", "guide", "tagIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "short_description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("short_description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShortDescription = data
		case "guide":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("guide"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Guide = data
		case "tagIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagIDs"))
			data, err := ec.unmarshalOTagID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMod(ctx context.Context, obj interface{}) (UpdateMod, error) {
	var it UpdateMod
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "short_description", "full_description", "logo", "source_url", "mod_reference", "authors", "hidden", "tagIDs", "compatibility"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "short_description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("short_description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShortDescription = data
		case "full_description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("full_description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullDescription = data
		case "logo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logo"))
			data, err := ec.unmarshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx, v)
			if err != nil {
				return it, err
			}
			it.Logo = data
		case "source_url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source_url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURL = data
		case "mod_reference":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mod_reference"))
			data, err := ec.unmarshalOModReference2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModReference = data
		case "authors":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authors"))
			data, err := ec.unmarshalOUpdateUserMod2githubcomsatisfactorymoddingsmrapigeneratedUpdateUserMod(ctx, v)
			if err != nil {
				return it, err
			}
			it.Authors = data
		case "hidden":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hidden = data
		case "tagIDs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagIDs"))
			data, err := ec.unmarshalOTagID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagIDs = data
		case "compatibility":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compatibility"))
			data, err := ec.unmarshalOCompatibilityInfoInput2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityInfoInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Compatibility = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSMLVersion(ctx context.Context, obj interface{}) (UpdateSMLVersion, error) {
	var it UpdateSMLVersion
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version", "satisfactory_version", "stability", "link", "targets", "changelog", "date", "bootstrap_version", "engine_version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "satisfactory_version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("satisfactory_version"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SatisfactoryVersion = data
		case "stability":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stability"))
			data, err := ec.unmarshalOVersionStabilities2githubcomsatisfactorymoddingsmrapigeneratedVersionStabilities(ctx, v)
			if err != nil {
				return it, err
			}
			it.Stability = data
		case "link":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("link"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Link = data
		case "targets":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targets"))
			data, err := ec.unmarshalNUpdateSMLVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedUpdateSMLVersionTarget(ctx, v)
			if err != nil {
				return it, err
			}
			it.Targets = data
		case "changelog":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changelog"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Changelog = data
		case "date":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalODate2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		case "bootstrap_version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bootstrap_version"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BootstrapVersion = data
		case "engine_version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("engine_version"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EngineVersion = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSMLVersionTarget(ctx context.Context, obj interface{}) (UpdateSMLVersionTarget, error) {
	var it UpdateSMLVersionTarget
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"targetName", "link"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "targetName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetName"))
			data, err := ec.unmarshalNTargetName2githubcomsatisfactorymoddingsmrapigeneratedTargetName(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetName = data
		case "link":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("link"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Link = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUser(ctx context.Context, obj interface{}) (UpdateUser, error) {
	var it UpdateUser
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"avatar", "groups", "username"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "avatar":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatar"))
			data, err := ec.unmarshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx, v)
			if err != nil {
				return it, err
			}
			it.Avatar = data
		case "groups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groups"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.CanEditUsers == nil {
					return nil, errors.New("directive canEditUsers is not implemented")
				}
				return ec.directives.CanEditUsers(ctx, obj, directive0)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				if ec.directives.IsLoggedIn == nil {
					return nil, errors.New("directive isLoggedIn is not implemented")
				}
				return ec.directives.IsLoggedIn(ctx, obj, directive1)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]string); ok {
				it.Groups = data
			} else if tmp == nil {
				it.Groups = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserMod(ctx context.Context, obj interface{}) (UpdateUserMod, error) {
	var it UpdateUserMod
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"user_id", "role"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "user_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user_id"))
			data, err := ec.unmarshalNUserID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "role":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateVersion(ctx context.Context, obj interface{}) (UpdateVersion, error) {
	var it UpdateVersion
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"changelog", "stability"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "changelog":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("changelog"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Changelog = data
		case "stability":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stability"))
			data, err := ec.unmarshalOVersionStabilities2githubcomsatisfactorymoddingsmrapigeneratedVersionStabilities(ctx, v)
			if err != nil {
				return it, err
			}
			it.Stability = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var announcementImplementors = []string{"Announcement"}

func (ec *executionContext) _Announcement(ctx context.Context, sel ast.SelectionSet, obj *Announcement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, announcementImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Announcement")
		case "id":
			out.Values[i] = ec._Announcement_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._Announcement_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "importance":
			out.Values[i] = ec._Announcement_importance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compatibilityImplementors = []string{"Compatibility"}

func (ec *executionContext) _Compatibility(ctx context.Context, sel ast.SelectionSet, obj *Compatibility) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compatibilityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Compatibility")
		case "state":
			out.Values[i] = ec._Compatibility_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "note":
			out.Values[i] = ec._Compatibility_note(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var compatibilityInfoImplementors = []string{"CompatibilityInfo"}

func (ec *executionContext) _CompatibilityInfo(ctx context.Context, sel ast.SelectionSet, obj *CompatibilityInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, compatibilityInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CompatibilityInfo")
		case "EA":
			out.Values[i] = ec._CompatibilityInfo_EA(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "EXP":
			out.Values[i] = ec._CompatibilityInfo_EXP(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createVersionResponseImplementors = []string{"CreateVersionResponse"}

func (ec *executionContext) _CreateVersionResponse(ctx context.Context, sel ast.SelectionSet, obj *CreateVersionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createVersionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateVersionResponse")
		case "auto_approved":
			out.Values[i] = ec._CreateVersionResponse_auto_approved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._CreateVersionResponse_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getGuidesImplementors = []string{"GetGuides"}

func (ec *executionContext) _GetGuides(ctx context.Context, sel ast.SelectionSet, obj *GetGuides) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getGuidesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetGuides")
		case "guides":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetGuides_guides(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetGuides_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getModsImplementors = []string{"GetMods"}

func (ec *executionContext) _GetMods(ctx context.Context, sel ast.SelectionSet, obj *GetMods) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getModsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMods")
		case "mods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMods_mods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMods_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMyModsImplementors = []string{"GetMyMods"}

func (ec *executionContext) _GetMyMods(ctx context.Context, sel ast.SelectionSet, obj *GetMyMods) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMyModsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMyMods")
		case "mods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMyMods_mods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMyMods_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getMyVersionsImplementors = []string{"GetMyVersions"}

func (ec *executionContext) _GetMyVersions(ctx context.Context, sel ast.SelectionSet, obj *GetMyVersions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getMyVersionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetMyVersions")
		case "versions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMyVersions_versions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetMyVersions_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getSMLVersionsImplementors = []string{"GetSMLVersions"}

func (ec *executionContext) _GetSMLVersions(ctx context.Context, sel ast.SelectionSet, obj *GetSMLVersions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getSMLVersionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetSMLVersions")
		case "sml_versions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetSMLVersions_sml_versions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetSMLVersions_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var getVersionsImplementors = []string{"GetVersions"}

func (ec *executionContext) _GetVersions(ctx context.Context, sel ast.SelectionSet, obj *GetVersions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, getVersionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GetVersions")
		case "versions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetVersions_versions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GetVersions_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupImplementors = []string{"Group"}

func (ec *executionContext) _Group(ctx context.Context, sel ast.SelectionSet, obj *Group) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Group")
		case "id":
			out.Values[i] = ec._Group_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Group_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var guideImplementors = []string{"Guide"}

func (ec *executionContext) _Guide(ctx context.Context, sel ast.SelectionSet, obj *Guide) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, guideImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Guide")
		case "id":
			out.Values[i] = ec._Guide_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Guide_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "short_description":
			out.Values[i] = ec._Guide_short_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "guide":
			out.Values[i] = ec._Guide_guide(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "views":
			out.Values[i] = ec._Guide_views(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user_id":
			out.Values[i] = ec._Guide_user_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updated_at":
			out.Values[i] = ec._Guide_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "created_at":
			out.Values[i] = ec._Guide_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			out.Values[i] = ec._Guide_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Guide_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var latestVersionsImplementors = []string{"LatestVersions"}

func (ec *executionContext) _LatestVersions(ctx context.Context, sel ast.SelectionSet, obj *LatestVersions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, latestVersionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LatestVersions")
		case "alpha":
			out.Values[i] = ec._LatestVersions_alpha(ctx, field, obj)
		case "beta":
			out.Values[i] = ec._LatestVersions_beta(ctx, field, obj)
		case "release":
			out.Values[i] = ec._LatestVersions_release(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modImplementors = []string{"Mod"}

func (ec *executionContext) _Mod(ctx context.Context, sel ast.SelectionSet, obj *Mod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mod")
		case "id":
			out.Values[i] = ec._Mod_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Mod_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "short_description":
			out.Values[i] = ec._Mod_short_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "full_description":
			out.Values[i] = ec._Mod_full_description(ctx, field, obj)
		case "logo":
			out.Values[i] = ec._Mod_logo(ctx, field, obj)
		case "source_url":
			out.Values[i] = ec._Mod_source_url(ctx, field, obj)
		case "creator_id":
			out.Values[i] = ec._Mod_creator_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "approved":
			out.Values[i] = ec._Mod_approved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "views":
			out.Values[i] = ec._Mod_views(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "downloads":
			out.Values[i] = ec._Mod_downloads(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hotness":
			out.Values[i] = ec._Mod_hotness(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "popularity":
			out.Values[i] = ec._Mod_popularity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updated_at":
			out.Values[i] = ec._Mod_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "created_at":
			out.Values[i] = ec._Mod_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "last_version_date":
			out.Values[i] = ec._Mod_last_version_date(ctx, field, obj)
		case "mod_reference":
			out.Values[i] = ec._Mod_mod_reference(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hidden":
			out.Values[i] = ec._Mod_hidden(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			out.Values[i] = ec._Mod_tags(ctx, field, obj)
		case "compatibility":
			out.Values[i] = ec._Mod_compatibility(ctx, field, obj)
		case "authors":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Mod_authors(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Mod_version(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "versions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Mod_versions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "latestVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Mod_latestVersions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var modVersionImplementors = []string{"ModVersion"}

func (ec *executionContext) _ModVersion(ctx context.Context, sel ast.SelectionSet, obj *ModVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, modVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModVersion")
		case "id":
			out.Values[i] = ec._ModVersion_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mod_reference":
			out.Values[i] = ec._ModVersion_mod_reference(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versions":
			out.Values[i] = ec._ModVersion_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "discourseSSO":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_discourseSSO(ctx, field)
			})
		case "createAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createAnnouncement(ctx, field)
			})
		case "updateAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteAnnouncement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteAnnouncement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateModCompatibility":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateModCompatibility(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMultipleModCompatibilities":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMultipleModCompatibilities(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createGuide":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createGuide(ctx, field)
			})
		case "updateGuide":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateGuide(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteGuide":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGuide(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMod":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMod(ctx, field)
			})
		case "updateMod":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMod(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteMod":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteMod(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approveMod":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_approveMod(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "denyMod":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_denyMod(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createSMLVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSMLVersion(ctx, field)
			})
		case "updateSMLVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSMLVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSMLVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSMLVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTag(ctx, field)
			})
		case "createMultipleTags":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMultipleTags(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "logout":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_logout(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oAuthGithub":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_oAuthGithub(ctx, field)
			})
		case "oAuthGoogle":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_oAuthGoogle(ctx, field)
			})
		case "oAuthFacebook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_oAuthFacebook(ctx, field)
			})
		case "createVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uploadVersionPart":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_uploadVersionPart(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "finalizeCreateVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_finalizeCreateVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approveVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_approveVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "denyVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_denyVersion(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuthOptionsImplementors = []string{"OAuthOptions"}

func (ec *executionContext) _OAuthOptions(ctx context.Context, sel ast.SelectionSet, obj *OAuthOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuthOptionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuthOptions")
		case "github":
			out.Values[i] = ec._OAuthOptions_github(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "google":
			out.Values[i] = ec._OAuthOptions_google(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "facebook":
			out.Values[i] = ec._OAuthOptions_facebook(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getOAuthOptions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getOAuthOptions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getAnnouncement":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAnnouncement(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getAnnouncements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAnnouncements(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getAnnouncementsByImportance":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAnnouncementsByImportance(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getGuide":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getGuide(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getGuides":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getGuides(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMod":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMod(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getModByReference":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getModByReference(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getModByIdOrReference":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getModByIdOrReference(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMods(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUnapprovedMods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUnapprovedMods(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMyMods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMyMods(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMyUnapprovedMods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMyUnapprovedMods(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "resolveModVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_resolveModVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getSMLVersion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getSMLVersion(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getSMLVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getSMLVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getTag":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getTag(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getTags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMe":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMe(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUser":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUser(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getVersion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getVersion(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUnapprovedVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUnapprovedVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "checkVersionUploadState":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_checkVersionUploadState(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMyVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMyVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMyUnapprovedVersions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMyUnapprovedVersions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sMLVersionImplementors = []string{"SMLVersion"}

func (ec *executionContext) _SMLVersion(ctx context.Context, sel ast.SelectionSet, obj *SMLVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sMLVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SMLVersion")
		case "id":
			out.Values[i] = ec._SMLVersion_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._SMLVersion_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "satisfactory_version":
			out.Values[i] = ec._SMLVersion_satisfactory_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stability":
			out.Values[i] = ec._SMLVersion_stability(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "link":
			out.Values[i] = ec._SMLVersion_link(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "targets":
			out.Values[i] = ec._SMLVersion_targets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changelog":
			out.Values[i] = ec._SMLVersion_changelog(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "date":
			out.Values[i] = ec._SMLVersion_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bootstrap_version":
			out.Values[i] = ec._SMLVersion_bootstrap_version(ctx, field, obj)
		case "engine_version":
			out.Values[i] = ec._SMLVersion_engine_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updated_at":
			out.Values[i] = ec._SMLVersion_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "created_at":
			out.Values[i] = ec._SMLVersion_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sMLVersionTargetImplementors = []string{"SMLVersionTarget"}

func (ec *executionContext) _SMLVersionTarget(ctx context.Context, sel ast.SelectionSet, obj *SMLVersionTarget) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sMLVersionTargetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SMLVersionTarget")
		case "VersionID":
			out.Values[i] = ec._SMLVersionTarget_VersionID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "targetName":
			out.Values[i] = ec._SMLVersionTarget_targetName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "link":
			out.Values[i] = ec._SMLVersionTarget_link(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagImplementors = []string{"Tag"}

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "id":
			out.Values[i] = ec._Tag_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Tag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
		case "username":
			out.Values[i] = ec._User_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "avatar":
			out.Values[i] = ec._User_avatar(ctx, field, obj)
		case "created_at":
			out.Values[i] = ec._User_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "github_id":
			out.Values[i] = ec._User_github_id(ctx, field, obj)
		case "google_id":
			out.Values[i] = ec._User_google_id(ctx, field, obj)
		case "facebook_id":
			out.Values[i] = ec._User_facebook_id(ctx, field, obj)
		case "roles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_roles(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_groups(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mods":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_mods(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "guides":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_guides(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userModImplementors = []string{"UserMod"}

func (ec *executionContext) _UserMod(ctx context.Context, sel ast.SelectionSet, obj *UserMod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userModImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserMod")
		case "user_id":
			out.Values[i] = ec._UserMod_user_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mod_id":
			out.Values[i] = ec._UserMod_mod_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "role":
			out.Values[i] = ec._UserMod_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserMod_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mod":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserMod_mod(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userRolesImplementors = []string{"UserRoles"}

func (ec *executionContext) _UserRoles(ctx context.Context, sel ast.SelectionSet, obj *UserRoles) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userRolesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserRoles")
		case "approveMods":
			out.Values[i] = ec._UserRoles_approveMods(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "approveVersions":
			out.Values[i] = ec._UserRoles_approveVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteContent":
			out.Values[i] = ec._UserRoles_deleteContent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editContent":
			out.Values[i] = ec._UserRoles_editContent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editUsers":
			out.Values[i] = ec._UserRoles_editUsers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editSMLVersions":
			out.Values[i] = ec._UserRoles_editSMLVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editBootstrapVersions":
			out.Values[i] = ec._UserRoles_editBootstrapVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editAnyModCompatibility":
			out.Values[i] = ec._UserRoles_editAnyModCompatibility(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSessionImplementors = []string{"UserSession"}

func (ec *executionContext) _UserSession(ctx context.Context, sel ast.SelectionSet, obj *UserSession) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSessionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSession")
		case "token":
			out.Values[i] = ec._UserSession_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionImplementors = []string{"Version"}

func (ec *executionContext) _Version(ctx context.Context, sel ast.SelectionSet, obj *Version) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Version")
		case "id":
			out.Values[i] = ec._Version_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mod_id":
			out.Values[i] = ec._Version_mod_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._Version_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sml_version":
			out.Values[i] = ec._Version_sml_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "changelog":
			out.Values[i] = ec._Version_changelog(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "downloads":
			out.Values[i] = ec._Version_downloads(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stability":
			out.Values[i] = ec._Version_stability(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "approved":
			out.Values[i] = ec._Version_approved(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updated_at":
			out.Values[i] = ec._Version_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "created_at":
			out.Values[i] = ec._Version_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "link":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_link(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "targets":
			out.Values[i] = ec._Version_targets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "metadata":
			out.Values[i] = ec._Version_metadata(ctx, field, obj)
		case "size":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_size(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hash":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_hash(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "mod":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_mod(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dependencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_dependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionDependencyImplementors = []string{"VersionDependency"}

func (ec *executionContext) _VersionDependency(ctx context.Context, sel ast.SelectionSet, obj *VersionDependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionDependencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionDependency")
		case "version_id":
			out.Values[i] = ec._VersionDependency_version_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mod_id":
			out.Values[i] = ec._VersionDependency_mod_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "condition":
			out.Values[i] = ec._VersionDependency_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "optional":
			out.Values[i] = ec._VersionDependency_optional(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mod":
			out.Values[i] = ec._VersionDependency_mod(ctx, field, obj)
		case "version":
			out.Values[i] = ec._VersionDependency_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionTargetImplementors = []string{"VersionTarget"}

func (ec *executionContext) _VersionTarget(ctx context.Context, sel ast.SelectionSet, obj *VersionTarget) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionTargetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionTarget")
		case "VersionID":
			out.Values[i] = ec._VersionTarget_VersionID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetName":
			out.Values[i] = ec._VersionTarget_targetName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "link":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._VersionTarget_link(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "size":
			out.Values[i] = ec._VersionTarget_size(ctx, field, obj)
		case "hash":
			out.Values[i] = ec._VersionTarget_hash(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedAnnouncement(ctx context.Context, sel ast.SelectionSet, v Announcement) graphql.Marshaler {
	return ec._Announcement(ctx, sel, &v)
}

func (ec *executionContext) marshalNAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedAnnouncement(ctx context.Context, sel ast.SelectionSet, v []*Announcement) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedAnnouncement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedAnnouncement(ctx context.Context, sel ast.SelectionSet, v *Announcement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Announcement(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAnnouncementID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAnnouncementID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNAnnouncementImportance2githubcomsatisfactorymoddingsmrapigeneratedAnnouncementImportance(ctx context.Context, v interface{}) (AnnouncementImportance, error) {
	var res AnnouncementImportance
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAnnouncementImportance2githubcomsatisfactorymoddingsmrapigeneratedAnnouncementImportance(ctx context.Context, sel ast.SelectionSet, v AnnouncementImportance) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCompatibility2githubcomsatisfactorymoddingsmrapigeneratedCompatibility(ctx context.Context, sel ast.SelectionSet, v *Compatibility) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Compatibility(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCompatibilityInfoInput2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityInfoInput(ctx context.Context, v interface{}) (CompatibilityInfoInput, error) {
	res, err := ec.unmarshalInputCompatibilityInfoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCompatibilityInput2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityInput(ctx context.Context, v interface{}) (*CompatibilityInput, error) {
	res, err := ec.unmarshalInputCompatibilityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCompatibilityState2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityState(ctx context.Context, v interface{}) (CompatibilityState, error) {
	var res CompatibilityState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCompatibilityState2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityState(ctx context.Context, sel ast.SelectionSet, v CompatibilityState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDate2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNGetGuides2githubcomsatisfactorymoddingsmrapigeneratedGetGuides(ctx context.Context, sel ast.SelectionSet, v GetGuides) graphql.Marshaler {
	return ec._GetGuides(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetGuides2githubcomsatisfactorymoddingsmrapigeneratedGetGuides(ctx context.Context, sel ast.SelectionSet, v *GetGuides) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetGuides(ctx, sel, v)
}

func (ec *executionContext) marshalNGetMods2githubcomsatisfactorymoddingsmrapigeneratedGetMods(ctx context.Context, sel ast.SelectionSet, v GetMods) graphql.Marshaler {
	return ec._GetMods(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMods2githubcomsatisfactorymoddingsmrapigeneratedGetMods(ctx context.Context, sel ast.SelectionSet, v *GetMods) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMods(ctx, sel, v)
}

func (ec *executionContext) marshalNGetMyMods2githubcomsatisfactorymoddingsmrapigeneratedGetMyMods(ctx context.Context, sel ast.SelectionSet, v GetMyMods) graphql.Marshaler {
	return ec._GetMyMods(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMyMods2githubcomsatisfactorymoddingsmrapigeneratedGetMyMods(ctx context.Context, sel ast.SelectionSet, v *GetMyMods) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMyMods(ctx, sel, v)
}

func (ec *executionContext) marshalNGetMyVersions2githubcomsatisfactorymoddingsmrapigeneratedGetMyVersions(ctx context.Context, sel ast.SelectionSet, v GetMyVersions) graphql.Marshaler {
	return ec._GetMyVersions(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetMyVersions2githubcomsatisfactorymoddingsmrapigeneratedGetMyVersions(ctx context.Context, sel ast.SelectionSet, v *GetMyVersions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetMyVersions(ctx, sel, v)
}

func (ec *executionContext) marshalNGetSMLVersions2githubcomsatisfactorymoddingsmrapigeneratedGetSMLVersions(ctx context.Context, sel ast.SelectionSet, v GetSMLVersions) graphql.Marshaler {
	return ec._GetSMLVersions(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetSMLVersions2githubcomsatisfactorymoddingsmrapigeneratedGetSMLVersions(ctx context.Context, sel ast.SelectionSet, v *GetSMLVersions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetSMLVersions(ctx, sel, v)
}

func (ec *executionContext) marshalNGetVersions2githubcomsatisfactorymoddingsmrapigeneratedGetVersions(ctx context.Context, sel ast.SelectionSet, v GetVersions) graphql.Marshaler {
	return ec._GetVersions(ctx, sel, &v)
}

func (ec *executionContext) marshalNGetVersions2githubcomsatisfactorymoddingsmrapigeneratedGetVersions(ctx context.Context, sel ast.SelectionSet, v *GetVersions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GetVersions(ctx, sel, v)
}

func (ec *executionContext) marshalNGroup2githubcomsatisfactorymoddingsmrapigeneratedGroup(ctx context.Context, sel ast.SelectionSet, v []*Group) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroup2githubcomsatisfactorymoddingsmrapigeneratedGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGroup2githubcomsatisfactorymoddingsmrapigeneratedGroup(ctx context.Context, sel ast.SelectionSet, v *Group) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Group(ctx, sel, v)
}

func (ec *executionContext) marshalNGuide2githubcomsatisfactorymoddingsmrapigeneratedGuide(ctx context.Context, sel ast.SelectionSet, v Guide) graphql.Marshaler {
	return ec._Guide(ctx, sel, &v)
}

func (ec *executionContext) marshalNGuide2githubcomsatisfactorymoddingsmrapigeneratedGuide(ctx context.Context, sel ast.SelectionSet, v []*Guide) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGuide2githubcomsatisfactorymoddingsmrapigeneratedGuide(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGuide2githubcomsatisfactorymoddingsmrapigeneratedGuide(ctx context.Context, sel ast.SelectionSet, v *Guide) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Guide(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGuideID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGuideID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLatestVersions2githubcomsatisfactorymoddingsmrapigeneratedLatestVersions(ctx context.Context, sel ast.SelectionSet, v LatestVersions) graphql.Marshaler {
	return ec._LatestVersions(ctx, sel, &v)
}

func (ec *executionContext) marshalNLatestVersions2githubcomsatisfactorymoddingsmrapigeneratedLatestVersions(ctx context.Context, sel ast.SelectionSet, v *LatestVersions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LatestVersions(ctx, sel, v)
}

func (ec *executionContext) marshalNMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx context.Context, sel ast.SelectionSet, v Mod) graphql.Marshaler {
	return ec._Mod(ctx, sel, &v)
}

func (ec *executionContext) marshalNMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx context.Context, sel ast.SelectionSet, v []*Mod) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx context.Context, sel ast.SelectionSet, v *Mod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Mod(ctx, sel, v)
}

func (ec *executionContext) unmarshalNModID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNModID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNModID2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNModID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNModID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNModID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNModReference2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNModReference2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNModVersion2githubcomsatisfactorymoddingsmrapigeneratedModVersion(ctx context.Context, sel ast.SelectionSet, v []*ModVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNModVersion2githubcomsatisfactorymoddingsmrapigeneratedModVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNModVersion2githubcomsatisfactorymoddingsmrapigeneratedModVersion(ctx context.Context, sel ast.SelectionSet, v *ModVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ModVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNModVersionConstraint2githubcomsatisfactorymoddingsmrapigeneratedModVersionConstraint(ctx context.Context, v interface{}) ([]*ModVersionConstraint, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ModVersionConstraint, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNModVersionConstraint2githubcomsatisfactorymoddingsmrapigeneratedModVersionConstraint(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNModVersionConstraint2githubcomsatisfactorymoddingsmrapigeneratedModVersionConstraint(ctx context.Context, v interface{}) (*ModVersionConstraint, error) {
	res, err := ec.unmarshalInputModVersionConstraint(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedNewAnnouncement(ctx context.Context, v interface{}) (NewAnnouncement, error) {
	res, err := ec.unmarshalInputNewAnnouncement(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewGuide2githubcomsatisfactorymoddingsmrapigeneratedNewGuide(ctx context.Context, v interface{}) (NewGuide, error) {
	res, err := ec.unmarshalInputNewGuide(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewMod2githubcomsatisfactorymoddingsmrapigeneratedNewMod(ctx context.Context, v interface{}) (NewMod, error) {
	res, err := ec.unmarshalInputNewMod(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedNewSMLVersion(ctx context.Context, v interface{}) (NewSMLVersion, error) {
	res, err := ec.unmarshalInputNewSMLVersion(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewSMLVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedNewSMLVersionTarget(ctx context.Context, v interface{}) ([]*NewSMLVersionTarget, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*NewSMLVersionTarget, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNewSMLVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedNewSMLVersionTarget(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNNewSMLVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedNewSMLVersionTarget(ctx context.Context, v interface{}) (*NewSMLVersionTarget, error) {
	res, err := ec.unmarshalInputNewSMLVersionTarget(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNNewVersion2githubcomsatisfactorymoddingsmrapigeneratedNewVersion(ctx context.Context, v interface{}) (NewVersion, error) {
	res, err := ec.unmarshalInputNewVersion(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOAuthOptions2githubcomsatisfactorymoddingsmrapigeneratedOAuthOptions(ctx context.Context, sel ast.SelectionSet, v OAuthOptions) graphql.Marshaler {
	return ec._OAuthOptions(ctx, sel, &v)
}

func (ec *executionContext) marshalNOAuthOptions2githubcomsatisfactorymoddingsmrapigeneratedOAuthOptions(ctx context.Context, sel ast.SelectionSet, v *OAuthOptions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OAuthOptions(ctx, sel, v)
}

func (ec *executionContext) marshalNSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedSMLVersion(ctx context.Context, sel ast.SelectionSet, v SMLVersion) graphql.Marshaler {
	return ec._SMLVersion(ctx, sel, &v)
}

func (ec *executionContext) marshalNSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedSMLVersion(ctx context.Context, sel ast.SelectionSet, v []*SMLVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedSMLVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedSMLVersion(ctx context.Context, sel ast.SelectionSet, v *SMLVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SMLVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSMLVersionID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSMLVersionID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNSMLVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedSMLVersionTarget(ctx context.Context, sel ast.SelectionSet, v []*SMLVersionTarget) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSMLVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedSMLVersionTarget(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx context.Context, sel ast.SelectionSet, v Tag) graphql.Marshaler {
	return ec._Tag(ctx, sel, &v)
}

func (ec *executionContext) marshalNTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx context.Context, sel ast.SelectionSet, v []*Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx context.Context, sel ast.SelectionSet, v *Tag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTagID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTagName2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagName2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTagName2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTagName2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNTagName2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTagName2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTargetName2githubcomsatisfactorymoddingsmrapigeneratedTargetName(ctx context.Context, v interface{}) (TargetName, error) {
	var res TargetName
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTargetName2githubcomsatisfactorymoddingsmrapigeneratedTargetName(ctx context.Context, sel ast.SelectionSet, v TargetName) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUpdateAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedUpdateAnnouncement(ctx context.Context, v interface{}) (UpdateAnnouncement, error) {
	res, err := ec.unmarshalInputUpdateAnnouncement(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateGuide2githubcomsatisfactorymoddingsmrapigeneratedUpdateGuide(ctx context.Context, v interface{}) (UpdateGuide, error) {
	res, err := ec.unmarshalInputUpdateGuide(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateMod2githubcomsatisfactorymoddingsmrapigeneratedUpdateMod(ctx context.Context, v interface{}) (UpdateMod, error) {
	res, err := ec.unmarshalInputUpdateMod(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedUpdateSMLVersion(ctx context.Context, v interface{}) (UpdateSMLVersion, error) {
	res, err := ec.unmarshalInputUpdateSMLVersion(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSMLVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedUpdateSMLVersionTarget(ctx context.Context, v interface{}) ([]*UpdateSMLVersionTarget, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*UpdateSMLVersionTarget, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOUpdateSMLVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedUpdateSMLVersionTarget(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNUpdateUser2githubcomsatisfactorymoddingsmrapigeneratedUpdateUser(ctx context.Context, v interface{}) (UpdateUser, error) {
	res, err := ec.unmarshalInputUpdateUser(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserMod2githubcomsatisfactorymoddingsmrapigeneratedUpdateUserMod(ctx context.Context, v interface{}) (UpdateUserMod, error) {
	res, err := ec.unmarshalInputUpdateUserMod(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateVersion2githubcomsatisfactorymoddingsmrapigeneratedUpdateVersion(ctx context.Context, v interface{}) (UpdateVersion, error) {
	res, err := ec.unmarshalInputUpdateVersion(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpload2githubcom99designsgqlgengraphqlUpload(ctx context.Context, v interface{}) (graphql.Upload, error) {
	res, err := graphql.UnmarshalUpload(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpload2githubcom99designsgqlgengraphqlUpload(ctx context.Context, sel ast.SelectionSet, v graphql.Upload) graphql.Marshaler {
	res := graphql.MarshalUpload(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2githubcomsatisfactorymoddingsmrapigeneratedUser(ctx context.Context, sel ast.SelectionSet, v User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcomsatisfactorymoddingsmrapigeneratedUser(ctx context.Context, sel ast.SelectionSet, v []*User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2githubcomsatisfactorymoddingsmrapigeneratedUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNUser2githubcomsatisfactorymoddingsmrapigeneratedUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUserID2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNUserID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNUserID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserMod2githubcomsatisfactorymoddingsmrapigeneratedUserMod(ctx context.Context, sel ast.SelectionSet, v []*UserMod) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserMod2githubcomsatisfactorymoddingsmrapigeneratedUserMod(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserMod2githubcomsatisfactorymoddingsmrapigeneratedUserMod(ctx context.Context, sel ast.SelectionSet, v *UserMod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserMod(ctx, sel, v)
}

func (ec *executionContext) marshalNUserRoles2githubcomsatisfactorymoddingsmrapigeneratedUserRoles(ctx context.Context, sel ast.SelectionSet, v UserRoles) graphql.Marshaler {
	return ec._UserRoles(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserRoles2githubcomsatisfactorymoddingsmrapigeneratedUserRoles(ctx context.Context, sel ast.SelectionSet, v *UserRoles) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserRoles(ctx, sel, v)
}

func (ec *executionContext) marshalNVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx context.Context, sel ast.SelectionSet, v Version) graphql.Marshaler {
	return ec._Version(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx context.Context, sel ast.SelectionSet, v []*Version) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx context.Context, sel ast.SelectionSet, v *Version) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalNVersionDependency2githubcomsatisfactorymoddingsmrapigeneratedVersionDependency(ctx context.Context, sel ast.SelectionSet, v []*VersionDependency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersionDependency2githubcomsatisfactorymoddingsmrapigeneratedVersionDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVersionDependency2githubcomsatisfactorymoddingsmrapigeneratedVersionDependency(ctx context.Context, sel ast.SelectionSet, v *VersionDependency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VersionDependency(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVersionID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersionID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNVersionStabilities2githubcomsatisfactorymoddingsmrapigeneratedVersionStabilities(ctx context.Context, v interface{}) (VersionStabilities, error) {
	var res VersionStabilities
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersionStabilities2githubcomsatisfactorymoddingsmrapigeneratedVersionStabilities(ctx context.Context, sel ast.SelectionSet, v VersionStabilities) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedVersionTarget(ctx context.Context, sel ast.SelectionSet, v []*VersionTarget) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedVersionTarget(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAnnouncement2githubcomsatisfactorymoddingsmrapigeneratedAnnouncement(ctx context.Context, sel ast.SelectionSet, v *Announcement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Announcement(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAnnouncementImportance2githubcomsatisfactorymoddingsmrapigeneratedAnnouncementImportance(ctx context.Context, v interface{}) (*AnnouncementImportance, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(AnnouncementImportance)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAnnouncementImportance2githubcomsatisfactorymoddingsmrapigeneratedAnnouncementImportance(ctx context.Context, sel ast.SelectionSet, v *AnnouncementImportance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCompatibilityInfo2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityInfo(ctx context.Context, sel ast.SelectionSet, v *CompatibilityInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CompatibilityInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCompatibilityInfoInput2githubcomsatisfactorymoddingsmrapigeneratedCompatibilityInfoInput(ctx context.Context, v interface{}) (*CompatibilityInfoInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCompatibilityInfoInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCreateVersionResponse2githubcomsatisfactorymoddingsmrapigeneratedCreateVersionResponse(ctx context.Context, sel ast.SelectionSet, v *CreateVersionResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CreateVersionResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalODate2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODate2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOGuide2githubcomsatisfactorymoddingsmrapigeneratedGuide(ctx context.Context, sel ast.SelectionSet, v *Guide) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Guide(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGuideFields2githubcomsatisfactorymoddingsmrapigeneratedGuideFields(ctx context.Context, v interface{}) (*GuideFields, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(GuideFields)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGuideFields2githubcomsatisfactorymoddingsmrapigeneratedGuideFields(ctx context.Context, sel ast.SelectionSet, v *GuideFields) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOGuideFilter2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	return v.(map[string]interface{}), nil
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOMod2githubcomsatisfactorymoddingsmrapigeneratedMod(ctx context.Context, sel ast.SelectionSet, v *Mod) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Mod(ctx, sel, v)
}

func (ec *executionContext) unmarshalOModFields2githubcomsatisfactorymoddingsmrapigeneratedModFields(ctx context.Context, v interface{}) (*ModFields, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ModFields)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOModFields2githubcomsatisfactorymoddingsmrapigeneratedModFields(ctx context.Context, sel ast.SelectionSet, v *ModFields) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOModFilter2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	return v.(map[string]interface{}), nil
}

func (ec *executionContext) unmarshalOModReference2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOModReference2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOOrder2githubcomsatisfactorymoddingsmrapigeneratedOrder(ctx context.Context, v interface{}) (*Order, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(Order)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrder2githubcomsatisfactorymoddingsmrapigeneratedOrder(ctx context.Context, sel ast.SelectionSet, v *Order) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOSMLVersion2githubcomsatisfactorymoddingsmrapigeneratedSMLVersion(ctx context.Context, sel ast.SelectionSet, v *SMLVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SMLVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSMLVersionFields2githubcomsatisfactorymoddingsmrapigeneratedSMLVersionFields(ctx context.Context, v interface{}) (*SMLVersionFields, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(SMLVersionFields)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSMLVersionFields2githubcomsatisfactorymoddingsmrapigeneratedSMLVersionFields(ctx context.Context, sel ast.SelectionSet, v *SMLVersionFields) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSMLVersionFilter2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	return v.(map[string]interface{}), nil
}

func (ec *executionContext) marshalOSMLVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedSMLVersionTarget(ctx context.Context, sel ast.SelectionSet, v *SMLVersionTarget) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SMLVersionTarget(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx context.Context, sel ast.SelectionSet, v []*Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTag2githubcomsatisfactorymoddingsmrapigeneratedTag(ctx context.Context, sel ast.SelectionSet, v *Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTagFilter2githubcomsatisfactorymoddingsmrapigeneratedTagFilter(ctx context.Context, v interface{}) (*TagFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTagFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTagID2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTagID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTagID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTagID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUpdateSMLVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedUpdateSMLVersionTarget(ctx context.Context, v interface{}) (*UpdateSMLVersionTarget, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateSMLVersionTarget(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpdateUserMod2githubcomsatisfactorymoddingsmrapigeneratedUpdateUserMod(ctx context.Context, v interface{}) ([]UpdateUserMod, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]UpdateUserMod, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUpdateUserMod2githubcomsatisfactorymoddingsmrapigeneratedUpdateUserMod(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx context.Context, v interface{}) (*graphql.Upload, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUpload(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx context.Context, sel ast.SelectionSet, v *graphql.Upload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalUpload(*v)
	return res
}

func (ec *executionContext) marshalOUser2githubcomsatisfactorymoddingsmrapigeneratedUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalOUserSession2githubcomsatisfactorymoddingsmrapigeneratedUserSession(ctx context.Context, sel ast.SelectionSet, v *UserSession) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserSession(ctx, sel, v)
}

func (ec *executionContext) marshalOVersion2githubcomsatisfactorymoddingsmrapigeneratedVersion(ctx context.Context, sel ast.SelectionSet, v *Version) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) unmarshalOVersionFields2githubcomsatisfactorymoddingsmrapigeneratedVersionFields(ctx context.Context, v interface{}) (*VersionFields, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(VersionFields)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersionFields2githubcomsatisfactorymoddingsmrapigeneratedVersionFields(ctx context.Context, sel ast.SelectionSet, v *VersionFields) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOVersionFilter2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	return v.(map[string]interface{}), nil
}

func (ec *executionContext) unmarshalOVersionStabilities2githubcomsatisfactorymoddingsmrapigeneratedVersionStabilities(ctx context.Context, v interface{}) (*VersionStabilities, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(VersionStabilities)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersionStabilities2githubcomsatisfactorymoddingsmrapigeneratedVersionStabilities(ctx context.Context, sel ast.SelectionSet, v *VersionStabilities) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOVersionTarget2githubcomsatisfactorymoddingsmrapigeneratedVersionTarget(ctx context.Context, sel ast.SelectionSet, v *VersionTarget) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VersionTarget(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************

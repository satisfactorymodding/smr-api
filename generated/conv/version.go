// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package conv

import (
	conversion "github.com/satisfactorymodding/smr-api/conversion"
	generated "github.com/satisfactorymodding/smr-api/generated"
	ent "github.com/satisfactorymodding/smr-api/generated/ent"
	types "github.com/satisfactorymodding/smr-api/nodes/types"
)

type ModAllVersionsImpl struct{}

func (c *ModAllVersionsImpl) Convert(source *ent.Version) *types.ModAllVersionsVersion {
	var pTypesModAllVersionsVersion *types.ModAllVersionsVersion
	if source != nil {
		var typesModAllVersionsVersion types.ModAllVersionsVersion
		typesModAllVersionsVersion.ID = (*source).ID
		typesModAllVersionsVersion.Version = (*source).Version
		typesModAllVersionsVersion.GameVersion = (*source).GameVersion
		var pTypesModAllVersionsVersionTargetList []*types.ModAllVersionsVersionTarget
		if (*source).Edges.Targets != nil {
			pTypesModAllVersionsVersionTargetList = make([]*types.ModAllVersionsVersionTarget, len((*source).Edges.Targets))
			for i := 0; i < len((*source).Edges.Targets); i++ {
				pTypesModAllVersionsVersionTargetList[i] = c.pEntVersionTargetToPTypesModAllVersionsVersionTarget((*source).Edges.Targets[i])
			}
		}
		typesModAllVersionsVersion.Targets = pTypesModAllVersionsVersionTargetList
		var pTypesModAllVersionsVersionDependencyList []*types.ModAllVersionsVersionDependency
		if (*source).Edges.VersionDependencies != nil {
			pTypesModAllVersionsVersionDependencyList = make([]*types.ModAllVersionsVersionDependency, len((*source).Edges.VersionDependencies))
			for j := 0; j < len((*source).Edges.VersionDependencies); j++ {
				pTypesModAllVersionsVersionDependencyList[j] = c.pEntVersionDependencyToPTypesModAllVersionsVersionDependency((*source).Edges.VersionDependencies[j])
			}
		}
		typesModAllVersionsVersion.Dependencies = pTypesModAllVersionsVersionDependencyList
		pTypesModAllVersionsVersion = &typesModAllVersionsVersion
	}
	return pTypesModAllVersionsVersion
}
func (c *ModAllVersionsImpl) ConvertSlice(source []*ent.Version) []*types.ModAllVersionsVersion {
	var pTypesModAllVersionsVersionList []*types.ModAllVersionsVersion
	if source != nil {
		pTypesModAllVersionsVersionList = make([]*types.ModAllVersionsVersion, len(source))
		for i := 0; i < len(source); i++ {
			pTypesModAllVersionsVersionList[i] = c.Convert(source[i])
		}
	}
	return pTypesModAllVersionsVersionList
}
func (c *ModAllVersionsImpl) pEntVersionDependencyToPTypesModAllVersionsVersionDependency(source *ent.VersionDependency) *types.ModAllVersionsVersionDependency {
	var pTypesModAllVersionsVersionDependency *types.ModAllVersionsVersionDependency
	if source != nil {
		var typesModAllVersionsVersionDependency types.ModAllVersionsVersionDependency
		typesModAllVersionsVersionDependency.ModID = (*source).ModID
		typesModAllVersionsVersionDependency.Condition = (*source).Condition
		typesModAllVersionsVersionDependency.Optional = (*source).Optional
		pTypesModAllVersionsVersionDependency = &typesModAllVersionsVersionDependency
	}
	return pTypesModAllVersionsVersionDependency
}
func (c *ModAllVersionsImpl) pEntVersionTargetToPTypesModAllVersionsVersionTarget(source *ent.VersionTarget) *types.ModAllVersionsVersionTarget {
	var pTypesModAllVersionsVersionTarget *types.ModAllVersionsVersionTarget
	if source != nil {
		var typesModAllVersionsVersionTarget types.ModAllVersionsVersionTarget
		typesModAllVersionsVersionTarget.VersionID = (*source).VersionID
		typesModAllVersionsVersionTarget.TargetName = (*source).TargetName
		typesModAllVersionsVersionTarget.Hash = (*source).Hash
		typesModAllVersionsVersionTarget.Size = conversion.Int64ToInt((*source).Size)
		pTypesModAllVersionsVersionTarget = &typesModAllVersionsVersionTarget
	}
	return pTypesModAllVersionsVersionTarget
}

type VersionImpl struct{}

func (c *VersionImpl) Convert(source *ent.Version) *generated.Version {
	var pGeneratedVersion *generated.Version
	if source != nil {
		var generatedVersion generated.Version
		generatedVersion.ID = (*source).ID
		generatedVersion.ModID = (*source).ModID
		generatedVersion.Version = (*source).Version
		generatedVersion.GameVersion = (*source).GameVersion
		generatedVersion.Changelog = (*source).Changelog
		generatedVersion.Downloads = conversion.UIntToInt((*source).Downloads)
		generatedVersion.Stability = generated.VersionStabilities((*source).Stability)
		generatedVersion.Approved = (*source).Approved
		generatedVersion.UpdatedAt = conversion.TimeToString((*source).UpdatedAt)
		generatedVersion.CreatedAt = conversion.TimeToString((*source).CreatedAt)
		var pGeneratedVersionTargetList []*generated.VersionTarget
		if (*source).Edges.Targets != nil {
			pGeneratedVersionTargetList = make([]*generated.VersionTarget, len((*source).Edges.Targets))
			for i := 0; i < len((*source).Edges.Targets); i++ {
				pGeneratedVersionTargetList[i] = c.ConvertTarget((*source).Edges.Targets[i])
			}
		}
		generatedVersion.Targets = pGeneratedVersionTargetList
		pString := (*source).Metadata
		generatedVersion.Metadata = &pString
		pInt := conversion.Int64ToInt((*source).Size)
		generatedVersion.Size = &pInt
		pString2 := (*source).Hash
		generatedVersion.Hash = &pString2
		pGeneratedVersion = &generatedVersion
	}
	return pGeneratedVersion
}
func (c *VersionImpl) ConvertSlice(source []*ent.Version) []*generated.Version {
	var pGeneratedVersionList []*generated.Version
	if source != nil {
		pGeneratedVersionList = make([]*generated.Version, len(source))
		for i := 0; i < len(source); i++ {
			pGeneratedVersionList[i] = c.Convert(source[i])
		}
	}
	return pGeneratedVersionList
}
func (c *VersionImpl) ConvertTarget(source *ent.VersionTarget) *generated.VersionTarget {
	var pGeneratedVersionTarget *generated.VersionTarget
	if source != nil {
		var generatedVersionTarget generated.VersionTarget
		generatedVersionTarget.VersionID = (*source).VersionID
		generatedVersionTarget.TargetName = generated.TargetName((*source).TargetName)
		pInt := conversion.Int64ToInt((*source).Size)
		generatedVersionTarget.Size = &pInt
		pString := (*source).Hash
		generatedVersionTarget.Hash = &pString
		pGeneratedVersionTarget = &generatedVersionTarget
	}
	return pGeneratedVersionTarget
}

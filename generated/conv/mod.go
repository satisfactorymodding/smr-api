// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.

package conv

import (
	conversion "github.com/satisfactorymodding/smr-api/conversion"
	generated "github.com/satisfactorymodding/smr-api/generated"
	ent "github.com/satisfactorymodding/smr-api/generated/ent"
	util "github.com/satisfactorymodding/smr-api/util"
	"time"
)

type ModImpl struct{}

func (c *ModImpl) Convert(source *ent.Mod) *generated.Mod {
	var pGeneratedMod *generated.Mod
	if source != nil {
		var generatedMod generated.Mod
		generatedMod.ID = (*source).ID
		generatedMod.Name = (*source).Name
		generatedMod.ShortDescription = (*source).ShortDescription
		pString := (*source).FullDescription
		generatedMod.FullDescription = &pString
		pString2 := (*source).Logo
		generatedMod.Logo = &pString2
		pString3 := (*source).SourceURL
		generatedMod.SourceURL = &pString3
		generatedMod.CreatorID = (*source).CreatorID
		generatedMod.Approved = (*source).Approved
		generatedMod.Views = conversion.UIntToInt((*source).Views)
		generatedMod.Downloads = conversion.UIntToInt((*source).Downloads)
		generatedMod.Hotness = conversion.UIntToInt((*source).Hotness)
		generatedMod.Popularity = conversion.UIntToInt((*source).Popularity)
		generatedMod.UpdatedAt = conversion.TimeToString((*source).UpdatedAt)
		generatedMod.CreatedAt = conversion.TimeToString((*source).CreatedAt)
		generatedMod.LastVersionDate = c.timeTimeToPString((*source).LastVersionDate)
		generatedMod.ModReference = (*source).ModReference
		generatedMod.Hidden = (*source).Hidden
		var pGeneratedTagList []*generated.Tag
		if (*source).Edges.Tags != nil {
			pGeneratedTagList = make([]*generated.Tag, len((*source).Edges.Tags))
			for i := 0; i < len((*source).Edges.Tags); i++ {
				pGeneratedTagList[i] = c.pEntTagToPGeneratedTag((*source).Edges.Tags[i])
			}
		}
		generatedMod.Tags = pGeneratedTagList
		generatedMod.Compatibility = c.pUtilCompatibilityInfoToPGeneratedCompatibilityInfo((*source).Compatibility)
		pGeneratedMod = &generatedMod
	}
	return pGeneratedMod
}
func (c *ModImpl) ConvertSlice(source []*ent.Mod) []*generated.Mod {
	var pGeneratedModList []*generated.Mod
	if source != nil {
		pGeneratedModList = make([]*generated.Mod, len(source))
		for i := 0; i < len(source); i++ {
			pGeneratedModList[i] = c.Convert(source[i])
		}
	}
	return pGeneratedModList
}
func (c *ModImpl) pEntTagToPGeneratedTag(source *ent.Tag) *generated.Tag {
	var pGeneratedTag *generated.Tag
	if source != nil {
		var generatedTag generated.Tag
		generatedTag.ID = (*source).ID
		generatedTag.Name = (*source).Name
		pGeneratedTag = &generatedTag
	}
	return pGeneratedTag
}
func (c *ModImpl) pUtilCompatibilityInfoToPGeneratedCompatibilityInfo(source *util.CompatibilityInfo) *generated.CompatibilityInfo {
	var pGeneratedCompatibilityInfo *generated.CompatibilityInfo
	if source != nil {
		var generatedCompatibilityInfo generated.CompatibilityInfo
		generatedCompatibilityInfo.Ea = c.utilCompatibilityToPGeneratedCompatibility((*source).Ea)
		generatedCompatibilityInfo.Exp = c.utilCompatibilityToPGeneratedCompatibility((*source).Exp)
		pGeneratedCompatibilityInfo = &generatedCompatibilityInfo
	}
	return pGeneratedCompatibilityInfo
}
func (c *ModImpl) timeTimeToPString(source time.Time) *string {
	xstring := conversion.TimeToString(source)
	return &xstring
}
func (c *ModImpl) utilCompatibilityToGeneratedCompatibility(source util.Compatibility) generated.Compatibility {
	var generatedCompatibility generated.Compatibility
	generatedCompatibility.State = generated.CompatibilityState(source.State)
	pString := source.Note
	generatedCompatibility.Note = &pString
	return generatedCompatibility
}
func (c *ModImpl) utilCompatibilityToPGeneratedCompatibility(source util.Compatibility) *generated.Compatibility {
	generatedCompatibility := c.utilCompatibilityToGeneratedCompatibility(source)
	return &generatedCompatibility
}

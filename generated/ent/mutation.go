// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/satisfactorymodding/smr-api/generated/ent/announcement"
	"github.com/satisfactorymodding/smr-api/generated/ent/guide"
	"github.com/satisfactorymodding/smr-api/generated/ent/guidetag"
	"github.com/satisfactorymodding/smr-api/generated/ent/mod"
	"github.com/satisfactorymodding/smr-api/generated/ent/modtag"
	"github.com/satisfactorymodding/smr-api/generated/ent/predicate"
	"github.com/satisfactorymodding/smr-api/generated/ent/satisfactoryversion"
	"github.com/satisfactorymodding/smr-api/generated/ent/tag"
	"github.com/satisfactorymodding/smr-api/generated/ent/user"
	"github.com/satisfactorymodding/smr-api/generated/ent/usergroup"
	"github.com/satisfactorymodding/smr-api/generated/ent/usermod"
	"github.com/satisfactorymodding/smr-api/generated/ent/usersession"
	"github.com/satisfactorymodding/smr-api/generated/ent/version"
	"github.com/satisfactorymodding/smr-api/generated/ent/versiondependency"
	"github.com/satisfactorymodding/smr-api/generated/ent/versiontarget"
	"github.com/satisfactorymodding/smr-api/util"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAnnouncement        = "Announcement"
	TypeGuide               = "Guide"
	TypeGuideTag            = "GuideTag"
	TypeMod                 = "Mod"
	TypeModTag              = "ModTag"
	TypeSatisfactoryVersion = "SatisfactoryVersion"
	TypeTag                 = "Tag"
	TypeUser                = "User"
	TypeUserGroup           = "UserGroup"
	TypeUserMod             = "UserMod"
	TypeUserSession         = "UserSession"
	TypeVersion             = "Version"
	TypeVersionDependency   = "VersionDependency"
	TypeVersionTarget       = "VersionTarget"
)

// AnnouncementMutation represents an operation that mutates the Announcement nodes in the graph.
type AnnouncementMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	message       *string
	importance    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Announcement, error)
	predicates    []predicate.Announcement
}

var _ ent.Mutation = (*AnnouncementMutation)(nil)

// announcementOption allows management of the mutation configuration using functional options.
type announcementOption func(*AnnouncementMutation)

// newAnnouncementMutation creates new mutation for the Announcement entity.
func newAnnouncementMutation(c config, op Op, opts ...announcementOption) *AnnouncementMutation {
	m := &AnnouncementMutation{
		config:        c,
		op:            op,
		typ:           TypeAnnouncement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnnouncementID sets the ID field of the mutation.
func withAnnouncementID(id string) announcementOption {
	return func(m *AnnouncementMutation) {
		var (
			err   error
			once  sync.Once
			value *Announcement
		)
		m.oldValue = func(ctx context.Context) (*Announcement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Announcement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnnouncement sets the old Announcement of the mutation.
func withAnnouncement(node *Announcement) announcementOption {
	return func(m *AnnouncementMutation) {
		m.oldValue = func(context.Context) (*Announcement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnnouncementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnnouncementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Announcement entities.
func (m *AnnouncementMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnnouncementMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnnouncementMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Announcement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AnnouncementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AnnouncementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AnnouncementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AnnouncementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AnnouncementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AnnouncementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AnnouncementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AnnouncementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AnnouncementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[announcement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AnnouncementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[announcement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AnnouncementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, announcement.FieldDeletedAt)
}

// SetMessage sets the "message" field.
func (m *AnnouncementMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *AnnouncementMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *AnnouncementMutation) ResetMessage() {
	m.message = nil
}

// SetImportance sets the "importance" field.
func (m *AnnouncementMutation) SetImportance(s string) {
	m.importance = &s
}

// Importance returns the value of the "importance" field in the mutation.
func (m *AnnouncementMutation) Importance() (r string, exists bool) {
	v := m.importance
	if v == nil {
		return
	}
	return *v, true
}

// OldImportance returns the old "importance" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldImportance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportance: %w", err)
	}
	return oldValue.Importance, nil
}

// ResetImportance resets all changes to the "importance" field.
func (m *AnnouncementMutation) ResetImportance() {
	m.importance = nil
}

// Where appends a list predicates to the AnnouncementMutation builder.
func (m *AnnouncementMutation) Where(ps ...predicate.Announcement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnnouncementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnnouncementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Announcement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnnouncementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnnouncementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Announcement).
func (m *AnnouncementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnnouncementMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, announcement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, announcement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, announcement.FieldDeletedAt)
	}
	if m.message != nil {
		fields = append(fields, announcement.FieldMessage)
	}
	if m.importance != nil {
		fields = append(fields, announcement.FieldImportance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnnouncementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case announcement.FieldCreatedAt:
		return m.CreatedAt()
	case announcement.FieldUpdatedAt:
		return m.UpdatedAt()
	case announcement.FieldDeletedAt:
		return m.DeletedAt()
	case announcement.FieldMessage:
		return m.Message()
	case announcement.FieldImportance:
		return m.Importance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnnouncementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case announcement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case announcement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case announcement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case announcement.FieldMessage:
		return m.OldMessage(ctx)
	case announcement.FieldImportance:
		return m.OldImportance(ctx)
	}
	return nil, fmt.Errorf("unknown Announcement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnouncementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case announcement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case announcement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case announcement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case announcement.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case announcement.FieldImportance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportance(v)
		return nil
	}
	return fmt.Errorf("unknown Announcement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnnouncementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnnouncementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnouncementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Announcement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnnouncementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(announcement.FieldDeletedAt) {
		fields = append(fields, announcement.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnnouncementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnnouncementMutation) ClearField(name string) error {
	switch name {
	case announcement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Announcement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnnouncementMutation) ResetField(name string) error {
	switch name {
	case announcement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case announcement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case announcement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case announcement.FieldMessage:
		m.ResetMessage()
		return nil
	case announcement.FieldImportance:
		m.ResetImportance()
		return nil
	}
	return fmt.Errorf("unknown Announcement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnnouncementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnnouncementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnnouncementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnnouncementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnnouncementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnnouncementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnnouncementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Announcement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnnouncementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Announcement edge %s", name)
}

// GuideMutation represents an operation that mutates the Guide nodes in the graph.
type GuideMutation struct {
	config
	op                Op
	typ               string
	id                *string
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	short_description *string
	guide             *string
	views             *int
	addviews          *int
	clearedFields     map[string]struct{}
	user              *string
	cleareduser       bool
	tags              map[string]struct{}
	removedtags       map[string]struct{}
	clearedtags       bool
	done              bool
	oldValue          func(context.Context) (*Guide, error)
	predicates        []predicate.Guide
}

var _ ent.Mutation = (*GuideMutation)(nil)

// guideOption allows management of the mutation configuration using functional options.
type guideOption func(*GuideMutation)

// newGuideMutation creates new mutation for the Guide entity.
func newGuideMutation(c config, op Op, opts ...guideOption) *GuideMutation {
	m := &GuideMutation{
		config:        c,
		op:            op,
		typ:           TypeGuide,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGuideID sets the ID field of the mutation.
func withGuideID(id string) guideOption {
	return func(m *GuideMutation) {
		var (
			err   error
			once  sync.Once
			value *Guide
		)
		m.oldValue = func(ctx context.Context) (*Guide, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Guide.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGuide sets the old Guide of the mutation.
func withGuide(node *Guide) guideOption {
	return func(m *GuideMutation) {
		m.oldValue = func(context.Context) (*Guide, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GuideMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GuideMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Guide entities.
func (m *GuideMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GuideMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GuideMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Guide.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GuideMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GuideMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GuideMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GuideMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GuideMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GuideMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GuideMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GuideMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GuideMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[guide.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GuideMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[guide.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GuideMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, guide.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *GuideMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GuideMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *GuideMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[guide.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *GuideMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[guide.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GuideMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, guide.FieldUserID)
}

// SetName sets the "name" field.
func (m *GuideMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GuideMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GuideMutation) ResetName() {
	m.name = nil
}

// SetShortDescription sets the "short_description" field.
func (m *GuideMutation) SetShortDescription(s string) {
	m.short_description = &s
}

// ShortDescription returns the value of the "short_description" field in the mutation.
func (m *GuideMutation) ShortDescription() (r string, exists bool) {
	v := m.short_description
	if v == nil {
		return
	}
	return *v, true
}

// OldShortDescription returns the old "short_description" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldShortDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortDescription: %w", err)
	}
	return oldValue.ShortDescription, nil
}

// ResetShortDescription resets all changes to the "short_description" field.
func (m *GuideMutation) ResetShortDescription() {
	m.short_description = nil
}

// SetGuide sets the "guide" field.
func (m *GuideMutation) SetGuide(s string) {
	m.guide = &s
}

// Guide returns the value of the "guide" field in the mutation.
func (m *GuideMutation) Guide() (r string, exists bool) {
	v := m.guide
	if v == nil {
		return
	}
	return *v, true
}

// OldGuide returns the old "guide" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldGuide(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuide is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuide requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuide: %w", err)
	}
	return oldValue.Guide, nil
}

// ResetGuide resets all changes to the "guide" field.
func (m *GuideMutation) ResetGuide() {
	m.guide = nil
}

// SetViews sets the "views" field.
func (m *GuideMutation) SetViews(i int) {
	m.views = &i
	m.addviews = nil
}

// Views returns the value of the "views" field in the mutation.
func (m *GuideMutation) Views() (r int, exists bool) {
	v := m.views
	if v == nil {
		return
	}
	return *v, true
}

// OldViews returns the old "views" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldViews(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViews: %w", err)
	}
	return oldValue.Views, nil
}

// AddViews adds i to the "views" field.
func (m *GuideMutation) AddViews(i int) {
	if m.addviews != nil {
		*m.addviews += i
	} else {
		m.addviews = &i
	}
}

// AddedViews returns the value that was added to the "views" field in this mutation.
func (m *GuideMutation) AddedViews() (r int, exists bool) {
	v := m.addviews
	if v == nil {
		return
	}
	return *v, true
}

// ResetViews resets all changes to the "views" field.
func (m *GuideMutation) ResetViews() {
	m.views = nil
	m.addviews = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *GuideMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[guide.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *GuideMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *GuideMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *GuideMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *GuideMutation) AddTagIDs(ids ...string) {
	if m.tags == nil {
		m.tags = make(map[string]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *GuideMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *GuideMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *GuideMutation) RemoveTagIDs(ids ...string) {
	if m.removedtags == nil {
		m.removedtags = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *GuideMutation) RemovedTagsIDs() (ids []string) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *GuideMutation) TagsIDs() (ids []string) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *GuideMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the GuideMutation builder.
func (m *GuideMutation) Where(ps ...predicate.Guide) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GuideMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GuideMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Guide, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GuideMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GuideMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Guide).
func (m *GuideMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GuideMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, guide.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, guide.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, guide.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, guide.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, guide.FieldName)
	}
	if m.short_description != nil {
		fields = append(fields, guide.FieldShortDescription)
	}
	if m.guide != nil {
		fields = append(fields, guide.FieldGuide)
	}
	if m.views != nil {
		fields = append(fields, guide.FieldViews)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GuideMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case guide.FieldCreatedAt:
		return m.CreatedAt()
	case guide.FieldUpdatedAt:
		return m.UpdatedAt()
	case guide.FieldDeletedAt:
		return m.DeletedAt()
	case guide.FieldUserID:
		return m.UserID()
	case guide.FieldName:
		return m.Name()
	case guide.FieldShortDescription:
		return m.ShortDescription()
	case guide.FieldGuide:
		return m.Guide()
	case guide.FieldViews:
		return m.Views()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GuideMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case guide.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case guide.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case guide.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case guide.FieldUserID:
		return m.OldUserID(ctx)
	case guide.FieldName:
		return m.OldName(ctx)
	case guide.FieldShortDescription:
		return m.OldShortDescription(ctx)
	case guide.FieldGuide:
		return m.OldGuide(ctx)
	case guide.FieldViews:
		return m.OldViews(ctx)
	}
	return nil, fmt.Errorf("unknown Guide field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GuideMutation) SetField(name string, value ent.Value) error {
	switch name {
	case guide.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case guide.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case guide.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case guide.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case guide.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case guide.FieldShortDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortDescription(v)
		return nil
	case guide.FieldGuide:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuide(v)
		return nil
	case guide.FieldViews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViews(v)
		return nil
	}
	return fmt.Errorf("unknown Guide field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GuideMutation) AddedFields() []string {
	var fields []string
	if m.addviews != nil {
		fields = append(fields, guide.FieldViews)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GuideMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case guide.FieldViews:
		return m.AddedViews()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GuideMutation) AddField(name string, value ent.Value) error {
	switch name {
	case guide.FieldViews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViews(v)
		return nil
	}
	return fmt.Errorf("unknown Guide numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GuideMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(guide.FieldDeletedAt) {
		fields = append(fields, guide.FieldDeletedAt)
	}
	if m.FieldCleared(guide.FieldUserID) {
		fields = append(fields, guide.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GuideMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GuideMutation) ClearField(name string) error {
	switch name {
	case guide.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case guide.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Guide nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GuideMutation) ResetField(name string) error {
	switch name {
	case guide.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case guide.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case guide.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case guide.FieldUserID:
		m.ResetUserID()
		return nil
	case guide.FieldName:
		m.ResetName()
		return nil
	case guide.FieldShortDescription:
		m.ResetShortDescription()
		return nil
	case guide.FieldGuide:
		m.ResetGuide()
		return nil
	case guide.FieldViews:
		m.ResetViews()
		return nil
	}
	return fmt.Errorf("unknown Guide field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GuideMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, guide.EdgeUser)
	}
	if m.tags != nil {
		edges = append(edges, guide.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GuideMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case guide.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case guide.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GuideMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtags != nil {
		edges = append(edges, guide.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GuideMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case guide.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GuideMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, guide.EdgeUser)
	}
	if m.clearedtags {
		edges = append(edges, guide.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GuideMutation) EdgeCleared(name string) bool {
	switch name {
	case guide.EdgeUser:
		return m.cleareduser
	case guide.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GuideMutation) ClearEdge(name string) error {
	switch name {
	case guide.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Guide unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GuideMutation) ResetEdge(name string) error {
	switch name {
	case guide.EdgeUser:
		m.ResetUser()
		return nil
	case guide.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Guide edge %s", name)
}

// GuideTagMutation represents an operation that mutates the GuideTag nodes in the graph.
type GuideTagMutation struct {
	config
	op            Op
	typ           string
	clearedFields map[string]struct{}
	guide         *string
	clearedguide  bool
	tag           *string
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*GuideTag, error)
	predicates    []predicate.GuideTag
}

var _ ent.Mutation = (*GuideTagMutation)(nil)

// guidetagOption allows management of the mutation configuration using functional options.
type guidetagOption func(*GuideTagMutation)

// newGuideTagMutation creates new mutation for the GuideTag entity.
func newGuideTagMutation(c config, op Op, opts ...guidetagOption) *GuideTagMutation {
	m := &GuideTagMutation{
		config:        c,
		op:            op,
		typ:           TypeGuideTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GuideTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GuideTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetGuideID sets the "guide_id" field.
func (m *GuideTagMutation) SetGuideID(s string) {
	m.guide = &s
}

// GuideID returns the value of the "guide_id" field in the mutation.
func (m *GuideTagMutation) GuideID() (r string, exists bool) {
	v := m.guide
	if v == nil {
		return
	}
	return *v, true
}

// ResetGuideID resets all changes to the "guide_id" field.
func (m *GuideTagMutation) ResetGuideID() {
	m.guide = nil
}

// SetTagID sets the "tag_id" field.
func (m *GuideTagMutation) SetTagID(s string) {
	m.tag = &s
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *GuideTagMutation) TagID() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *GuideTagMutation) ResetTagID() {
	m.tag = nil
}

// ClearGuide clears the "guide" edge to the Guide entity.
func (m *GuideTagMutation) ClearGuide() {
	m.clearedguide = true
	m.clearedFields[guidetag.FieldGuideID] = struct{}{}
}

// GuideCleared reports if the "guide" edge to the Guide entity was cleared.
func (m *GuideTagMutation) GuideCleared() bool {
	return m.clearedguide
}

// GuideIDs returns the "guide" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GuideID instead. It exists only for internal usage by the builders.
func (m *GuideTagMutation) GuideIDs() (ids []string) {
	if id := m.guide; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGuide resets all changes to the "guide" edge.
func (m *GuideTagMutation) ResetGuide() {
	m.guide = nil
	m.clearedguide = false
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *GuideTagMutation) ClearTag() {
	m.clearedtag = true
	m.clearedFields[guidetag.FieldTagID] = struct{}{}
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *GuideTagMutation) TagCleared() bool {
	return m.clearedtag
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *GuideTagMutation) TagIDs() (ids []string) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *GuideTagMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// Where appends a list predicates to the GuideTagMutation builder.
func (m *GuideTagMutation) Where(ps ...predicate.GuideTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GuideTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GuideTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GuideTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GuideTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GuideTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GuideTag).
func (m *GuideTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GuideTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.guide != nil {
		fields = append(fields, guidetag.FieldGuideID)
	}
	if m.tag != nil {
		fields = append(fields, guidetag.FieldTagID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GuideTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case guidetag.FieldGuideID:
		return m.GuideID()
	case guidetag.FieldTagID:
		return m.TagID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GuideTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema GuideTag does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GuideTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case guidetag.FieldGuideID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuideID(v)
		return nil
	case guidetag.FieldTagID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	}
	return fmt.Errorf("unknown GuideTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GuideTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GuideTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GuideTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GuideTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GuideTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GuideTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GuideTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GuideTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GuideTagMutation) ResetField(name string) error {
	switch name {
	case guidetag.FieldGuideID:
		m.ResetGuideID()
		return nil
	case guidetag.FieldTagID:
		m.ResetTagID()
		return nil
	}
	return fmt.Errorf("unknown GuideTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GuideTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.guide != nil {
		edges = append(edges, guidetag.EdgeGuide)
	}
	if m.tag != nil {
		edges = append(edges, guidetag.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GuideTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case guidetag.EdgeGuide:
		if id := m.guide; id != nil {
			return []ent.Value{*id}
		}
	case guidetag.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GuideTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GuideTagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GuideTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedguide {
		edges = append(edges, guidetag.EdgeGuide)
	}
	if m.clearedtag {
		edges = append(edges, guidetag.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GuideTagMutation) EdgeCleared(name string) bool {
	switch name {
	case guidetag.EdgeGuide:
		return m.clearedguide
	case guidetag.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GuideTagMutation) ClearEdge(name string) error {
	switch name {
	case guidetag.EdgeGuide:
		m.ClearGuide()
		return nil
	case guidetag.EdgeTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown GuideTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GuideTagMutation) ResetEdge(name string) error {
	switch name {
	case guidetag.EdgeGuide:
		m.ResetGuide()
		return nil
	case guidetag.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown GuideTag edge %s", name)
}

// ModMutation represents an operation that mutates the Mod nodes in the graph.
type ModMutation struct {
	config
	op                Op
	typ               string
	id                *string
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	short_description *string
	full_description  *string
	logo              *string
	source_url        *string
	creator_id        *string
	approved          *bool
	views             *uint
	addviews          *int
	hotness           *uint
	addhotness        *int
	popularity        *uint
	addpopularity     *int
	downloads         *uint
	adddownloads      *int
	denied            *bool
	last_version_date *time.Time
	mod_reference     *string
	hidden            *bool
	compatibility     **util.CompatibilityInfo
	clearedFields     map[string]struct{}
	versions          map[string]struct{}
	removedversions   map[string]struct{}
	clearedversions   bool
	authors           map[string]struct{}
	removedauthors    map[string]struct{}
	clearedauthors    bool
	tags              map[string]struct{}
	removedtags       map[string]struct{}
	clearedtags       bool
	dependents        map[string]struct{}
	removeddependents map[string]struct{}
	cleareddependents bool
	done              bool
	oldValue          func(context.Context) (*Mod, error)
	predicates        []predicate.Mod
}

var _ ent.Mutation = (*ModMutation)(nil)

// modOption allows management of the mutation configuration using functional options.
type modOption func(*ModMutation)

// newModMutation creates new mutation for the Mod entity.
func newModMutation(c config, op Op, opts ...modOption) *ModMutation {
	m := &ModMutation{
		config:        c,
		op:            op,
		typ:           TypeMod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModID sets the ID field of the mutation.
func withModID(id string) modOption {
	return func(m *ModMutation) {
		var (
			err   error
			once  sync.Once
			value *Mod
		)
		m.oldValue = func(ctx context.Context) (*Mod, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mod.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMod sets the old Mod of the mutation.
func withMod(node *Mod) modOption {
	return func(m *ModMutation) {
		m.oldValue = func(context.Context) (*Mod, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Mod entities.
func (m *ModMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mod.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ModMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ModMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ModMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ModMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[mod.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ModMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[mod.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ModMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, mod.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ModMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ModMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ModMutation) ResetName() {
	m.name = nil
}

// SetShortDescription sets the "short_description" field.
func (m *ModMutation) SetShortDescription(s string) {
	m.short_description = &s
}

// ShortDescription returns the value of the "short_description" field in the mutation.
func (m *ModMutation) ShortDescription() (r string, exists bool) {
	v := m.short_description
	if v == nil {
		return
	}
	return *v, true
}

// OldShortDescription returns the old "short_description" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldShortDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortDescription: %w", err)
	}
	return oldValue.ShortDescription, nil
}

// ResetShortDescription resets all changes to the "short_description" field.
func (m *ModMutation) ResetShortDescription() {
	m.short_description = nil
}

// SetFullDescription sets the "full_description" field.
func (m *ModMutation) SetFullDescription(s string) {
	m.full_description = &s
}

// FullDescription returns the value of the "full_description" field in the mutation.
func (m *ModMutation) FullDescription() (r string, exists bool) {
	v := m.full_description
	if v == nil {
		return
	}
	return *v, true
}

// OldFullDescription returns the old "full_description" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldFullDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullDescription: %w", err)
	}
	return oldValue.FullDescription, nil
}

// ResetFullDescription resets all changes to the "full_description" field.
func (m *ModMutation) ResetFullDescription() {
	m.full_description = nil
}

// SetLogo sets the "logo" field.
func (m *ModMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *ModMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ResetLogo resets all changes to the "logo" field.
func (m *ModMutation) ResetLogo() {
	m.logo = nil
}

// SetSourceURL sets the "source_url" field.
func (m *ModMutation) SetSourceURL(s string) {
	m.source_url = &s
}

// SourceURL returns the value of the "source_url" field in the mutation.
func (m *ModMutation) SourceURL() (r string, exists bool) {
	v := m.source_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceURL returns the old "source_url" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldSourceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceURL: %w", err)
	}
	return oldValue.SourceURL, nil
}

// ClearSourceURL clears the value of the "source_url" field.
func (m *ModMutation) ClearSourceURL() {
	m.source_url = nil
	m.clearedFields[mod.FieldSourceURL] = struct{}{}
}

// SourceURLCleared returns if the "source_url" field was cleared in this mutation.
func (m *ModMutation) SourceURLCleared() bool {
	_, ok := m.clearedFields[mod.FieldSourceURL]
	return ok
}

// ResetSourceURL resets all changes to the "source_url" field.
func (m *ModMutation) ResetSourceURL() {
	m.source_url = nil
	delete(m.clearedFields, mod.FieldSourceURL)
}

// SetCreatorID sets the "creator_id" field.
func (m *ModMutation) SetCreatorID(s string) {
	m.creator_id = &s
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *ModMutation) CreatorID() (r string, exists bool) {
	v := m.creator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldCreatorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *ModMutation) ResetCreatorID() {
	m.creator_id = nil
}

// SetApproved sets the "approved" field.
func (m *ModMutation) SetApproved(b bool) {
	m.approved = &b
}

// Approved returns the value of the "approved" field in the mutation.
func (m *ModMutation) Approved() (r bool, exists bool) {
	v := m.approved
	if v == nil {
		return
	}
	return *v, true
}

// OldApproved returns the old "approved" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproved: %w", err)
	}
	return oldValue.Approved, nil
}

// ResetApproved resets all changes to the "approved" field.
func (m *ModMutation) ResetApproved() {
	m.approved = nil
}

// SetViews sets the "views" field.
func (m *ModMutation) SetViews(u uint) {
	m.views = &u
	m.addviews = nil
}

// Views returns the value of the "views" field in the mutation.
func (m *ModMutation) Views() (r uint, exists bool) {
	v := m.views
	if v == nil {
		return
	}
	return *v, true
}

// OldViews returns the old "views" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldViews(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViews: %w", err)
	}
	return oldValue.Views, nil
}

// AddViews adds u to the "views" field.
func (m *ModMutation) AddViews(u int) {
	if m.addviews != nil {
		*m.addviews += u
	} else {
		m.addviews = &u
	}
}

// AddedViews returns the value that was added to the "views" field in this mutation.
func (m *ModMutation) AddedViews() (r int, exists bool) {
	v := m.addviews
	if v == nil {
		return
	}
	return *v, true
}

// ResetViews resets all changes to the "views" field.
func (m *ModMutation) ResetViews() {
	m.views = nil
	m.addviews = nil
}

// SetHotness sets the "hotness" field.
func (m *ModMutation) SetHotness(u uint) {
	m.hotness = &u
	m.addhotness = nil
}

// Hotness returns the value of the "hotness" field in the mutation.
func (m *ModMutation) Hotness() (r uint, exists bool) {
	v := m.hotness
	if v == nil {
		return
	}
	return *v, true
}

// OldHotness returns the old "hotness" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldHotness(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHotness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHotness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHotness: %w", err)
	}
	return oldValue.Hotness, nil
}

// AddHotness adds u to the "hotness" field.
func (m *ModMutation) AddHotness(u int) {
	if m.addhotness != nil {
		*m.addhotness += u
	} else {
		m.addhotness = &u
	}
}

// AddedHotness returns the value that was added to the "hotness" field in this mutation.
func (m *ModMutation) AddedHotness() (r int, exists bool) {
	v := m.addhotness
	if v == nil {
		return
	}
	return *v, true
}

// ResetHotness resets all changes to the "hotness" field.
func (m *ModMutation) ResetHotness() {
	m.hotness = nil
	m.addhotness = nil
}

// SetPopularity sets the "popularity" field.
func (m *ModMutation) SetPopularity(u uint) {
	m.popularity = &u
	m.addpopularity = nil
}

// Popularity returns the value of the "popularity" field in the mutation.
func (m *ModMutation) Popularity() (r uint, exists bool) {
	v := m.popularity
	if v == nil {
		return
	}
	return *v, true
}

// OldPopularity returns the old "popularity" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldPopularity(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopularity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopularity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopularity: %w", err)
	}
	return oldValue.Popularity, nil
}

// AddPopularity adds u to the "popularity" field.
func (m *ModMutation) AddPopularity(u int) {
	if m.addpopularity != nil {
		*m.addpopularity += u
	} else {
		m.addpopularity = &u
	}
}

// AddedPopularity returns the value that was added to the "popularity" field in this mutation.
func (m *ModMutation) AddedPopularity() (r int, exists bool) {
	v := m.addpopularity
	if v == nil {
		return
	}
	return *v, true
}

// ResetPopularity resets all changes to the "popularity" field.
func (m *ModMutation) ResetPopularity() {
	m.popularity = nil
	m.addpopularity = nil
}

// SetDownloads sets the "downloads" field.
func (m *ModMutation) SetDownloads(u uint) {
	m.downloads = &u
	m.adddownloads = nil
}

// Downloads returns the value of the "downloads" field in the mutation.
func (m *ModMutation) Downloads() (r uint, exists bool) {
	v := m.downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloads returns the old "downloads" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldDownloads(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloads: %w", err)
	}
	return oldValue.Downloads, nil
}

// AddDownloads adds u to the "downloads" field.
func (m *ModMutation) AddDownloads(u int) {
	if m.adddownloads != nil {
		*m.adddownloads += u
	} else {
		m.adddownloads = &u
	}
}

// AddedDownloads returns the value that was added to the "downloads" field in this mutation.
func (m *ModMutation) AddedDownloads() (r int, exists bool) {
	v := m.adddownloads
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloads resets all changes to the "downloads" field.
func (m *ModMutation) ResetDownloads() {
	m.downloads = nil
	m.adddownloads = nil
}

// SetDenied sets the "denied" field.
func (m *ModMutation) SetDenied(b bool) {
	m.denied = &b
}

// Denied returns the value of the "denied" field in the mutation.
func (m *ModMutation) Denied() (r bool, exists bool) {
	v := m.denied
	if v == nil {
		return
	}
	return *v, true
}

// OldDenied returns the old "denied" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldDenied(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDenied is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDenied requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDenied: %w", err)
	}
	return oldValue.Denied, nil
}

// ResetDenied resets all changes to the "denied" field.
func (m *ModMutation) ResetDenied() {
	m.denied = nil
}

// SetLastVersionDate sets the "last_version_date" field.
func (m *ModMutation) SetLastVersionDate(t time.Time) {
	m.last_version_date = &t
}

// LastVersionDate returns the value of the "last_version_date" field in the mutation.
func (m *ModMutation) LastVersionDate() (r time.Time, exists bool) {
	v := m.last_version_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastVersionDate returns the old "last_version_date" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldLastVersionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastVersionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastVersionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastVersionDate: %w", err)
	}
	return oldValue.LastVersionDate, nil
}

// ClearLastVersionDate clears the value of the "last_version_date" field.
func (m *ModMutation) ClearLastVersionDate() {
	m.last_version_date = nil
	m.clearedFields[mod.FieldLastVersionDate] = struct{}{}
}

// LastVersionDateCleared returns if the "last_version_date" field was cleared in this mutation.
func (m *ModMutation) LastVersionDateCleared() bool {
	_, ok := m.clearedFields[mod.FieldLastVersionDate]
	return ok
}

// ResetLastVersionDate resets all changes to the "last_version_date" field.
func (m *ModMutation) ResetLastVersionDate() {
	m.last_version_date = nil
	delete(m.clearedFields, mod.FieldLastVersionDate)
}

// SetModReference sets the "mod_reference" field.
func (m *ModMutation) SetModReference(s string) {
	m.mod_reference = &s
}

// ModReference returns the value of the "mod_reference" field in the mutation.
func (m *ModMutation) ModReference() (r string, exists bool) {
	v := m.mod_reference
	if v == nil {
		return
	}
	return *v, true
}

// OldModReference returns the old "mod_reference" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldModReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModReference: %w", err)
	}
	return oldValue.ModReference, nil
}

// ResetModReference resets all changes to the "mod_reference" field.
func (m *ModMutation) ResetModReference() {
	m.mod_reference = nil
}

// SetHidden sets the "hidden" field.
func (m *ModMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *ModMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ResetHidden resets all changes to the "hidden" field.
func (m *ModMutation) ResetHidden() {
	m.hidden = nil
}

// SetCompatibility sets the "compatibility" field.
func (m *ModMutation) SetCompatibility(ui *util.CompatibilityInfo) {
	m.compatibility = &ui
}

// Compatibility returns the value of the "compatibility" field in the mutation.
func (m *ModMutation) Compatibility() (r *util.CompatibilityInfo, exists bool) {
	v := m.compatibility
	if v == nil {
		return
	}
	return *v, true
}

// OldCompatibility returns the old "compatibility" field's value of the Mod entity.
// If the Mod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModMutation) OldCompatibility(ctx context.Context) (v *util.CompatibilityInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompatibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompatibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompatibility: %w", err)
	}
	return oldValue.Compatibility, nil
}

// ClearCompatibility clears the value of the "compatibility" field.
func (m *ModMutation) ClearCompatibility() {
	m.compatibility = nil
	m.clearedFields[mod.FieldCompatibility] = struct{}{}
}

// CompatibilityCleared returns if the "compatibility" field was cleared in this mutation.
func (m *ModMutation) CompatibilityCleared() bool {
	_, ok := m.clearedFields[mod.FieldCompatibility]
	return ok
}

// ResetCompatibility resets all changes to the "compatibility" field.
func (m *ModMutation) ResetCompatibility() {
	m.compatibility = nil
	delete(m.clearedFields, mod.FieldCompatibility)
}

// AddVersionIDs adds the "versions" edge to the Version entity by ids.
func (m *ModMutation) AddVersionIDs(ids ...string) {
	if m.versions == nil {
		m.versions = make(map[string]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the Version entity.
func (m *ModMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the Version entity was cleared.
func (m *ModMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the Version entity by IDs.
func (m *ModMutation) RemoveVersionIDs(ids ...string) {
	if m.removedversions == nil {
		m.removedversions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the Version entity.
func (m *ModMutation) RemovedVersionsIDs() (ids []string) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *ModMutation) VersionsIDs() (ids []string) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *ModMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// AddAuthorIDs adds the "authors" edge to the User entity by ids.
func (m *ModMutation) AddAuthorIDs(ids ...string) {
	if m.authors == nil {
		m.authors = make(map[string]struct{})
	}
	for i := range ids {
		m.authors[ids[i]] = struct{}{}
	}
}

// ClearAuthors clears the "authors" edge to the User entity.
func (m *ModMutation) ClearAuthors() {
	m.clearedauthors = true
}

// AuthorsCleared reports if the "authors" edge to the User entity was cleared.
func (m *ModMutation) AuthorsCleared() bool {
	return m.clearedauthors
}

// RemoveAuthorIDs removes the "authors" edge to the User entity by IDs.
func (m *ModMutation) RemoveAuthorIDs(ids ...string) {
	if m.removedauthors == nil {
		m.removedauthors = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.authors, ids[i])
		m.removedauthors[ids[i]] = struct{}{}
	}
}

// RemovedAuthors returns the removed IDs of the "authors" edge to the User entity.
func (m *ModMutation) RemovedAuthorsIDs() (ids []string) {
	for id := range m.removedauthors {
		ids = append(ids, id)
	}
	return
}

// AuthorsIDs returns the "authors" edge IDs in the mutation.
func (m *ModMutation) AuthorsIDs() (ids []string) {
	for id := range m.authors {
		ids = append(ids, id)
	}
	return
}

// ResetAuthors resets all changes to the "authors" edge.
func (m *ModMutation) ResetAuthors() {
	m.authors = nil
	m.clearedauthors = false
	m.removedauthors = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ModMutation) AddTagIDs(ids ...string) {
	if m.tags == nil {
		m.tags = make(map[string]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ModMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ModMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ModMutation) RemoveTagIDs(ids ...string) {
	if m.removedtags == nil {
		m.removedtags = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ModMutation) RemovedTagsIDs() (ids []string) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ModMutation) TagsIDs() (ids []string) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ModMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddDependentIDs adds the "dependents" edge to the Version entity by ids.
func (m *ModMutation) AddDependentIDs(ids ...string) {
	if m.dependents == nil {
		m.dependents = make(map[string]struct{})
	}
	for i := range ids {
		m.dependents[ids[i]] = struct{}{}
	}
}

// ClearDependents clears the "dependents" edge to the Version entity.
func (m *ModMutation) ClearDependents() {
	m.cleareddependents = true
}

// DependentsCleared reports if the "dependents" edge to the Version entity was cleared.
func (m *ModMutation) DependentsCleared() bool {
	return m.cleareddependents
}

// RemoveDependentIDs removes the "dependents" edge to the Version entity by IDs.
func (m *ModMutation) RemoveDependentIDs(ids ...string) {
	if m.removeddependents == nil {
		m.removeddependents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dependents, ids[i])
		m.removeddependents[ids[i]] = struct{}{}
	}
}

// RemovedDependents returns the removed IDs of the "dependents" edge to the Version entity.
func (m *ModMutation) RemovedDependentsIDs() (ids []string) {
	for id := range m.removeddependents {
		ids = append(ids, id)
	}
	return
}

// DependentsIDs returns the "dependents" edge IDs in the mutation.
func (m *ModMutation) DependentsIDs() (ids []string) {
	for id := range m.dependents {
		ids = append(ids, id)
	}
	return
}

// ResetDependents resets all changes to the "dependents" edge.
func (m *ModMutation) ResetDependents() {
	m.dependents = nil
	m.cleareddependents = false
	m.removeddependents = nil
}

// Where appends a list predicates to the ModMutation builder.
func (m *ModMutation) Where(ps ...predicate.Mod) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Mod, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Mod).
func (m *ModMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, mod.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mod.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, mod.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, mod.FieldName)
	}
	if m.short_description != nil {
		fields = append(fields, mod.FieldShortDescription)
	}
	if m.full_description != nil {
		fields = append(fields, mod.FieldFullDescription)
	}
	if m.logo != nil {
		fields = append(fields, mod.FieldLogo)
	}
	if m.source_url != nil {
		fields = append(fields, mod.FieldSourceURL)
	}
	if m.creator_id != nil {
		fields = append(fields, mod.FieldCreatorID)
	}
	if m.approved != nil {
		fields = append(fields, mod.FieldApproved)
	}
	if m.views != nil {
		fields = append(fields, mod.FieldViews)
	}
	if m.hotness != nil {
		fields = append(fields, mod.FieldHotness)
	}
	if m.popularity != nil {
		fields = append(fields, mod.FieldPopularity)
	}
	if m.downloads != nil {
		fields = append(fields, mod.FieldDownloads)
	}
	if m.denied != nil {
		fields = append(fields, mod.FieldDenied)
	}
	if m.last_version_date != nil {
		fields = append(fields, mod.FieldLastVersionDate)
	}
	if m.mod_reference != nil {
		fields = append(fields, mod.FieldModReference)
	}
	if m.hidden != nil {
		fields = append(fields, mod.FieldHidden)
	}
	if m.compatibility != nil {
		fields = append(fields, mod.FieldCompatibility)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mod.FieldCreatedAt:
		return m.CreatedAt()
	case mod.FieldUpdatedAt:
		return m.UpdatedAt()
	case mod.FieldDeletedAt:
		return m.DeletedAt()
	case mod.FieldName:
		return m.Name()
	case mod.FieldShortDescription:
		return m.ShortDescription()
	case mod.FieldFullDescription:
		return m.FullDescription()
	case mod.FieldLogo:
		return m.Logo()
	case mod.FieldSourceURL:
		return m.SourceURL()
	case mod.FieldCreatorID:
		return m.CreatorID()
	case mod.FieldApproved:
		return m.Approved()
	case mod.FieldViews:
		return m.Views()
	case mod.FieldHotness:
		return m.Hotness()
	case mod.FieldPopularity:
		return m.Popularity()
	case mod.FieldDownloads:
		return m.Downloads()
	case mod.FieldDenied:
		return m.Denied()
	case mod.FieldLastVersionDate:
		return m.LastVersionDate()
	case mod.FieldModReference:
		return m.ModReference()
	case mod.FieldHidden:
		return m.Hidden()
	case mod.FieldCompatibility:
		return m.Compatibility()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mod.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mod.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mod.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case mod.FieldName:
		return m.OldName(ctx)
	case mod.FieldShortDescription:
		return m.OldShortDescription(ctx)
	case mod.FieldFullDescription:
		return m.OldFullDescription(ctx)
	case mod.FieldLogo:
		return m.OldLogo(ctx)
	case mod.FieldSourceURL:
		return m.OldSourceURL(ctx)
	case mod.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case mod.FieldApproved:
		return m.OldApproved(ctx)
	case mod.FieldViews:
		return m.OldViews(ctx)
	case mod.FieldHotness:
		return m.OldHotness(ctx)
	case mod.FieldPopularity:
		return m.OldPopularity(ctx)
	case mod.FieldDownloads:
		return m.OldDownloads(ctx)
	case mod.FieldDenied:
		return m.OldDenied(ctx)
	case mod.FieldLastVersionDate:
		return m.OldLastVersionDate(ctx)
	case mod.FieldModReference:
		return m.OldModReference(ctx)
	case mod.FieldHidden:
		return m.OldHidden(ctx)
	case mod.FieldCompatibility:
		return m.OldCompatibility(ctx)
	}
	return nil, fmt.Errorf("unknown Mod field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mod.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mod.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mod.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case mod.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case mod.FieldShortDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortDescription(v)
		return nil
	case mod.FieldFullDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullDescription(v)
		return nil
	case mod.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case mod.FieldSourceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceURL(v)
		return nil
	case mod.FieldCreatorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case mod.FieldApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproved(v)
		return nil
	case mod.FieldViews:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViews(v)
		return nil
	case mod.FieldHotness:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHotness(v)
		return nil
	case mod.FieldPopularity:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopularity(v)
		return nil
	case mod.FieldDownloads:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloads(v)
		return nil
	case mod.FieldDenied:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDenied(v)
		return nil
	case mod.FieldLastVersionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastVersionDate(v)
		return nil
	case mod.FieldModReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModReference(v)
		return nil
	case mod.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case mod.FieldCompatibility:
		v, ok := value.(*util.CompatibilityInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompatibility(v)
		return nil
	}
	return fmt.Errorf("unknown Mod field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModMutation) AddedFields() []string {
	var fields []string
	if m.addviews != nil {
		fields = append(fields, mod.FieldViews)
	}
	if m.addhotness != nil {
		fields = append(fields, mod.FieldHotness)
	}
	if m.addpopularity != nil {
		fields = append(fields, mod.FieldPopularity)
	}
	if m.adddownloads != nil {
		fields = append(fields, mod.FieldDownloads)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mod.FieldViews:
		return m.AddedViews()
	case mod.FieldHotness:
		return m.AddedHotness()
	case mod.FieldPopularity:
		return m.AddedPopularity()
	case mod.FieldDownloads:
		return m.AddedDownloads()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mod.FieldViews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViews(v)
		return nil
	case mod.FieldHotness:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHotness(v)
		return nil
	case mod.FieldPopularity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPopularity(v)
		return nil
	case mod.FieldDownloads:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloads(v)
		return nil
	}
	return fmt.Errorf("unknown Mod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mod.FieldDeletedAt) {
		fields = append(fields, mod.FieldDeletedAt)
	}
	if m.FieldCleared(mod.FieldSourceURL) {
		fields = append(fields, mod.FieldSourceURL)
	}
	if m.FieldCleared(mod.FieldLastVersionDate) {
		fields = append(fields, mod.FieldLastVersionDate)
	}
	if m.FieldCleared(mod.FieldCompatibility) {
		fields = append(fields, mod.FieldCompatibility)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModMutation) ClearField(name string) error {
	switch name {
	case mod.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case mod.FieldSourceURL:
		m.ClearSourceURL()
		return nil
	case mod.FieldLastVersionDate:
		m.ClearLastVersionDate()
		return nil
	case mod.FieldCompatibility:
		m.ClearCompatibility()
		return nil
	}
	return fmt.Errorf("unknown Mod nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModMutation) ResetField(name string) error {
	switch name {
	case mod.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mod.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mod.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case mod.FieldName:
		m.ResetName()
		return nil
	case mod.FieldShortDescription:
		m.ResetShortDescription()
		return nil
	case mod.FieldFullDescription:
		m.ResetFullDescription()
		return nil
	case mod.FieldLogo:
		m.ResetLogo()
		return nil
	case mod.FieldSourceURL:
		m.ResetSourceURL()
		return nil
	case mod.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case mod.FieldApproved:
		m.ResetApproved()
		return nil
	case mod.FieldViews:
		m.ResetViews()
		return nil
	case mod.FieldHotness:
		m.ResetHotness()
		return nil
	case mod.FieldPopularity:
		m.ResetPopularity()
		return nil
	case mod.FieldDownloads:
		m.ResetDownloads()
		return nil
	case mod.FieldDenied:
		m.ResetDenied()
		return nil
	case mod.FieldLastVersionDate:
		m.ResetLastVersionDate()
		return nil
	case mod.FieldModReference:
		m.ResetModReference()
		return nil
	case mod.FieldHidden:
		m.ResetHidden()
		return nil
	case mod.FieldCompatibility:
		m.ResetCompatibility()
		return nil
	}
	return fmt.Errorf("unknown Mod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.versions != nil {
		edges = append(edges, mod.EdgeVersions)
	}
	if m.authors != nil {
		edges = append(edges, mod.EdgeAuthors)
	}
	if m.tags != nil {
		edges = append(edges, mod.EdgeTags)
	}
	if m.dependents != nil {
		edges = append(edges, mod.EdgeDependents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mod.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case mod.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.authors))
		for id := range m.authors {
			ids = append(ids, id)
		}
		return ids
	case mod.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case mod.EdgeDependents:
		ids := make([]ent.Value, 0, len(m.dependents))
		for id := range m.dependents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedversions != nil {
		edges = append(edges, mod.EdgeVersions)
	}
	if m.removedauthors != nil {
		edges = append(edges, mod.EdgeAuthors)
	}
	if m.removedtags != nil {
		edges = append(edges, mod.EdgeTags)
	}
	if m.removeddependents != nil {
		edges = append(edges, mod.EdgeDependents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mod.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	case mod.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.removedauthors))
		for id := range m.removedauthors {
			ids = append(ids, id)
		}
		return ids
	case mod.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case mod.EdgeDependents:
		ids := make([]ent.Value, 0, len(m.removeddependents))
		for id := range m.removeddependents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedversions {
		edges = append(edges, mod.EdgeVersions)
	}
	if m.clearedauthors {
		edges = append(edges, mod.EdgeAuthors)
	}
	if m.clearedtags {
		edges = append(edges, mod.EdgeTags)
	}
	if m.cleareddependents {
		edges = append(edges, mod.EdgeDependents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModMutation) EdgeCleared(name string) bool {
	switch name {
	case mod.EdgeVersions:
		return m.clearedversions
	case mod.EdgeAuthors:
		return m.clearedauthors
	case mod.EdgeTags:
		return m.clearedtags
	case mod.EdgeDependents:
		return m.cleareddependents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Mod unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModMutation) ResetEdge(name string) error {
	switch name {
	case mod.EdgeVersions:
		m.ResetVersions()
		return nil
	case mod.EdgeAuthors:
		m.ResetAuthors()
		return nil
	case mod.EdgeTags:
		m.ResetTags()
		return nil
	case mod.EdgeDependents:
		m.ResetDependents()
		return nil
	}
	return fmt.Errorf("unknown Mod edge %s", name)
}

// ModTagMutation represents an operation that mutates the ModTag nodes in the graph.
type ModTagMutation struct {
	config
	op            Op
	typ           string
	clearedFields map[string]struct{}
	mod           *string
	clearedmod    bool
	tag           *string
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*ModTag, error)
	predicates    []predicate.ModTag
}

var _ ent.Mutation = (*ModTagMutation)(nil)

// modtagOption allows management of the mutation configuration using functional options.
type modtagOption func(*ModTagMutation)

// newModTagMutation creates new mutation for the ModTag entity.
func newModTagMutation(c config, op Op, opts ...modtagOption) *ModTagMutation {
	m := &ModTagMutation{
		config:        c,
		op:            op,
		typ:           TypeModTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetModID sets the "mod_id" field.
func (m *ModTagMutation) SetModID(s string) {
	m.mod = &s
}

// ModID returns the value of the "mod_id" field in the mutation.
func (m *ModTagMutation) ModID() (r string, exists bool) {
	v := m.mod
	if v == nil {
		return
	}
	return *v, true
}

// ResetModID resets all changes to the "mod_id" field.
func (m *ModTagMutation) ResetModID() {
	m.mod = nil
}

// SetTagID sets the "tag_id" field.
func (m *ModTagMutation) SetTagID(s string) {
	m.tag = &s
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *ModTagMutation) TagID() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *ModTagMutation) ResetTagID() {
	m.tag = nil
}

// ClearMod clears the "mod" edge to the Mod entity.
func (m *ModTagMutation) ClearMod() {
	m.clearedmod = true
	m.clearedFields[modtag.FieldModID] = struct{}{}
}

// ModCleared reports if the "mod" edge to the Mod entity was cleared.
func (m *ModTagMutation) ModCleared() bool {
	return m.clearedmod
}

// ModIDs returns the "mod" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModID instead. It exists only for internal usage by the builders.
func (m *ModTagMutation) ModIDs() (ids []string) {
	if id := m.mod; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMod resets all changes to the "mod" edge.
func (m *ModTagMutation) ResetMod() {
	m.mod = nil
	m.clearedmod = false
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *ModTagMutation) ClearTag() {
	m.clearedtag = true
	m.clearedFields[modtag.FieldTagID] = struct{}{}
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *ModTagMutation) TagCleared() bool {
	return m.clearedtag
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *ModTagMutation) TagIDs() (ids []string) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *ModTagMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// Where appends a list predicates to the ModTagMutation builder.
func (m *ModTagMutation) Where(ps ...predicate.ModTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ModTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ModTag).
func (m *ModTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.mod != nil {
		fields = append(fields, modtag.FieldModID)
	}
	if m.tag != nil {
		fields = append(fields, modtag.FieldTagID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case modtag.FieldModID:
		return m.ModID()
	case modtag.FieldTagID:
		return m.TagID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema ModTag does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case modtag.FieldModID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModID(v)
		return nil
	case modtag.FieldTagID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	}
	return fmt.Errorf("unknown ModTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ModTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ModTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModTagMutation) ResetField(name string) error {
	switch name {
	case modtag.FieldModID:
		m.ResetModID()
		return nil
	case modtag.FieldTagID:
		m.ResetTagID()
		return nil
	}
	return fmt.Errorf("unknown ModTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mod != nil {
		edges = append(edges, modtag.EdgeMod)
	}
	if m.tag != nil {
		edges = append(edges, modtag.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case modtag.EdgeMod:
		if id := m.mod; id != nil {
			return []ent.Value{*id}
		}
	case modtag.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModTagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmod {
		edges = append(edges, modtag.EdgeMod)
	}
	if m.clearedtag {
		edges = append(edges, modtag.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModTagMutation) EdgeCleared(name string) bool {
	switch name {
	case modtag.EdgeMod:
		return m.clearedmod
	case modtag.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModTagMutation) ClearEdge(name string) error {
	switch name {
	case modtag.EdgeMod:
		m.ClearMod()
		return nil
	case modtag.EdgeTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown ModTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModTagMutation) ResetEdge(name string) error {
	switch name {
	case modtag.EdgeMod:
		m.ResetMod()
		return nil
	case modtag.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown ModTag edge %s", name)
}

// SatisfactoryVersionMutation represents an operation that mutates the SatisfactoryVersion nodes in the graph.
type SatisfactoryVersionMutation struct {
	config
	op             Op
	typ            string
	id             *string
	version        *int
	addversion     *int
	engine_version *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*SatisfactoryVersion, error)
	predicates     []predicate.SatisfactoryVersion
}

var _ ent.Mutation = (*SatisfactoryVersionMutation)(nil)

// satisfactoryversionOption allows management of the mutation configuration using functional options.
type satisfactoryversionOption func(*SatisfactoryVersionMutation)

// newSatisfactoryVersionMutation creates new mutation for the SatisfactoryVersion entity.
func newSatisfactoryVersionMutation(c config, op Op, opts ...satisfactoryversionOption) *SatisfactoryVersionMutation {
	m := &SatisfactoryVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeSatisfactoryVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSatisfactoryVersionID sets the ID field of the mutation.
func withSatisfactoryVersionID(id string) satisfactoryversionOption {
	return func(m *SatisfactoryVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *SatisfactoryVersion
		)
		m.oldValue = func(ctx context.Context) (*SatisfactoryVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SatisfactoryVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSatisfactoryVersion sets the old SatisfactoryVersion of the mutation.
func withSatisfactoryVersion(node *SatisfactoryVersion) satisfactoryversionOption {
	return func(m *SatisfactoryVersionMutation) {
		m.oldValue = func(context.Context) (*SatisfactoryVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SatisfactoryVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SatisfactoryVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SatisfactoryVersion entities.
func (m *SatisfactoryVersionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SatisfactoryVersionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SatisfactoryVersionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SatisfactoryVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *SatisfactoryVersionMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *SatisfactoryVersionMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the SatisfactoryVersion entity.
// If the SatisfactoryVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SatisfactoryVersionMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *SatisfactoryVersionMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *SatisfactoryVersionMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *SatisfactoryVersionMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetEngineVersion sets the "engine_version" field.
func (m *SatisfactoryVersionMutation) SetEngineVersion(s string) {
	m.engine_version = &s
}

// EngineVersion returns the value of the "engine_version" field in the mutation.
func (m *SatisfactoryVersionMutation) EngineVersion() (r string, exists bool) {
	v := m.engine_version
	if v == nil {
		return
	}
	return *v, true
}

// OldEngineVersion returns the old "engine_version" field's value of the SatisfactoryVersion entity.
// If the SatisfactoryVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SatisfactoryVersionMutation) OldEngineVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEngineVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEngineVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEngineVersion: %w", err)
	}
	return oldValue.EngineVersion, nil
}

// ResetEngineVersion resets all changes to the "engine_version" field.
func (m *SatisfactoryVersionMutation) ResetEngineVersion() {
	m.engine_version = nil
}

// Where appends a list predicates to the SatisfactoryVersionMutation builder.
func (m *SatisfactoryVersionMutation) Where(ps ...predicate.SatisfactoryVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SatisfactoryVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SatisfactoryVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SatisfactoryVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SatisfactoryVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SatisfactoryVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SatisfactoryVersion).
func (m *SatisfactoryVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SatisfactoryVersionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.version != nil {
		fields = append(fields, satisfactoryversion.FieldVersion)
	}
	if m.engine_version != nil {
		fields = append(fields, satisfactoryversion.FieldEngineVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SatisfactoryVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case satisfactoryversion.FieldVersion:
		return m.Version()
	case satisfactoryversion.FieldEngineVersion:
		return m.EngineVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SatisfactoryVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case satisfactoryversion.FieldVersion:
		return m.OldVersion(ctx)
	case satisfactoryversion.FieldEngineVersion:
		return m.OldEngineVersion(ctx)
	}
	return nil, fmt.Errorf("unknown SatisfactoryVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SatisfactoryVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case satisfactoryversion.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case satisfactoryversion.FieldEngineVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEngineVersion(v)
		return nil
	}
	return fmt.Errorf("unknown SatisfactoryVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SatisfactoryVersionMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, satisfactoryversion.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SatisfactoryVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case satisfactoryversion.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SatisfactoryVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case satisfactoryversion.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown SatisfactoryVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SatisfactoryVersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SatisfactoryVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SatisfactoryVersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SatisfactoryVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SatisfactoryVersionMutation) ResetField(name string) error {
	switch name {
	case satisfactoryversion.FieldVersion:
		m.ResetVersion()
		return nil
	case satisfactoryversion.FieldEngineVersion:
		m.ResetEngineVersion()
		return nil
	}
	return fmt.Errorf("unknown SatisfactoryVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SatisfactoryVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SatisfactoryVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SatisfactoryVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SatisfactoryVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SatisfactoryVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SatisfactoryVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SatisfactoryVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SatisfactoryVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SatisfactoryVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SatisfactoryVersion edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	description   *string
	clearedFields map[string]struct{}
	mods          map[string]struct{}
	removedmods   map[string]struct{}
	clearedmods   bool
	guides        map[string]struct{}
	removedguides map[string]struct{}
	clearedguides bool
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id string) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TagMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TagMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TagMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tag.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
}

// AddModIDs adds the "mods" edge to the Mod entity by ids.
func (m *TagMutation) AddModIDs(ids ...string) {
	if m.mods == nil {
		m.mods = make(map[string]struct{})
	}
	for i := range ids {
		m.mods[ids[i]] = struct{}{}
	}
}

// ClearMods clears the "mods" edge to the Mod entity.
func (m *TagMutation) ClearMods() {
	m.clearedmods = true
}

// ModsCleared reports if the "mods" edge to the Mod entity was cleared.
func (m *TagMutation) ModsCleared() bool {
	return m.clearedmods
}

// RemoveModIDs removes the "mods" edge to the Mod entity by IDs.
func (m *TagMutation) RemoveModIDs(ids ...string) {
	if m.removedmods == nil {
		m.removedmods = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.mods, ids[i])
		m.removedmods[ids[i]] = struct{}{}
	}
}

// RemovedMods returns the removed IDs of the "mods" edge to the Mod entity.
func (m *TagMutation) RemovedModsIDs() (ids []string) {
	for id := range m.removedmods {
		ids = append(ids, id)
	}
	return
}

// ModsIDs returns the "mods" edge IDs in the mutation.
func (m *TagMutation) ModsIDs() (ids []string) {
	for id := range m.mods {
		ids = append(ids, id)
	}
	return
}

// ResetMods resets all changes to the "mods" edge.
func (m *TagMutation) ResetMods() {
	m.mods = nil
	m.clearedmods = false
	m.removedmods = nil
}

// AddGuideIDs adds the "guides" edge to the Guide entity by ids.
func (m *TagMutation) AddGuideIDs(ids ...string) {
	if m.guides == nil {
		m.guides = make(map[string]struct{})
	}
	for i := range ids {
		m.guides[ids[i]] = struct{}{}
	}
}

// ClearGuides clears the "guides" edge to the Guide entity.
func (m *TagMutation) ClearGuides() {
	m.clearedguides = true
}

// GuidesCleared reports if the "guides" edge to the Guide entity was cleared.
func (m *TagMutation) GuidesCleared() bool {
	return m.clearedguides
}

// RemoveGuideIDs removes the "guides" edge to the Guide entity by IDs.
func (m *TagMutation) RemoveGuideIDs(ids ...string) {
	if m.removedguides == nil {
		m.removedguides = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.guides, ids[i])
		m.removedguides[ids[i]] = struct{}{}
	}
}

// RemovedGuides returns the removed IDs of the "guides" edge to the Guide entity.
func (m *TagMutation) RemovedGuidesIDs() (ids []string) {
	for id := range m.removedguides {
		ids = append(ids, id)
	}
	return
}

// GuidesIDs returns the "guides" edge IDs in the mutation.
func (m *TagMutation) GuidesIDs() (ids []string) {
	for id := range m.guides {
		ids = append(ids, id)
	}
	return
}

// ResetGuides resets all changes to the "guides" edge.
func (m *TagMutation) ResetGuides() {
	m.guides = nil
	m.clearedguides = false
	m.removedguides = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tag.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldDeletedAt:
		return m.DeletedAt()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDeletedAt) {
		fields = append(fields, tag.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mods != nil {
		edges = append(edges, tag.EdgeMods)
	}
	if m.guides != nil {
		edges = append(edges, tag.EdgeGuides)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeMods:
		ids := make([]ent.Value, 0, len(m.mods))
		for id := range m.mods {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeGuides:
		ids := make([]ent.Value, 0, len(m.guides))
		for id := range m.guides {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmods != nil {
		edges = append(edges, tag.EdgeMods)
	}
	if m.removedguides != nil {
		edges = append(edges, tag.EdgeGuides)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeMods:
		ids := make([]ent.Value, 0, len(m.removedmods))
		for id := range m.removedmods {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeGuides:
		ids := make([]ent.Value, 0, len(m.removedguides))
		for id := range m.removedguides {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmods {
		edges = append(edges, tag.EdgeMods)
	}
	if m.clearedguides {
		edges = append(edges, tag.EdgeGuides)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeMods:
		return m.clearedmods
	case tag.EdgeGuides:
		return m.clearedguides
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeMods:
		m.ResetMods()
		return nil
	case tag.EdgeGuides:
		m.ResetGuides()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	email           *string
	username        *string
	avatar          *string
	joined_from     *string
	banned          *bool
	rank            *int
	addrank         *int
	github_id       *string
	google_id       *string
	facebook_id     *string
	clearedFields   map[string]struct{}
	guides          map[string]struct{}
	removedguides   map[string]struct{}
	clearedguides   bool
	sessions        map[string]struct{}
	removedsessions map[string]struct{}
	clearedsessions bool
	mods            map[string]struct{}
	removedmods     map[string]struct{}
	clearedmods     bool
	groups          map[string]struct{}
	removedgroups   map[string]struct{}
	clearedgroups   bool
	done            bool
	oldValue        func(context.Context) (*User, error)
	predicates      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetJoinedFrom sets the "joined_from" field.
func (m *UserMutation) SetJoinedFrom(s string) {
	m.joined_from = &s
}

// JoinedFrom returns the value of the "joined_from" field in the mutation.
func (m *UserMutation) JoinedFrom() (r string, exists bool) {
	v := m.joined_from
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedFrom returns the old "joined_from" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJoinedFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedFrom: %w", err)
	}
	return oldValue.JoinedFrom, nil
}

// ClearJoinedFrom clears the value of the "joined_from" field.
func (m *UserMutation) ClearJoinedFrom() {
	m.joined_from = nil
	m.clearedFields[user.FieldJoinedFrom] = struct{}{}
}

// JoinedFromCleared returns if the "joined_from" field was cleared in this mutation.
func (m *UserMutation) JoinedFromCleared() bool {
	_, ok := m.clearedFields[user.FieldJoinedFrom]
	return ok
}

// ResetJoinedFrom resets all changes to the "joined_from" field.
func (m *UserMutation) ResetJoinedFrom() {
	m.joined_from = nil
	delete(m.clearedFields, user.FieldJoinedFrom)
}

// SetBanned sets the "banned" field.
func (m *UserMutation) SetBanned(b bool) {
	m.banned = &b
}

// Banned returns the value of the "banned" field in the mutation.
func (m *UserMutation) Banned() (r bool, exists bool) {
	v := m.banned
	if v == nil {
		return
	}
	return *v, true
}

// OldBanned returns the old "banned" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBanned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanned: %w", err)
	}
	return oldValue.Banned, nil
}

// ResetBanned resets all changes to the "banned" field.
func (m *UserMutation) ResetBanned() {
	m.banned = nil
}

// SetRank sets the "rank" field.
func (m *UserMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *UserMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *UserMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *UserMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *UserMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetGithubID sets the "github_id" field.
func (m *UserMutation) SetGithubID(s string) {
	m.github_id = &s
}

// GithubID returns the value of the "github_id" field in the mutation.
func (m *UserMutation) GithubID() (r string, exists bool) {
	v := m.github_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubID returns the old "github_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGithubID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubID: %w", err)
	}
	return oldValue.GithubID, nil
}

// ClearGithubID clears the value of the "github_id" field.
func (m *UserMutation) ClearGithubID() {
	m.github_id = nil
	m.clearedFields[user.FieldGithubID] = struct{}{}
}

// GithubIDCleared returns if the "github_id" field was cleared in this mutation.
func (m *UserMutation) GithubIDCleared() bool {
	_, ok := m.clearedFields[user.FieldGithubID]
	return ok
}

// ResetGithubID resets all changes to the "github_id" field.
func (m *UserMutation) ResetGithubID() {
	m.github_id = nil
	delete(m.clearedFields, user.FieldGithubID)
}

// SetGoogleID sets the "google_id" field.
func (m *UserMutation) SetGoogleID(s string) {
	m.google_id = &s
}

// GoogleID returns the value of the "google_id" field in the mutation.
func (m *UserMutation) GoogleID() (r string, exists bool) {
	v := m.google_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleID returns the old "google_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGoogleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleID: %w", err)
	}
	return oldValue.GoogleID, nil
}

// ClearGoogleID clears the value of the "google_id" field.
func (m *UserMutation) ClearGoogleID() {
	m.google_id = nil
	m.clearedFields[user.FieldGoogleID] = struct{}{}
}

// GoogleIDCleared returns if the "google_id" field was cleared in this mutation.
func (m *UserMutation) GoogleIDCleared() bool {
	_, ok := m.clearedFields[user.FieldGoogleID]
	return ok
}

// ResetGoogleID resets all changes to the "google_id" field.
func (m *UserMutation) ResetGoogleID() {
	m.google_id = nil
	delete(m.clearedFields, user.FieldGoogleID)
}

// SetFacebookID sets the "facebook_id" field.
func (m *UserMutation) SetFacebookID(s string) {
	m.facebook_id = &s
}

// FacebookID returns the value of the "facebook_id" field in the mutation.
func (m *UserMutation) FacebookID() (r string, exists bool) {
	v := m.facebook_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFacebookID returns the old "facebook_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFacebookID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacebookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacebookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacebookID: %w", err)
	}
	return oldValue.FacebookID, nil
}

// ClearFacebookID clears the value of the "facebook_id" field.
func (m *UserMutation) ClearFacebookID() {
	m.facebook_id = nil
	m.clearedFields[user.FieldFacebookID] = struct{}{}
}

// FacebookIDCleared returns if the "facebook_id" field was cleared in this mutation.
func (m *UserMutation) FacebookIDCleared() bool {
	_, ok := m.clearedFields[user.FieldFacebookID]
	return ok
}

// ResetFacebookID resets all changes to the "facebook_id" field.
func (m *UserMutation) ResetFacebookID() {
	m.facebook_id = nil
	delete(m.clearedFields, user.FieldFacebookID)
}

// AddGuideIDs adds the "guides" edge to the Guide entity by ids.
func (m *UserMutation) AddGuideIDs(ids ...string) {
	if m.guides == nil {
		m.guides = make(map[string]struct{})
	}
	for i := range ids {
		m.guides[ids[i]] = struct{}{}
	}
}

// ClearGuides clears the "guides" edge to the Guide entity.
func (m *UserMutation) ClearGuides() {
	m.clearedguides = true
}

// GuidesCleared reports if the "guides" edge to the Guide entity was cleared.
func (m *UserMutation) GuidesCleared() bool {
	return m.clearedguides
}

// RemoveGuideIDs removes the "guides" edge to the Guide entity by IDs.
func (m *UserMutation) RemoveGuideIDs(ids ...string) {
	if m.removedguides == nil {
		m.removedguides = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.guides, ids[i])
		m.removedguides[ids[i]] = struct{}{}
	}
}

// RemovedGuides returns the removed IDs of the "guides" edge to the Guide entity.
func (m *UserMutation) RemovedGuidesIDs() (ids []string) {
	for id := range m.removedguides {
		ids = append(ids, id)
	}
	return
}

// GuidesIDs returns the "guides" edge IDs in the mutation.
func (m *UserMutation) GuidesIDs() (ids []string) {
	for id := range m.guides {
		ids = append(ids, id)
	}
	return
}

// ResetGuides resets all changes to the "guides" edge.
func (m *UserMutation) ResetGuides() {
	m.guides = nil
	m.clearedguides = false
	m.removedguides = nil
}

// AddSessionIDs adds the "sessions" edge to the UserSession entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...string) {
	if m.sessions == nil {
		m.sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the UserSession entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the UserSession entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the UserSession entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...string) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the UserSession entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []string) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []string) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddModIDs adds the "mods" edge to the Mod entity by ids.
func (m *UserMutation) AddModIDs(ids ...string) {
	if m.mods == nil {
		m.mods = make(map[string]struct{})
	}
	for i := range ids {
		m.mods[ids[i]] = struct{}{}
	}
}

// ClearMods clears the "mods" edge to the Mod entity.
func (m *UserMutation) ClearMods() {
	m.clearedmods = true
}

// ModsCleared reports if the "mods" edge to the Mod entity was cleared.
func (m *UserMutation) ModsCleared() bool {
	return m.clearedmods
}

// RemoveModIDs removes the "mods" edge to the Mod entity by IDs.
func (m *UserMutation) RemoveModIDs(ids ...string) {
	if m.removedmods == nil {
		m.removedmods = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.mods, ids[i])
		m.removedmods[ids[i]] = struct{}{}
	}
}

// RemovedMods returns the removed IDs of the "mods" edge to the Mod entity.
func (m *UserMutation) RemovedModsIDs() (ids []string) {
	for id := range m.removedmods {
		ids = append(ids, id)
	}
	return
}

// ModsIDs returns the "mods" edge IDs in the mutation.
func (m *UserMutation) ModsIDs() (ids []string) {
	for id := range m.mods {
		ids = append(ids, id)
	}
	return
}

// ResetMods resets all changes to the "mods" edge.
func (m *UserMutation) ResetMods() {
	m.mods = nil
	m.clearedmods = false
	m.removedmods = nil
}

// AddGroupIDs adds the "groups" edge to the UserGroup entity by ids.
func (m *UserMutation) AddGroupIDs(ids ...string) {
	if m.groups == nil {
		m.groups = make(map[string]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the UserGroup entity.
func (m *UserMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the UserGroup entity was cleared.
func (m *UserMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the UserGroup entity by IDs.
func (m *UserMutation) RemoveGroupIDs(ids ...string) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the UserGroup entity.
func (m *UserMutation) RemovedGroupsIDs() (ids []string) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *UserMutation) GroupsIDs() (ids []string) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *UserMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.joined_from != nil {
		fields = append(fields, user.FieldJoinedFrom)
	}
	if m.banned != nil {
		fields = append(fields, user.FieldBanned)
	}
	if m.rank != nil {
		fields = append(fields, user.FieldRank)
	}
	if m.github_id != nil {
		fields = append(fields, user.FieldGithubID)
	}
	if m.google_id != nil {
		fields = append(fields, user.FieldGoogleID)
	}
	if m.facebook_id != nil {
		fields = append(fields, user.FieldFacebookID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldUsername:
		return m.Username()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldJoinedFrom:
		return m.JoinedFrom()
	case user.FieldBanned:
		return m.Banned()
	case user.FieldRank:
		return m.Rank()
	case user.FieldGithubID:
		return m.GithubID()
	case user.FieldGoogleID:
		return m.GoogleID()
	case user.FieldFacebookID:
		return m.FacebookID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldJoinedFrom:
		return m.OldJoinedFrom(ctx)
	case user.FieldBanned:
		return m.OldBanned(ctx)
	case user.FieldRank:
		return m.OldRank(ctx)
	case user.FieldGithubID:
		return m.OldGithubID(ctx)
	case user.FieldGoogleID:
		return m.OldGoogleID(ctx)
	case user.FieldFacebookID:
		return m.OldFacebookID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldJoinedFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedFrom(v)
		return nil
	case user.FieldBanned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanned(v)
		return nil
	case user.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case user.FieldGithubID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubID(v)
		return nil
	case user.FieldGoogleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleID(v)
		return nil
	case user.FieldFacebookID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacebookID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addrank != nil {
		fields = append(fields, user.FieldRank)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldRank:
		return m.AddedRank()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldJoinedFrom) {
		fields = append(fields, user.FieldJoinedFrom)
	}
	if m.FieldCleared(user.FieldGithubID) {
		fields = append(fields, user.FieldGithubID)
	}
	if m.FieldCleared(user.FieldGoogleID) {
		fields = append(fields, user.FieldGoogleID)
	}
	if m.FieldCleared(user.FieldFacebookID) {
		fields = append(fields, user.FieldFacebookID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldJoinedFrom:
		m.ClearJoinedFrom()
		return nil
	case user.FieldGithubID:
		m.ClearGithubID()
		return nil
	case user.FieldGoogleID:
		m.ClearGoogleID()
		return nil
	case user.FieldFacebookID:
		m.ClearFacebookID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldJoinedFrom:
		m.ResetJoinedFrom()
		return nil
	case user.FieldBanned:
		m.ResetBanned()
		return nil
	case user.FieldRank:
		m.ResetRank()
		return nil
	case user.FieldGithubID:
		m.ResetGithubID()
		return nil
	case user.FieldGoogleID:
		m.ResetGoogleID()
		return nil
	case user.FieldFacebookID:
		m.ResetFacebookID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.guides != nil {
		edges = append(edges, user.EdgeGuides)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.mods != nil {
		edges = append(edges, user.EdgeMods)
	}
	if m.groups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGuides:
		ids := make([]ent.Value, 0, len(m.guides))
		for id := range m.guides {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMods:
		ids := make([]ent.Value, 0, len(m.mods))
		for id := range m.mods {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedguides != nil {
		edges = append(edges, user.EdgeGuides)
	}
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedmods != nil {
		edges = append(edges, user.EdgeMods)
	}
	if m.removedgroups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGuides:
		ids := make([]ent.Value, 0, len(m.removedguides))
		for id := range m.removedguides {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMods:
		ids := make([]ent.Value, 0, len(m.removedmods))
		for id := range m.removedmods {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedguides {
		edges = append(edges, user.EdgeGuides)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedmods {
		edges = append(edges, user.EdgeMods)
	}
	if m.clearedgroups {
		edges = append(edges, user.EdgeGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeGuides:
		return m.clearedguides
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeMods:
		return m.clearedmods
	case user.EdgeGroups:
		return m.clearedgroups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeGuides:
		m.ResetGuides()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeMods:
		m.ResetMods()
		return nil
	case user.EdgeGroups:
		m.ResetGroups()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserGroupMutation represents an operation that mutates the UserGroup nodes in the graph.
type UserGroupMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	group_id      *string
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserGroup, error)
	predicates    []predicate.UserGroup
}

var _ ent.Mutation = (*UserGroupMutation)(nil)

// usergroupOption allows management of the mutation configuration using functional options.
type usergroupOption func(*UserGroupMutation)

// newUserGroupMutation creates new mutation for the UserGroup entity.
func newUserGroupMutation(c config, op Op, opts ...usergroupOption) *UserGroupMutation {
	m := &UserGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUserGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserGroupID sets the ID field of the mutation.
func withUserGroupID(id string) usergroupOption {
	return func(m *UserGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *UserGroup
		)
		m.oldValue = func(ctx context.Context) (*UserGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserGroup sets the old UserGroup of the mutation.
func withUserGroup(node *UserGroup) usergroupOption {
	return func(m *UserGroupMutation) {
		m.oldValue = func(context.Context) (*UserGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserGroup entities.
func (m *UserGroupMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserGroupMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserGroupMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserGroupMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserGroupMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserGroupMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usergroup.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserGroupMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usergroup.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserGroupMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usergroup.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserGroupMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserGroupMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserGroupMutation) ResetUserID() {
	m.user = nil
}

// SetGroupID sets the "group_id" field.
func (m *UserGroupMutation) SetGroupID(s string) {
	m.group_id = &s
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *UserGroupMutation) GroupID() (r string, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the UserGroup entity.
// If the UserGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGroupMutation) OldGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *UserGroupMutation) ResetGroupID() {
	m.group_id = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserGroupMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usergroup.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserGroupMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserGroupMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserGroupMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserGroupMutation builder.
func (m *UserGroupMutation) Where(ps ...predicate.UserGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserGroup).
func (m *UserGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserGroupMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, usergroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usergroup.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usergroup.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, usergroup.FieldUserID)
	}
	if m.group_id != nil {
		fields = append(fields, usergroup.FieldGroupID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usergroup.FieldCreatedAt:
		return m.CreatedAt()
	case usergroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case usergroup.FieldDeletedAt:
		return m.DeletedAt()
	case usergroup.FieldUserID:
		return m.UserID()
	case usergroup.FieldGroupID:
		return m.GroupID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usergroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usergroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usergroup.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usergroup.FieldUserID:
		return m.OldUserID(ctx)
	case usergroup.FieldGroupID:
		return m.OldGroupID(ctx)
	}
	return nil, fmt.Errorf("unknown UserGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usergroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usergroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usergroup.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usergroup.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usergroup.FieldGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown UserGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usergroup.FieldDeletedAt) {
		fields = append(fields, usergroup.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserGroupMutation) ClearField(name string) error {
	switch name {
	case usergroup.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserGroupMutation) ResetField(name string) error {
	switch name {
	case usergroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usergroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usergroup.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usergroup.FieldUserID:
		m.ResetUserID()
		return nil
	case usergroup.FieldGroupID:
		m.ResetGroupID()
		return nil
	}
	return fmt.Errorf("unknown UserGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usergroup.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usergroup.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usergroup.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case usergroup.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserGroupMutation) ClearEdge(name string) error {
	switch name {
	case usergroup.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserGroupMutation) ResetEdge(name string) error {
	switch name {
	case usergroup.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserGroup edge %s", name)
}

// UserModMutation represents an operation that mutates the UserMod nodes in the graph.
type UserModMutation struct {
	config
	op            Op
	typ           string
	role          *string
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	mod           *string
	clearedmod    bool
	done          bool
	oldValue      func(context.Context) (*UserMod, error)
	predicates    []predicate.UserMod
}

var _ ent.Mutation = (*UserModMutation)(nil)

// usermodOption allows management of the mutation configuration using functional options.
type usermodOption func(*UserModMutation)

// newUserModMutation creates new mutation for the UserMod entity.
func newUserModMutation(c config, op Op, opts ...usermodOption) *UserModMutation {
	m := &UserModMutation{
		config:        c,
		op:            op,
		typ:           TypeUserMod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserModMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserModMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserID sets the "user_id" field.
func (m *UserModMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserModMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserModMutation) ResetUserID() {
	m.user = nil
}

// SetModID sets the "mod_id" field.
func (m *UserModMutation) SetModID(s string) {
	m.mod = &s
}

// ModID returns the value of the "mod_id" field in the mutation.
func (m *UserModMutation) ModID() (r string, exists bool) {
	v := m.mod
	if v == nil {
		return
	}
	return *v, true
}

// ResetModID resets all changes to the "mod_id" field.
func (m *UserModMutation) ResetModID() {
	m.mod = nil
}

// SetRole sets the "role" field.
func (m *UserModMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserModMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *UserModMutation) ResetRole() {
	m.role = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserModMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usermod.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserModMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserModMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserModMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearMod clears the "mod" edge to the Mod entity.
func (m *UserModMutation) ClearMod() {
	m.clearedmod = true
	m.clearedFields[usermod.FieldModID] = struct{}{}
}

// ModCleared reports if the "mod" edge to the Mod entity was cleared.
func (m *UserModMutation) ModCleared() bool {
	return m.clearedmod
}

// ModIDs returns the "mod" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModID instead. It exists only for internal usage by the builders.
func (m *UserModMutation) ModIDs() (ids []string) {
	if id := m.mod; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMod resets all changes to the "mod" edge.
func (m *UserModMutation) ResetMod() {
	m.mod = nil
	m.clearedmod = false
}

// Where appends a list predicates to the UserModMutation builder.
func (m *UserModMutation) Where(ps ...predicate.UserMod) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserModMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserModMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserMod, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserModMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserModMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserMod).
func (m *UserModMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserModMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, usermod.FieldUserID)
	}
	if m.mod != nil {
		fields = append(fields, usermod.FieldModID)
	}
	if m.role != nil {
		fields = append(fields, usermod.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserModMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usermod.FieldUserID:
		return m.UserID()
	case usermod.FieldModID:
		return m.ModID()
	case usermod.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserModMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserMod does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserModMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usermod.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usermod.FieldModID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModID(v)
		return nil
	case usermod.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown UserMod field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserModMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserModMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserModMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserMod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserModMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserModMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserModMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserMod nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserModMutation) ResetField(name string) error {
	switch name {
	case usermod.FieldUserID:
		m.ResetUserID()
		return nil
	case usermod.FieldModID:
		m.ResetModID()
		return nil
	case usermod.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserMod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserModMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usermod.EdgeUser)
	}
	if m.mod != nil {
		edges = append(edges, usermod.EdgeMod)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserModMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usermod.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usermod.EdgeMod:
		if id := m.mod; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserModMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserModMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserModMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usermod.EdgeUser)
	}
	if m.clearedmod {
		edges = append(edges, usermod.EdgeMod)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserModMutation) EdgeCleared(name string) bool {
	switch name {
	case usermod.EdgeUser:
		return m.cleareduser
	case usermod.EdgeMod:
		return m.clearedmod
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserModMutation) ClearEdge(name string) error {
	switch name {
	case usermod.EdgeUser:
		m.ClearUser()
		return nil
	case usermod.EdgeMod:
		m.ClearMod()
		return nil
	}
	return fmt.Errorf("unknown UserMod unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserModMutation) ResetEdge(name string) error {
	switch name {
	case usermod.EdgeUser:
		m.ResetUser()
		return nil
	case usermod.EdgeMod:
		m.ResetMod()
		return nil
	}
	return fmt.Errorf("unknown UserMod edge %s", name)
}

// UserSessionMutation represents an operation that mutates the UserSession nodes in the graph.
type UserSessionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token         *string
	user_agent    *string
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserSession, error)
	predicates    []predicate.UserSession
}

var _ ent.Mutation = (*UserSessionMutation)(nil)

// usersessionOption allows management of the mutation configuration using functional options.
type usersessionOption func(*UserSessionMutation)

// newUserSessionMutation creates new mutation for the UserSession entity.
func newUserSessionMutation(c config, op Op, opts ...usersessionOption) *UserSessionMutation {
	m := &UserSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSessionID sets the ID field of the mutation.
func withUserSessionID(id string) usersessionOption {
	return func(m *UserSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSession
		)
		m.oldValue = func(ctx context.Context) (*UserSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSession sets the old UserSession of the mutation.
func withUserSession(node *UserSession) usersessionOption {
	return func(m *UserSessionMutation) {
		m.oldValue = func(context.Context) (*UserSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSession entities.
func (m *UserSessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserSessionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserSessionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserSessionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usersession.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserSessionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usersession.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserSessionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usersession.FieldDeletedAt)
}

// SetToken sets the "token" field.
func (m *UserSessionMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *UserSessionMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *UserSessionMutation) ResetToken() {
	m.token = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *UserSessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *UserSessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *UserSessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[usersession.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *UserSessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[usersession.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *UserSessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, usersession.FieldUserAgent)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserSessionMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserSessionMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSessionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserSessionMutation builder.
func (m *UserSessionMutation) Where(ps ...predicate.UserSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSession).
func (m *UserSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSessionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, usersession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersession.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usersession.FieldDeletedAt)
	}
	if m.token != nil {
		fields = append(fields, usersession.FieldToken)
	}
	if m.user_agent != nil {
		fields = append(fields, usersession.FieldUserAgent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersession.FieldCreatedAt:
		return m.CreatedAt()
	case usersession.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersession.FieldDeletedAt:
		return m.DeletedAt()
	case usersession.FieldToken:
		return m.Token()
	case usersession.FieldUserAgent:
		return m.UserAgent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersession.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usersession.FieldToken:
		return m.OldToken(ctx)
	case usersession.FieldUserAgent:
		return m.OldUserAgent(ctx)
	}
	return nil, fmt.Errorf("unknown UserSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersession.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usersession.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case usersession.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersession.FieldDeletedAt) {
		fields = append(fields, usersession.FieldDeletedAt)
	}
	if m.FieldCleared(usersession.FieldUserAgent) {
		fields = append(fields, usersession.FieldUserAgent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSessionMutation) ClearField(name string) error {
	switch name {
	case usersession.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case usersession.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	}
	return fmt.Errorf("unknown UserSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSessionMutation) ResetField(name string) error {
	switch name {
	case usersession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersession.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usersession.FieldToken:
		m.ResetToken()
		return nil
	case usersession.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usersession.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usersession.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersession.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSessionMutation) ClearEdge(name string) error {
	switch name {
	case usersession.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSessionMutation) ResetEdge(name string) error {
	switch name {
	case usersession.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserSession edge %s", name)
}

// VersionMutation represents an operation that mutates the Version nodes in the graph.
type VersionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	version             *string
	game_version        *string
	changelog           *string
	downloads           *uint
	adddownloads        *int
	key                 *string
	stability           *util.Stability
	approved            *bool
	hotness             *uint
	addhotness          *int
	denied              *bool
	metadata            *string
	mod_reference       *string
	version_major       *int
	addversion_major    *int
	version_minor       *int
	addversion_minor    *int
	version_patch       *int
	addversion_patch    *int
	size                *int64
	addsize             *int64
	hash                *string
	clearedFields       map[string]struct{}
	mod                 *string
	clearedmod          bool
	dependencies        map[string]struct{}
	removeddependencies map[string]struct{}
	cleareddependencies bool
	targets             map[string]struct{}
	removedtargets      map[string]struct{}
	clearedtargets      bool
	done                bool
	oldValue            func(context.Context) (*Version, error)
	predicates          []predicate.Version
}

var _ ent.Mutation = (*VersionMutation)(nil)

// versionOption allows management of the mutation configuration using functional options.
type versionOption func(*VersionMutation)

// newVersionMutation creates new mutation for the Version entity.
func newVersionMutation(c config, op Op, opts ...versionOption) *VersionMutation {
	m := &VersionMutation{
		config:        c,
		op:            op,
		typ:           TypeVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVersionID sets the ID field of the mutation.
func withVersionID(id string) versionOption {
	return func(m *VersionMutation) {
		var (
			err   error
			once  sync.Once
			value *Version
		)
		m.oldValue = func(ctx context.Context) (*Version, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Version.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVersion sets the old Version of the mutation.
func withVersion(node *Version) versionOption {
	return func(m *VersionMutation) {
		m.oldValue = func(context.Context) (*Version, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Version entities.
func (m *VersionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VersionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VersionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Version.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VersionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VersionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VersionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VersionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VersionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VersionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VersionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VersionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VersionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[version.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VersionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[version.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VersionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, version.FieldDeletedAt)
}

// SetModID sets the "mod_id" field.
func (m *VersionMutation) SetModID(s string) {
	m.mod = &s
}

// ModID returns the value of the "mod_id" field in the mutation.
func (m *VersionMutation) ModID() (r string, exists bool) {
	v := m.mod
	if v == nil {
		return
	}
	return *v, true
}

// OldModID returns the old "mod_id" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldModID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModID: %w", err)
	}
	return oldValue.ModID, nil
}

// ResetModID resets all changes to the "mod_id" field.
func (m *VersionMutation) ResetModID() {
	m.mod = nil
}

// SetVersion sets the "version" field.
func (m *VersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *VersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *VersionMutation) ResetVersion() {
	m.version = nil
}

// SetGameVersion sets the "game_version" field.
func (m *VersionMutation) SetGameVersion(s string) {
	m.game_version = &s
}

// GameVersion returns the value of the "game_version" field in the mutation.
func (m *VersionMutation) GameVersion() (r string, exists bool) {
	v := m.game_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGameVersion returns the old "game_version" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldGameVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameVersion: %w", err)
	}
	return oldValue.GameVersion, nil
}

// ResetGameVersion resets all changes to the "game_version" field.
func (m *VersionMutation) ResetGameVersion() {
	m.game_version = nil
}

// SetChangelog sets the "changelog" field.
func (m *VersionMutation) SetChangelog(s string) {
	m.changelog = &s
}

// Changelog returns the value of the "changelog" field in the mutation.
func (m *VersionMutation) Changelog() (r string, exists bool) {
	v := m.changelog
	if v == nil {
		return
	}
	return *v, true
}

// OldChangelog returns the old "changelog" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldChangelog(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangelog is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangelog requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangelog: %w", err)
	}
	return oldValue.Changelog, nil
}

// ClearChangelog clears the value of the "changelog" field.
func (m *VersionMutation) ClearChangelog() {
	m.changelog = nil
	m.clearedFields[version.FieldChangelog] = struct{}{}
}

// ChangelogCleared returns if the "changelog" field was cleared in this mutation.
func (m *VersionMutation) ChangelogCleared() bool {
	_, ok := m.clearedFields[version.FieldChangelog]
	return ok
}

// ResetChangelog resets all changes to the "changelog" field.
func (m *VersionMutation) ResetChangelog() {
	m.changelog = nil
	delete(m.clearedFields, version.FieldChangelog)
}

// SetDownloads sets the "downloads" field.
func (m *VersionMutation) SetDownloads(u uint) {
	m.downloads = &u
	m.adddownloads = nil
}

// Downloads returns the value of the "downloads" field in the mutation.
func (m *VersionMutation) Downloads() (r uint, exists bool) {
	v := m.downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloads returns the old "downloads" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldDownloads(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloads: %w", err)
	}
	return oldValue.Downloads, nil
}

// AddDownloads adds u to the "downloads" field.
func (m *VersionMutation) AddDownloads(u int) {
	if m.adddownloads != nil {
		*m.adddownloads += u
	} else {
		m.adddownloads = &u
	}
}

// AddedDownloads returns the value that was added to the "downloads" field in this mutation.
func (m *VersionMutation) AddedDownloads() (r int, exists bool) {
	v := m.adddownloads
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloads resets all changes to the "downloads" field.
func (m *VersionMutation) ResetDownloads() {
	m.downloads = nil
	m.adddownloads = nil
}

// SetKey sets the "key" field.
func (m *VersionMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *VersionMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ClearKey clears the value of the "key" field.
func (m *VersionMutation) ClearKey() {
	m.key = nil
	m.clearedFields[version.FieldKey] = struct{}{}
}

// KeyCleared returns if the "key" field was cleared in this mutation.
func (m *VersionMutation) KeyCleared() bool {
	_, ok := m.clearedFields[version.FieldKey]
	return ok
}

// ResetKey resets all changes to the "key" field.
func (m *VersionMutation) ResetKey() {
	m.key = nil
	delete(m.clearedFields, version.FieldKey)
}

// SetStability sets the "stability" field.
func (m *VersionMutation) SetStability(u util.Stability) {
	m.stability = &u
}

// Stability returns the value of the "stability" field in the mutation.
func (m *VersionMutation) Stability() (r util.Stability, exists bool) {
	v := m.stability
	if v == nil {
		return
	}
	return *v, true
}

// OldStability returns the old "stability" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldStability(ctx context.Context) (v util.Stability, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStability: %w", err)
	}
	return oldValue.Stability, nil
}

// ResetStability resets all changes to the "stability" field.
func (m *VersionMutation) ResetStability() {
	m.stability = nil
}

// SetApproved sets the "approved" field.
func (m *VersionMutation) SetApproved(b bool) {
	m.approved = &b
}

// Approved returns the value of the "approved" field in the mutation.
func (m *VersionMutation) Approved() (r bool, exists bool) {
	v := m.approved
	if v == nil {
		return
	}
	return *v, true
}

// OldApproved returns the old "approved" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproved: %w", err)
	}
	return oldValue.Approved, nil
}

// ResetApproved resets all changes to the "approved" field.
func (m *VersionMutation) ResetApproved() {
	m.approved = nil
}

// SetHotness sets the "hotness" field.
func (m *VersionMutation) SetHotness(u uint) {
	m.hotness = &u
	m.addhotness = nil
}

// Hotness returns the value of the "hotness" field in the mutation.
func (m *VersionMutation) Hotness() (r uint, exists bool) {
	v := m.hotness
	if v == nil {
		return
	}
	return *v, true
}

// OldHotness returns the old "hotness" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldHotness(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHotness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHotness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHotness: %w", err)
	}
	return oldValue.Hotness, nil
}

// AddHotness adds u to the "hotness" field.
func (m *VersionMutation) AddHotness(u int) {
	if m.addhotness != nil {
		*m.addhotness += u
	} else {
		m.addhotness = &u
	}
}

// AddedHotness returns the value that was added to the "hotness" field in this mutation.
func (m *VersionMutation) AddedHotness() (r int, exists bool) {
	v := m.addhotness
	if v == nil {
		return
	}
	return *v, true
}

// ResetHotness resets all changes to the "hotness" field.
func (m *VersionMutation) ResetHotness() {
	m.hotness = nil
	m.addhotness = nil
}

// SetDenied sets the "denied" field.
func (m *VersionMutation) SetDenied(b bool) {
	m.denied = &b
}

// Denied returns the value of the "denied" field in the mutation.
func (m *VersionMutation) Denied() (r bool, exists bool) {
	v := m.denied
	if v == nil {
		return
	}
	return *v, true
}

// OldDenied returns the old "denied" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldDenied(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDenied is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDenied requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDenied: %w", err)
	}
	return oldValue.Denied, nil
}

// ResetDenied resets all changes to the "denied" field.
func (m *VersionMutation) ResetDenied() {
	m.denied = nil
}

// SetMetadata sets the "metadata" field.
func (m *VersionMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *VersionMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *VersionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[version.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *VersionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[version.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *VersionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, version.FieldMetadata)
}

// SetModReference sets the "mod_reference" field.
func (m *VersionMutation) SetModReference(s string) {
	m.mod_reference = &s
}

// ModReference returns the value of the "mod_reference" field in the mutation.
func (m *VersionMutation) ModReference() (r string, exists bool) {
	v := m.mod_reference
	if v == nil {
		return
	}
	return *v, true
}

// OldModReference returns the old "mod_reference" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldModReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModReference: %w", err)
	}
	return oldValue.ModReference, nil
}

// ResetModReference resets all changes to the "mod_reference" field.
func (m *VersionMutation) ResetModReference() {
	m.mod_reference = nil
}

// SetVersionMajor sets the "version_major" field.
func (m *VersionMutation) SetVersionMajor(i int) {
	m.version_major = &i
	m.addversion_major = nil
}

// VersionMajor returns the value of the "version_major" field in the mutation.
func (m *VersionMutation) VersionMajor() (r int, exists bool) {
	v := m.version_major
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionMajor returns the old "version_major" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldVersionMajor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionMajor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionMajor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionMajor: %w", err)
	}
	return oldValue.VersionMajor, nil
}

// AddVersionMajor adds i to the "version_major" field.
func (m *VersionMutation) AddVersionMajor(i int) {
	if m.addversion_major != nil {
		*m.addversion_major += i
	} else {
		m.addversion_major = &i
	}
}

// AddedVersionMajor returns the value that was added to the "version_major" field in this mutation.
func (m *VersionMutation) AddedVersionMajor() (r int, exists bool) {
	v := m.addversion_major
	if v == nil {
		return
	}
	return *v, true
}

// ClearVersionMajor clears the value of the "version_major" field.
func (m *VersionMutation) ClearVersionMajor() {
	m.version_major = nil
	m.addversion_major = nil
	m.clearedFields[version.FieldVersionMajor] = struct{}{}
}

// VersionMajorCleared returns if the "version_major" field was cleared in this mutation.
func (m *VersionMutation) VersionMajorCleared() bool {
	_, ok := m.clearedFields[version.FieldVersionMajor]
	return ok
}

// ResetVersionMajor resets all changes to the "version_major" field.
func (m *VersionMutation) ResetVersionMajor() {
	m.version_major = nil
	m.addversion_major = nil
	delete(m.clearedFields, version.FieldVersionMajor)
}

// SetVersionMinor sets the "version_minor" field.
func (m *VersionMutation) SetVersionMinor(i int) {
	m.version_minor = &i
	m.addversion_minor = nil
}

// VersionMinor returns the value of the "version_minor" field in the mutation.
func (m *VersionMutation) VersionMinor() (r int, exists bool) {
	v := m.version_minor
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionMinor returns the old "version_minor" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldVersionMinor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionMinor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionMinor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionMinor: %w", err)
	}
	return oldValue.VersionMinor, nil
}

// AddVersionMinor adds i to the "version_minor" field.
func (m *VersionMutation) AddVersionMinor(i int) {
	if m.addversion_minor != nil {
		*m.addversion_minor += i
	} else {
		m.addversion_minor = &i
	}
}

// AddedVersionMinor returns the value that was added to the "version_minor" field in this mutation.
func (m *VersionMutation) AddedVersionMinor() (r int, exists bool) {
	v := m.addversion_minor
	if v == nil {
		return
	}
	return *v, true
}

// ClearVersionMinor clears the value of the "version_minor" field.
func (m *VersionMutation) ClearVersionMinor() {
	m.version_minor = nil
	m.addversion_minor = nil
	m.clearedFields[version.FieldVersionMinor] = struct{}{}
}

// VersionMinorCleared returns if the "version_minor" field was cleared in this mutation.
func (m *VersionMutation) VersionMinorCleared() bool {
	_, ok := m.clearedFields[version.FieldVersionMinor]
	return ok
}

// ResetVersionMinor resets all changes to the "version_minor" field.
func (m *VersionMutation) ResetVersionMinor() {
	m.version_minor = nil
	m.addversion_minor = nil
	delete(m.clearedFields, version.FieldVersionMinor)
}

// SetVersionPatch sets the "version_patch" field.
func (m *VersionMutation) SetVersionPatch(i int) {
	m.version_patch = &i
	m.addversion_patch = nil
}

// VersionPatch returns the value of the "version_patch" field in the mutation.
func (m *VersionMutation) VersionPatch() (r int, exists bool) {
	v := m.version_patch
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionPatch returns the old "version_patch" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldVersionPatch(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionPatch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionPatch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionPatch: %w", err)
	}
	return oldValue.VersionPatch, nil
}

// AddVersionPatch adds i to the "version_patch" field.
func (m *VersionMutation) AddVersionPatch(i int) {
	if m.addversion_patch != nil {
		*m.addversion_patch += i
	} else {
		m.addversion_patch = &i
	}
}

// AddedVersionPatch returns the value that was added to the "version_patch" field in this mutation.
func (m *VersionMutation) AddedVersionPatch() (r int, exists bool) {
	v := m.addversion_patch
	if v == nil {
		return
	}
	return *v, true
}

// ClearVersionPatch clears the value of the "version_patch" field.
func (m *VersionMutation) ClearVersionPatch() {
	m.version_patch = nil
	m.addversion_patch = nil
	m.clearedFields[version.FieldVersionPatch] = struct{}{}
}

// VersionPatchCleared returns if the "version_patch" field was cleared in this mutation.
func (m *VersionMutation) VersionPatchCleared() bool {
	_, ok := m.clearedFields[version.FieldVersionPatch]
	return ok
}

// ResetVersionPatch resets all changes to the "version_patch" field.
func (m *VersionMutation) ResetVersionPatch() {
	m.version_patch = nil
	m.addversion_patch = nil
	delete(m.clearedFields, version.FieldVersionPatch)
}

// SetSize sets the "size" field.
func (m *VersionMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *VersionMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *VersionMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *VersionMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *VersionMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[version.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *VersionMutation) SizeCleared() bool {
	_, ok := m.clearedFields[version.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *VersionMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, version.FieldSize)
}

// SetHash sets the "hash" field.
func (m *VersionMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *VersionMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ClearHash clears the value of the "hash" field.
func (m *VersionMutation) ClearHash() {
	m.hash = nil
	m.clearedFields[version.FieldHash] = struct{}{}
}

// HashCleared returns if the "hash" field was cleared in this mutation.
func (m *VersionMutation) HashCleared() bool {
	_, ok := m.clearedFields[version.FieldHash]
	return ok
}

// ResetHash resets all changes to the "hash" field.
func (m *VersionMutation) ResetHash() {
	m.hash = nil
	delete(m.clearedFields, version.FieldHash)
}

// ClearMod clears the "mod" edge to the Mod entity.
func (m *VersionMutation) ClearMod() {
	m.clearedmod = true
	m.clearedFields[version.FieldModID] = struct{}{}
}

// ModCleared reports if the "mod" edge to the Mod entity was cleared.
func (m *VersionMutation) ModCleared() bool {
	return m.clearedmod
}

// ModIDs returns the "mod" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModID instead. It exists only for internal usage by the builders.
func (m *VersionMutation) ModIDs() (ids []string) {
	if id := m.mod; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMod resets all changes to the "mod" edge.
func (m *VersionMutation) ResetMod() {
	m.mod = nil
	m.clearedmod = false
}

// AddDependencyIDs adds the "dependencies" edge to the Mod entity by ids.
func (m *VersionMutation) AddDependencyIDs(ids ...string) {
	if m.dependencies == nil {
		m.dependencies = make(map[string]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the Mod entity.
func (m *VersionMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the Mod entity was cleared.
func (m *VersionMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the Mod entity by IDs.
func (m *VersionMutation) RemoveDependencyIDs(ids ...string) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the Mod entity.
func (m *VersionMutation) RemovedDependenciesIDs() (ids []string) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *VersionMutation) DependenciesIDs() (ids []string) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *VersionMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// AddTargetIDs adds the "targets" edge to the VersionTarget entity by ids.
func (m *VersionMutation) AddTargetIDs(ids ...string) {
	if m.targets == nil {
		m.targets = make(map[string]struct{})
	}
	for i := range ids {
		m.targets[ids[i]] = struct{}{}
	}
}

// ClearTargets clears the "targets" edge to the VersionTarget entity.
func (m *VersionMutation) ClearTargets() {
	m.clearedtargets = true
}

// TargetsCleared reports if the "targets" edge to the VersionTarget entity was cleared.
func (m *VersionMutation) TargetsCleared() bool {
	return m.clearedtargets
}

// RemoveTargetIDs removes the "targets" edge to the VersionTarget entity by IDs.
func (m *VersionMutation) RemoveTargetIDs(ids ...string) {
	if m.removedtargets == nil {
		m.removedtargets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.targets, ids[i])
		m.removedtargets[ids[i]] = struct{}{}
	}
}

// RemovedTargets returns the removed IDs of the "targets" edge to the VersionTarget entity.
func (m *VersionMutation) RemovedTargetsIDs() (ids []string) {
	for id := range m.removedtargets {
		ids = append(ids, id)
	}
	return
}

// TargetsIDs returns the "targets" edge IDs in the mutation.
func (m *VersionMutation) TargetsIDs() (ids []string) {
	for id := range m.targets {
		ids = append(ids, id)
	}
	return
}

// ResetTargets resets all changes to the "targets" edge.
func (m *VersionMutation) ResetTargets() {
	m.targets = nil
	m.clearedtargets = false
	m.removedtargets = nil
}

// Where appends a list predicates to the VersionMutation builder.
func (m *VersionMutation) Where(ps ...predicate.Version) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Version, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Version).
func (m *VersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VersionMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, version.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, version.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, version.FieldDeletedAt)
	}
	if m.mod != nil {
		fields = append(fields, version.FieldModID)
	}
	if m.version != nil {
		fields = append(fields, version.FieldVersion)
	}
	if m.game_version != nil {
		fields = append(fields, version.FieldGameVersion)
	}
	if m.changelog != nil {
		fields = append(fields, version.FieldChangelog)
	}
	if m.downloads != nil {
		fields = append(fields, version.FieldDownloads)
	}
	if m.key != nil {
		fields = append(fields, version.FieldKey)
	}
	if m.stability != nil {
		fields = append(fields, version.FieldStability)
	}
	if m.approved != nil {
		fields = append(fields, version.FieldApproved)
	}
	if m.hotness != nil {
		fields = append(fields, version.FieldHotness)
	}
	if m.denied != nil {
		fields = append(fields, version.FieldDenied)
	}
	if m.metadata != nil {
		fields = append(fields, version.FieldMetadata)
	}
	if m.mod_reference != nil {
		fields = append(fields, version.FieldModReference)
	}
	if m.version_major != nil {
		fields = append(fields, version.FieldVersionMajor)
	}
	if m.version_minor != nil {
		fields = append(fields, version.FieldVersionMinor)
	}
	if m.version_patch != nil {
		fields = append(fields, version.FieldVersionPatch)
	}
	if m.size != nil {
		fields = append(fields, version.FieldSize)
	}
	if m.hash != nil {
		fields = append(fields, version.FieldHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case version.FieldCreatedAt:
		return m.CreatedAt()
	case version.FieldUpdatedAt:
		return m.UpdatedAt()
	case version.FieldDeletedAt:
		return m.DeletedAt()
	case version.FieldModID:
		return m.ModID()
	case version.FieldVersion:
		return m.Version()
	case version.FieldGameVersion:
		return m.GameVersion()
	case version.FieldChangelog:
		return m.Changelog()
	case version.FieldDownloads:
		return m.Downloads()
	case version.FieldKey:
		return m.Key()
	case version.FieldStability:
		return m.Stability()
	case version.FieldApproved:
		return m.Approved()
	case version.FieldHotness:
		return m.Hotness()
	case version.FieldDenied:
		return m.Denied()
	case version.FieldMetadata:
		return m.Metadata()
	case version.FieldModReference:
		return m.ModReference()
	case version.FieldVersionMajor:
		return m.VersionMajor()
	case version.FieldVersionMinor:
		return m.VersionMinor()
	case version.FieldVersionPatch:
		return m.VersionPatch()
	case version.FieldSize:
		return m.Size()
	case version.FieldHash:
		return m.Hash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case version.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case version.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case version.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case version.FieldModID:
		return m.OldModID(ctx)
	case version.FieldVersion:
		return m.OldVersion(ctx)
	case version.FieldGameVersion:
		return m.OldGameVersion(ctx)
	case version.FieldChangelog:
		return m.OldChangelog(ctx)
	case version.FieldDownloads:
		return m.OldDownloads(ctx)
	case version.FieldKey:
		return m.OldKey(ctx)
	case version.FieldStability:
		return m.OldStability(ctx)
	case version.FieldApproved:
		return m.OldApproved(ctx)
	case version.FieldHotness:
		return m.OldHotness(ctx)
	case version.FieldDenied:
		return m.OldDenied(ctx)
	case version.FieldMetadata:
		return m.OldMetadata(ctx)
	case version.FieldModReference:
		return m.OldModReference(ctx)
	case version.FieldVersionMajor:
		return m.OldVersionMajor(ctx)
	case version.FieldVersionMinor:
		return m.OldVersionMinor(ctx)
	case version.FieldVersionPatch:
		return m.OldVersionPatch(ctx)
	case version.FieldSize:
		return m.OldSize(ctx)
	case version.FieldHash:
		return m.OldHash(ctx)
	}
	return nil, fmt.Errorf("unknown Version field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case version.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case version.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case version.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case version.FieldModID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModID(v)
		return nil
	case version.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case version.FieldGameVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameVersion(v)
		return nil
	case version.FieldChangelog:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangelog(v)
		return nil
	case version.FieldDownloads:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloads(v)
		return nil
	case version.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case version.FieldStability:
		v, ok := value.(util.Stability)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStability(v)
		return nil
	case version.FieldApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproved(v)
		return nil
	case version.FieldHotness:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHotness(v)
		return nil
	case version.FieldDenied:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDenied(v)
		return nil
	case version.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case version.FieldModReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModReference(v)
		return nil
	case version.FieldVersionMajor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionMajor(v)
		return nil
	case version.FieldVersionMinor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionMinor(v)
		return nil
	case version.FieldVersionPatch:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionPatch(v)
		return nil
	case version.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case version.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VersionMutation) AddedFields() []string {
	var fields []string
	if m.adddownloads != nil {
		fields = append(fields, version.FieldDownloads)
	}
	if m.addhotness != nil {
		fields = append(fields, version.FieldHotness)
	}
	if m.addversion_major != nil {
		fields = append(fields, version.FieldVersionMajor)
	}
	if m.addversion_minor != nil {
		fields = append(fields, version.FieldVersionMinor)
	}
	if m.addversion_patch != nil {
		fields = append(fields, version.FieldVersionPatch)
	}
	if m.addsize != nil {
		fields = append(fields, version.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case version.FieldDownloads:
		return m.AddedDownloads()
	case version.FieldHotness:
		return m.AddedHotness()
	case version.FieldVersionMajor:
		return m.AddedVersionMajor()
	case version.FieldVersionMinor:
		return m.AddedVersionMinor()
	case version.FieldVersionPatch:
		return m.AddedVersionPatch()
	case version.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case version.FieldDownloads:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloads(v)
		return nil
	case version.FieldHotness:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHotness(v)
		return nil
	case version.FieldVersionMajor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionMajor(v)
		return nil
	case version.FieldVersionMinor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionMinor(v)
		return nil
	case version.FieldVersionPatch:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionPatch(v)
		return nil
	case version.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Version numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(version.FieldDeletedAt) {
		fields = append(fields, version.FieldDeletedAt)
	}
	if m.FieldCleared(version.FieldChangelog) {
		fields = append(fields, version.FieldChangelog)
	}
	if m.FieldCleared(version.FieldKey) {
		fields = append(fields, version.FieldKey)
	}
	if m.FieldCleared(version.FieldMetadata) {
		fields = append(fields, version.FieldMetadata)
	}
	if m.FieldCleared(version.FieldVersionMajor) {
		fields = append(fields, version.FieldVersionMajor)
	}
	if m.FieldCleared(version.FieldVersionMinor) {
		fields = append(fields, version.FieldVersionMinor)
	}
	if m.FieldCleared(version.FieldVersionPatch) {
		fields = append(fields, version.FieldVersionPatch)
	}
	if m.FieldCleared(version.FieldSize) {
		fields = append(fields, version.FieldSize)
	}
	if m.FieldCleared(version.FieldHash) {
		fields = append(fields, version.FieldHash)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VersionMutation) ClearField(name string) error {
	switch name {
	case version.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case version.FieldChangelog:
		m.ClearChangelog()
		return nil
	case version.FieldKey:
		m.ClearKey()
		return nil
	case version.FieldMetadata:
		m.ClearMetadata()
		return nil
	case version.FieldVersionMajor:
		m.ClearVersionMajor()
		return nil
	case version.FieldVersionMinor:
		m.ClearVersionMinor()
		return nil
	case version.FieldVersionPatch:
		m.ClearVersionPatch()
		return nil
	case version.FieldSize:
		m.ClearSize()
		return nil
	case version.FieldHash:
		m.ClearHash()
		return nil
	}
	return fmt.Errorf("unknown Version nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VersionMutation) ResetField(name string) error {
	switch name {
	case version.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case version.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case version.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case version.FieldModID:
		m.ResetModID()
		return nil
	case version.FieldVersion:
		m.ResetVersion()
		return nil
	case version.FieldGameVersion:
		m.ResetGameVersion()
		return nil
	case version.FieldChangelog:
		m.ResetChangelog()
		return nil
	case version.FieldDownloads:
		m.ResetDownloads()
		return nil
	case version.FieldKey:
		m.ResetKey()
		return nil
	case version.FieldStability:
		m.ResetStability()
		return nil
	case version.FieldApproved:
		m.ResetApproved()
		return nil
	case version.FieldHotness:
		m.ResetHotness()
		return nil
	case version.FieldDenied:
		m.ResetDenied()
		return nil
	case version.FieldMetadata:
		m.ResetMetadata()
		return nil
	case version.FieldModReference:
		m.ResetModReference()
		return nil
	case version.FieldVersionMajor:
		m.ResetVersionMajor()
		return nil
	case version.FieldVersionMinor:
		m.ResetVersionMinor()
		return nil
	case version.FieldVersionPatch:
		m.ResetVersionPatch()
		return nil
	case version.FieldSize:
		m.ResetSize()
		return nil
	case version.FieldHash:
		m.ResetHash()
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.mod != nil {
		edges = append(edges, version.EdgeMod)
	}
	if m.dependencies != nil {
		edges = append(edges, version.EdgeDependencies)
	}
	if m.targets != nil {
		edges = append(edges, version.EdgeTargets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case version.EdgeMod:
		if id := m.mod; id != nil {
			return []ent.Value{*id}
		}
	case version.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	case version.EdgeTargets:
		ids := make([]ent.Value, 0, len(m.targets))
		for id := range m.targets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddependencies != nil {
		edges = append(edges, version.EdgeDependencies)
	}
	if m.removedtargets != nil {
		edges = append(edges, version.EdgeTargets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VersionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case version.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	case version.EdgeTargets:
		ids := make([]ent.Value, 0, len(m.removedtargets))
		for id := range m.removedtargets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmod {
		edges = append(edges, version.EdgeMod)
	}
	if m.cleareddependencies {
		edges = append(edges, version.EdgeDependencies)
	}
	if m.clearedtargets {
		edges = append(edges, version.EdgeTargets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VersionMutation) EdgeCleared(name string) bool {
	switch name {
	case version.EdgeMod:
		return m.clearedmod
	case version.EdgeDependencies:
		return m.cleareddependencies
	case version.EdgeTargets:
		return m.clearedtargets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VersionMutation) ClearEdge(name string) error {
	switch name {
	case version.EdgeMod:
		m.ClearMod()
		return nil
	}
	return fmt.Errorf("unknown Version unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VersionMutation) ResetEdge(name string) error {
	switch name {
	case version.EdgeMod:
		m.ResetMod()
		return nil
	case version.EdgeDependencies:
		m.ResetDependencies()
		return nil
	case version.EdgeTargets:
		m.ResetTargets()
		return nil
	}
	return fmt.Errorf("unknown Version edge %s", name)
}

// VersionDependencyMutation represents an operation that mutates the VersionDependency nodes in the graph.
type VersionDependencyMutation struct {
	config
	op             Op
	typ            string
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	condition      *string
	optional       *bool
	clearedFields  map[string]struct{}
	version        *string
	clearedversion bool
	mod            *string
	clearedmod     bool
	done           bool
	oldValue       func(context.Context) (*VersionDependency, error)
	predicates     []predicate.VersionDependency
}

var _ ent.Mutation = (*VersionDependencyMutation)(nil)

// versiondependencyOption allows management of the mutation configuration using functional options.
type versiondependencyOption func(*VersionDependencyMutation)

// newVersionDependencyMutation creates new mutation for the VersionDependency entity.
func newVersionDependencyMutation(c config, op Op, opts ...versiondependencyOption) *VersionDependencyMutation {
	m := &VersionDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeVersionDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VersionDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VersionDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VersionDependencyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VersionDependencyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VersionDependencyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VersionDependencyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VersionDependencyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VersionDependencyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VersionDependencyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VersionDependencyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VersionDependencyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[versiondependency.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VersionDependencyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[versiondependency.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VersionDependencyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, versiondependency.FieldDeletedAt)
}

// SetVersionID sets the "version_id" field.
func (m *VersionDependencyMutation) SetVersionID(s string) {
	m.version = &s
}

// VersionID returns the value of the "version_id" field in the mutation.
func (m *VersionDependencyMutation) VersionID() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionID resets all changes to the "version_id" field.
func (m *VersionDependencyMutation) ResetVersionID() {
	m.version = nil
}

// SetModID sets the "mod_id" field.
func (m *VersionDependencyMutation) SetModID(s string) {
	m.mod = &s
}

// ModID returns the value of the "mod_id" field in the mutation.
func (m *VersionDependencyMutation) ModID() (r string, exists bool) {
	v := m.mod
	if v == nil {
		return
	}
	return *v, true
}

// ResetModID resets all changes to the "mod_id" field.
func (m *VersionDependencyMutation) ResetModID() {
	m.mod = nil
}

// SetCondition sets the "condition" field.
func (m *VersionDependencyMutation) SetCondition(s string) {
	m.condition = &s
}

// Condition returns the value of the "condition" field in the mutation.
func (m *VersionDependencyMutation) Condition() (r string, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// ResetCondition resets all changes to the "condition" field.
func (m *VersionDependencyMutation) ResetCondition() {
	m.condition = nil
}

// SetOptional sets the "optional" field.
func (m *VersionDependencyMutation) SetOptional(b bool) {
	m.optional = &b
}

// Optional returns the value of the "optional" field in the mutation.
func (m *VersionDependencyMutation) Optional() (r bool, exists bool) {
	v := m.optional
	if v == nil {
		return
	}
	return *v, true
}

// ResetOptional resets all changes to the "optional" field.
func (m *VersionDependencyMutation) ResetOptional() {
	m.optional = nil
}

// ClearVersion clears the "version" edge to the Version entity.
func (m *VersionDependencyMutation) ClearVersion() {
	m.clearedversion = true
	m.clearedFields[versiondependency.FieldVersionID] = struct{}{}
}

// VersionCleared reports if the "version" edge to the Version entity was cleared.
func (m *VersionDependencyMutation) VersionCleared() bool {
	return m.clearedversion
}

// VersionIDs returns the "version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VersionID instead. It exists only for internal usage by the builders.
func (m *VersionDependencyMutation) VersionIDs() (ids []string) {
	if id := m.version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVersion resets all changes to the "version" edge.
func (m *VersionDependencyMutation) ResetVersion() {
	m.version = nil
	m.clearedversion = false
}

// ClearMod clears the "mod" edge to the Mod entity.
func (m *VersionDependencyMutation) ClearMod() {
	m.clearedmod = true
	m.clearedFields[versiondependency.FieldModID] = struct{}{}
}

// ModCleared reports if the "mod" edge to the Mod entity was cleared.
func (m *VersionDependencyMutation) ModCleared() bool {
	return m.clearedmod
}

// ModIDs returns the "mod" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModID instead. It exists only for internal usage by the builders.
func (m *VersionDependencyMutation) ModIDs() (ids []string) {
	if id := m.mod; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMod resets all changes to the "mod" edge.
func (m *VersionDependencyMutation) ResetMod() {
	m.mod = nil
	m.clearedmod = false
}

// Where appends a list predicates to the VersionDependencyMutation builder.
func (m *VersionDependencyMutation) Where(ps ...predicate.VersionDependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VersionDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VersionDependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VersionDependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VersionDependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VersionDependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VersionDependency).
func (m *VersionDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VersionDependencyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, versiondependency.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, versiondependency.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, versiondependency.FieldDeletedAt)
	}
	if m.version != nil {
		fields = append(fields, versiondependency.FieldVersionID)
	}
	if m.mod != nil {
		fields = append(fields, versiondependency.FieldModID)
	}
	if m.condition != nil {
		fields = append(fields, versiondependency.FieldCondition)
	}
	if m.optional != nil {
		fields = append(fields, versiondependency.FieldOptional)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VersionDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case versiondependency.FieldCreatedAt:
		return m.CreatedAt()
	case versiondependency.FieldUpdatedAt:
		return m.UpdatedAt()
	case versiondependency.FieldDeletedAt:
		return m.DeletedAt()
	case versiondependency.FieldVersionID:
		return m.VersionID()
	case versiondependency.FieldModID:
		return m.ModID()
	case versiondependency.FieldCondition:
		return m.Condition()
	case versiondependency.FieldOptional:
		return m.Optional()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VersionDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema VersionDependency does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case versiondependency.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case versiondependency.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case versiondependency.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case versiondependency.FieldVersionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionID(v)
		return nil
	case versiondependency.FieldModID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModID(v)
		return nil
	case versiondependency.FieldCondition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	case versiondependency.FieldOptional:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptional(v)
		return nil
	}
	return fmt.Errorf("unknown VersionDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VersionDependencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VersionDependencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VersionDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VersionDependencyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(versiondependency.FieldDeletedAt) {
		fields = append(fields, versiondependency.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VersionDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VersionDependencyMutation) ClearField(name string) error {
	switch name {
	case versiondependency.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown VersionDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VersionDependencyMutation) ResetField(name string) error {
	switch name {
	case versiondependency.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case versiondependency.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case versiondependency.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case versiondependency.FieldVersionID:
		m.ResetVersionID()
		return nil
	case versiondependency.FieldModID:
		m.ResetModID()
		return nil
	case versiondependency.FieldCondition:
		m.ResetCondition()
		return nil
	case versiondependency.FieldOptional:
		m.ResetOptional()
		return nil
	}
	return fmt.Errorf("unknown VersionDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VersionDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.version != nil {
		edges = append(edges, versiondependency.EdgeVersion)
	}
	if m.mod != nil {
		edges = append(edges, versiondependency.EdgeMod)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VersionDependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case versiondependency.EdgeVersion:
		if id := m.version; id != nil {
			return []ent.Value{*id}
		}
	case versiondependency.EdgeMod:
		if id := m.mod; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VersionDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VersionDependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VersionDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedversion {
		edges = append(edges, versiondependency.EdgeVersion)
	}
	if m.clearedmod {
		edges = append(edges, versiondependency.EdgeMod)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VersionDependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case versiondependency.EdgeVersion:
		return m.clearedversion
	case versiondependency.EdgeMod:
		return m.clearedmod
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VersionDependencyMutation) ClearEdge(name string) error {
	switch name {
	case versiondependency.EdgeVersion:
		m.ClearVersion()
		return nil
	case versiondependency.EdgeMod:
		m.ClearMod()
		return nil
	}
	return fmt.Errorf("unknown VersionDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VersionDependencyMutation) ResetEdge(name string) error {
	switch name {
	case versiondependency.EdgeVersion:
		m.ResetVersion()
		return nil
	case versiondependency.EdgeMod:
		m.ResetMod()
		return nil
	}
	return fmt.Errorf("unknown VersionDependency edge %s", name)
}

// VersionTargetMutation represents an operation that mutates the VersionTarget nodes in the graph.
type VersionTargetMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	target_name        *string
	key                *string
	hash               *string
	size               *int64
	addsize            *int64
	clearedFields      map[string]struct{}
	sml_version        *string
	clearedsml_version bool
	done               bool
	oldValue           func(context.Context) (*VersionTarget, error)
	predicates         []predicate.VersionTarget
}

var _ ent.Mutation = (*VersionTargetMutation)(nil)

// versiontargetOption allows management of the mutation configuration using functional options.
type versiontargetOption func(*VersionTargetMutation)

// newVersionTargetMutation creates new mutation for the VersionTarget entity.
func newVersionTargetMutation(c config, op Op, opts ...versiontargetOption) *VersionTargetMutation {
	m := &VersionTargetMutation{
		config:        c,
		op:            op,
		typ:           TypeVersionTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVersionTargetID sets the ID field of the mutation.
func withVersionTargetID(id string) versiontargetOption {
	return func(m *VersionTargetMutation) {
		var (
			err   error
			once  sync.Once
			value *VersionTarget
		)
		m.oldValue = func(ctx context.Context) (*VersionTarget, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VersionTarget.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVersionTarget sets the old VersionTarget of the mutation.
func withVersionTarget(node *VersionTarget) versiontargetOption {
	return func(m *VersionTargetMutation) {
		m.oldValue = func(context.Context) (*VersionTarget, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VersionTargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VersionTargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VersionTarget entities.
func (m *VersionTargetMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VersionTargetMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VersionTargetMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VersionTarget.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersionID sets the "version_id" field.
func (m *VersionTargetMutation) SetVersionID(s string) {
	m.sml_version = &s
}

// VersionID returns the value of the "version_id" field in the mutation.
func (m *VersionTargetMutation) VersionID() (r string, exists bool) {
	v := m.sml_version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionID returns the old "version_id" field's value of the VersionTarget entity.
// If the VersionTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionTargetMutation) OldVersionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionID: %w", err)
	}
	return oldValue.VersionID, nil
}

// ResetVersionID resets all changes to the "version_id" field.
func (m *VersionTargetMutation) ResetVersionID() {
	m.sml_version = nil
}

// SetTargetName sets the "target_name" field.
func (m *VersionTargetMutation) SetTargetName(s string) {
	m.target_name = &s
}

// TargetName returns the value of the "target_name" field in the mutation.
func (m *VersionTargetMutation) TargetName() (r string, exists bool) {
	v := m.target_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetName returns the old "target_name" field's value of the VersionTarget entity.
// If the VersionTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionTargetMutation) OldTargetName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetName: %w", err)
	}
	return oldValue.TargetName, nil
}

// ResetTargetName resets all changes to the "target_name" field.
func (m *VersionTargetMutation) ResetTargetName() {
	m.target_name = nil
}

// SetKey sets the "key" field.
func (m *VersionTargetMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *VersionTargetMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the VersionTarget entity.
// If the VersionTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionTargetMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ClearKey clears the value of the "key" field.
func (m *VersionTargetMutation) ClearKey() {
	m.key = nil
	m.clearedFields[versiontarget.FieldKey] = struct{}{}
}

// KeyCleared returns if the "key" field was cleared in this mutation.
func (m *VersionTargetMutation) KeyCleared() bool {
	_, ok := m.clearedFields[versiontarget.FieldKey]
	return ok
}

// ResetKey resets all changes to the "key" field.
func (m *VersionTargetMutation) ResetKey() {
	m.key = nil
	delete(m.clearedFields, versiontarget.FieldKey)
}

// SetHash sets the "hash" field.
func (m *VersionTargetMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *VersionTargetMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the VersionTarget entity.
// If the VersionTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionTargetMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ClearHash clears the value of the "hash" field.
func (m *VersionTargetMutation) ClearHash() {
	m.hash = nil
	m.clearedFields[versiontarget.FieldHash] = struct{}{}
}

// HashCleared returns if the "hash" field was cleared in this mutation.
func (m *VersionTargetMutation) HashCleared() bool {
	_, ok := m.clearedFields[versiontarget.FieldHash]
	return ok
}

// ResetHash resets all changes to the "hash" field.
func (m *VersionTargetMutation) ResetHash() {
	m.hash = nil
	delete(m.clearedFields, versiontarget.FieldHash)
}

// SetSize sets the "size" field.
func (m *VersionTargetMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *VersionTargetMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the VersionTarget entity.
// If the VersionTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionTargetMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *VersionTargetMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *VersionTargetMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *VersionTargetMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[versiontarget.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *VersionTargetMutation) SizeCleared() bool {
	_, ok := m.clearedFields[versiontarget.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *VersionTargetMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, versiontarget.FieldSize)
}

// SetSmlVersionID sets the "sml_version" edge to the Version entity by id.
func (m *VersionTargetMutation) SetSmlVersionID(id string) {
	m.sml_version = &id
}

// ClearSmlVersion clears the "sml_version" edge to the Version entity.
func (m *VersionTargetMutation) ClearSmlVersion() {
	m.clearedsml_version = true
	m.clearedFields[versiontarget.FieldVersionID] = struct{}{}
}

// SmlVersionCleared reports if the "sml_version" edge to the Version entity was cleared.
func (m *VersionTargetMutation) SmlVersionCleared() bool {
	return m.clearedsml_version
}

// SmlVersionID returns the "sml_version" edge ID in the mutation.
func (m *VersionTargetMutation) SmlVersionID() (id string, exists bool) {
	if m.sml_version != nil {
		return *m.sml_version, true
	}
	return
}

// SmlVersionIDs returns the "sml_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SmlVersionID instead. It exists only for internal usage by the builders.
func (m *VersionTargetMutation) SmlVersionIDs() (ids []string) {
	if id := m.sml_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSmlVersion resets all changes to the "sml_version" edge.
func (m *VersionTargetMutation) ResetSmlVersion() {
	m.sml_version = nil
	m.clearedsml_version = false
}

// Where appends a list predicates to the VersionTargetMutation builder.
func (m *VersionTargetMutation) Where(ps ...predicate.VersionTarget) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VersionTargetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VersionTargetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VersionTarget, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VersionTargetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VersionTargetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VersionTarget).
func (m *VersionTargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VersionTargetMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.sml_version != nil {
		fields = append(fields, versiontarget.FieldVersionID)
	}
	if m.target_name != nil {
		fields = append(fields, versiontarget.FieldTargetName)
	}
	if m.key != nil {
		fields = append(fields, versiontarget.FieldKey)
	}
	if m.hash != nil {
		fields = append(fields, versiontarget.FieldHash)
	}
	if m.size != nil {
		fields = append(fields, versiontarget.FieldSize)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VersionTargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case versiontarget.FieldVersionID:
		return m.VersionID()
	case versiontarget.FieldTargetName:
		return m.TargetName()
	case versiontarget.FieldKey:
		return m.Key()
	case versiontarget.FieldHash:
		return m.Hash()
	case versiontarget.FieldSize:
		return m.Size()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VersionTargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case versiontarget.FieldVersionID:
		return m.OldVersionID(ctx)
	case versiontarget.FieldTargetName:
		return m.OldTargetName(ctx)
	case versiontarget.FieldKey:
		return m.OldKey(ctx)
	case versiontarget.FieldHash:
		return m.OldHash(ctx)
	case versiontarget.FieldSize:
		return m.OldSize(ctx)
	}
	return nil, fmt.Errorf("unknown VersionTarget field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionTargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case versiontarget.FieldVersionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionID(v)
		return nil
	case versiontarget.FieldTargetName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetName(v)
		return nil
	case versiontarget.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case versiontarget.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case versiontarget.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	}
	return fmt.Errorf("unknown VersionTarget field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VersionTargetMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, versiontarget.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VersionTargetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case versiontarget.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionTargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case versiontarget.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown VersionTarget numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VersionTargetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(versiontarget.FieldKey) {
		fields = append(fields, versiontarget.FieldKey)
	}
	if m.FieldCleared(versiontarget.FieldHash) {
		fields = append(fields, versiontarget.FieldHash)
	}
	if m.FieldCleared(versiontarget.FieldSize) {
		fields = append(fields, versiontarget.FieldSize)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VersionTargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VersionTargetMutation) ClearField(name string) error {
	switch name {
	case versiontarget.FieldKey:
		m.ClearKey()
		return nil
	case versiontarget.FieldHash:
		m.ClearHash()
		return nil
	case versiontarget.FieldSize:
		m.ClearSize()
		return nil
	}
	return fmt.Errorf("unknown VersionTarget nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VersionTargetMutation) ResetField(name string) error {
	switch name {
	case versiontarget.FieldVersionID:
		m.ResetVersionID()
		return nil
	case versiontarget.FieldTargetName:
		m.ResetTargetName()
		return nil
	case versiontarget.FieldKey:
		m.ResetKey()
		return nil
	case versiontarget.FieldHash:
		m.ResetHash()
		return nil
	case versiontarget.FieldSize:
		m.ResetSize()
		return nil
	}
	return fmt.Errorf("unknown VersionTarget field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VersionTargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sml_version != nil {
		edges = append(edges, versiontarget.EdgeSmlVersion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VersionTargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case versiontarget.EdgeSmlVersion:
		if id := m.sml_version; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VersionTargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VersionTargetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VersionTargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsml_version {
		edges = append(edges, versiontarget.EdgeSmlVersion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VersionTargetMutation) EdgeCleared(name string) bool {
	switch name {
	case versiontarget.EdgeSmlVersion:
		return m.clearedsml_version
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VersionTargetMutation) ClearEdge(name string) error {
	switch name {
	case versiontarget.EdgeSmlVersion:
		m.ClearSmlVersion()
		return nil
	}
	return fmt.Errorf("unknown VersionTarget unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VersionTargetMutation) ResetEdge(name string) error {
	switch name {
	case versiontarget.EdgeSmlVersion:
		m.ResetSmlVersion()
		return nil
	}
	return fmt.Errorf("unknown VersionTarget edge %s", name)
}
